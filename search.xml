<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>一则迟来的碎碎念</title>
      <link href="posts/c5cc4bc3/"/>
      <url>posts/c5cc4bc3/</url>
      
        <content type="html"><![CDATA[<p>这件事发生在一个月之前。因为我太热心，帮助了一位牛客网友找到了实习，却没得到应有回报的事情（好歹有点表示吧，我发了这段文字才开始说请我吃饭？说什么都晚了，求生欲真的强的一批，我怕了）。我没有完全明示，只是想以一种更高级的手段抨击他罢了。</p><p>社会教我做人，这一天跟很多朋友聊天，也就「我如何处理众多来询问我项目或者找实习取经的牛客网友」给出了建议。很感谢父母、老社会人以及善于沟通交流的其他朋友们的建议。我受教了。今后做人不会再这么善良。害人之心不可有，防人之心不可无。不过再想想，我帮助过的大部分人中，还是有点感恩之心的，突然间又感到有点欣慰。不指望你「滴水之恩当涌泉相报」吧，好歹给点物质感谢的表示就行啊，哪怕只是个客套话。</p><p>我的过分善良成就了一位竞争对手，这篇小作文，也将激励我从11月开始，要为秋招不懈努力。又想到了高中班主任说过的一句话：「一分干掉一千人」。希望一年后我再回看这篇小作文，我兑现到了哪一步。希望今年的我，不会成为明年的笑话吧。</p><p>我的运气虽然一直很差，但是我不允许任何人，以及这个世界亵渎我的努力。<strong>化悲愤为动力，是我这么多年走到现在的秘诀</strong>。这段文字也会一直激励我前行。话说回来，我总是强调和相信「天道酬勤」，<strong>终究只是一厢情愿罢了</strong>。就像是我暑假面试疯狂舔面试官一样，一厢情愿觉得自己准备好了就会要你一样（不招人的组，你准备再好都会成为hr眼中用来刷kpi的工具人）。实际上这个国度就是这样，总是强调个人努力，但是丝毫比不过遇上了好运气和好机遇强，运气总是比努力重要的多，甚至决定了你的一生。我就是一个鲜活的例子。想到这个，眼泪止不住往下流。</p><p>准备如果真的秋招成功了，尘埃落定了，我再想办法<strong>收费并给予</strong>这样的帮助。准备也开个公众号，开知识星球噶韭菜，看着大家天天为了大厂打卡，然后再回答大家的问题，岂不美哉。哎，这事情明年这个时候，拿到满意offer了再考虑吧。</p><p>在朋友圈发这些东西之前，我也想过这种行为是不是显得我格局太小，心眼太小？跟一个无关紧要的人置气，而且就是我前进道路上，一颗无关紧要的绊脚石罢了，自己大概率也能踢开它。希望真的会成为自己努力的动力，而不是成为让我从此失去信心而沉沦的源头。</p><p>后来想了想，有些话是真的不吐不快的。</p><a id="more"></a><hr><p>你唾手可得的一切，终将会以其他形式还给你；我本应得到却未得到的一切，也终将以其他形式还给我。</p><p>我始终相信天道酬勤，越努力越幸运。我相信我的努力，终将会被时间所认可，只是它到来的晚一些罢了，即使也遭遇了一时的挫折和现实、环境的阻拦，让我被迫错失最好的机遇。</p><p>我通过这一年来的努力好不容易得到的这一切，你凭借超凡的运气和机遇，以及我一年内努力的力量在短时间内唾手可得。可能你在背后也得意，自己一个月内得到了别人努力一年才得到的东西；可能也在笑我这一年的努力不值得，甚至觉得我努力方向错了，不及遇上一个千载难逢的机遇，以及自己到处求助别人强。</p><p>我相信，你即使现在唾手可得了这一切，省去了其他靠努力、靠时间积累的漫长过程，之后终将都会全数归还给你。 你现在借助运气和机遇飘的多高，之后就会摔得越惨。毕竟风口上的猪都能飞起来。</p><p>我也是过于善良，喜欢帮助别人，尽可能让别人少走弯路。却没想过自己帮助别人取得了成功，甚至连一句小小的感谢都换不到（物质感谢就更无从可谈了），只觉得自己成功只有自己的功劳（是自己social，找对了人、打赢了信息战的功劳，而不是我自己帮了忙的功劳），只知道继续索取、榨干我的一切，甚至觉得我提供的帮助只是举手之劳，觉得没帮够，没让你实现最高的目标，还想要更大的自行车。</p><p>前段时间，我曾因此怀疑过人生的不公，也怀疑过自己努力的方向是不是真的错了，也试图想从过去的挫折和苦恼中走出来。我也在想，我从来都不是一个容易因为挫折而垂头丧气的人，毕竟如果是自己的问题就总结和反思，不是自己的问题则静待更好的机遇出现。</p><p>可能是，自己帮了别人忙，成就了别人，自己的努力做了别人的嫁衣，别人没怎么感谢，甚至觉得嫁衣还不够好看，成为了导火索吧。我想通了，从以后开始，我也不会这么善良了。太善良只会给自己徒增苦恼，好人没好报。我不该帮助不该帮助的人，也是我活该了。</p><p>总是期望自己帮忙了，也能得到别人对等的帮忙。其他人怎么会帮竞争对手呢？人都是自私的，巴不得多榨干别人一分，好在最后凭借别人的力量，踩在别人头上，超越自己的竞争对手罢了。</p><p>诚然，这确实是一个只看结果不看过程的世界，别人只会关注你最终取得了什么，不会关注你取得的背后付出了多少努力和汗水，还是只凭借运气和机遇，还有别人的帮助，没付出多少努力。我慢慢也在学着接受这样的不公，毕竟好运从未眷顾过我这种非洲人。</p><p>成功固然需要努力，运气和机遇也同样重要。但是，努力决定下限，运气和机遇决定上限。 我相信真正努力过的人，再坏的机遇和运气都不会影响他取得最后的成功；没努力过的人，只想借别人力量，只想借助运气和机遇腾飞，终将会失败。</p><p>不是不报，时候未到，还有一年，走着瞧。我相信上帝不会亏待真正努力过的人，并且让只凭借运气和机遇成功的人现出原形。是骡子还是马，在最终的考验中，拉出来遛一遛便知。</p><p>共勉。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
            <tag> 失败 </tag>
            
            <tag> 成功 </tag>
            
            <tag> 机遇 </tag>
            
            <tag> 运气 </tag>
            
            <tag> 努力 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装CUDA的一些坑</title>
      <link href="posts/75df0b52/"/>
      <url>posts/75df0b52/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>一般来说，进行深度学习的任务时，为了训练的速度更快一些，一般会在GPU上进行训练。除了安装Tensorflow或Pytorch以外，还会安装CUDA和cuDNN（针对深度神经网络的加速库）来加速训练。</p><p>之前就听身边人说这东西很难安装，我当时还在想有啥东西能为难我这种配环境高手的。结果经过这一次痛苦的安装过程，自信心是真的受到了打击。</p><p>为了应对以后还有可能做同样事情的可能（当然，毕业了之后绝无可能），决定用这篇文章备忘一下。</p><a id="more"></a><h2 id="安装步骤">安装步骤</h2><h3 id="检查显卡驱动">检查显卡驱动</h3><p>首先得确认该机器是否有NVIDIA独立显卡。然后再检查是否安装了NVIDIA显卡驱动。</p><p>安装了之后在终端中输入 <code>nvidia-smi</code> 检查显卡驱动的安装情况。</p><p>其中，右上角的CUDA版本表示机器当前能安装的CUDA的最高版本：</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20220428184513462.png" alt="image-20220428184513462" style="zoom:50%;"></p><p>当然，由于Pytorch和Tensorflow目前不一定支持这个最高版本，所以一般不按照这个最高版本安装！</p><p>由于我用的机器已经有了显卡驱动，所以这一步的坑还没有踩，以后再说。</p><h3 id="下载并安装cuda和cudnn">下载并安装CUDA和cuDNN</h3><ol type="1"><li><p>在<a href="https://developer.nvidia.com/cuda-toolkit-archive">这里</a>找到想安装的CUDA版本，如果是Ubuntu，可以按照如下选择，按照如下方式安装（记住如果安装了显卡驱动，在安装的时候就不要勾选安装驱动了，否则会重复安装）：</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20220428185206312.png" alt="image-20220428185206312" style="zoom:50%;"></p></li><li><p>然后在<a href="https://developer.nvidia.com/rdp/cudnn-archive">这里</a>根据上一步选择的CUDA版本，下载对应版本的cuDNN。第一次下载需要注册。</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20220428185538492.png" alt="image-20220428185538492" style="zoom:50%;"></p></li></ol><p>下载了cuDNN之后，解压下载下来的压缩包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf &lt;压缩包&gt;</span><br></pre></td></tr></table></figure><p>将压缩包中对应的文件拷贝到CUDA安装路径的对应位置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo cp cuda/lib64/* /usr/<span class="built_in">local</span>/cuda-版本号/lib64/</span><br><span class="line">sudo cp cuda/include/* /usr/<span class="built_in">local</span>/cuda-版本号/include/ </span><br><span class="line">sudo chmod a+r /usr/<span class="built_in">local</span>/cuda-版本号/include/cudnn.h /usr/<span class="built_in">local</span>/cuda-版本号/lib64/libcudnn*</span><br></pre></td></tr></table></figure><p>在 <code>~/.bashrc</code> 中加入环境变量（这是用户变量，如果想加入系统变量，在Ubuntu应该编辑的是 <code>/etc/bash.bashrc</code>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/cuda-版本号/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/usr/<span class="built_in">local</span>/cuda-版本号/lib64:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure><p>让设置的环境变量立即生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"><span class="comment"># 如果编辑的是/etc/bash.bashrc：</span></span><br><span class="line"><span class="built_in">source</span> /etc/bash.bashrc</span><br></pre></td></tr></table></figure><h3 id="检查是否安装成功">检查是否安装成功</h3><p>在终端中输入命令：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvcc -V</span><br></pre></td></tr></table></figure><p>如果见到了类似如下的信息，说明已经安装了。（如果之前不知道是否安装了CUDA，如果没见到以下的信息，大概率就是没安装了）。</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20220428191021091.png" alt="image-20220428191021091" style="zoom:50%;"></p><p>但是仅凭上述信息无法判断是否安装成功，需要编译并运行CUDA提供的 <code>deviceQuery</code> 工具：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/cuda-版本号/samples/1_Utilities/deviceQuery</span><br><span class="line">sudo make</span><br><span class="line">./deviceQuery</span><br></pre></td></tr></table></figure><p>输出以下信息说明安装成功：</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20220428192129022.png" alt="image-20220428192129022" style="zoom:50%;"></p><h3 id="验证在pytorch中的可用性">验证在Pytorch中的可用性</h3><p>在 Python 终端中，按照如下输入如果能得到 <code>True</code> 说明Pytorch可以使用CUDA来训练了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> torch</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(torch.cuda.is_available())</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>如果想查看有几个GPU可以用，可以输入 <code>torch.cuda.device_count()</code> 来查看。</p><h2 id="如何选择cuda版本">如何选择CUDA版本</h2><p>上面的步骤乍一看很简单。但是这个东西最坑的地方在于，安装成功却不一定能正常使用。</p><p>如果跑程序的时候出现了类似以下的错误，大概率是因为安装的Pytorch版本和CUDA版本不兼容。</p><p>（按照支持的最高版本CUDA 11.4安装，使用项目作者推荐的Pytorch版本（1.4.0））</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20220428193311332.png" alt="image-20220428193311332" style="zoom:50%;"></p><p>（Pytorch升级到1.9.0，CUDA降级到11.1）</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20220428193425602.png" alt="image-20220428193425602" style="zoom:50%;"></p><p>那么解决的思路无非是两种：</p><ul><li><p>Pytorch版本较低，降低CUDA版本</p><ul><li><p>首先是像之前提的那样，不要使用上述提到的支持的最高版本安装</p></li><li><p>安装的CUDA版本不能太低，否则编译 <code>deviceQuery</code> 可能会出现如下错误。表示GPU过于新，不支持对应的架构（当然，太低的版本可能也不支持系统的gcc版本）：</p><p>最初降低到了1.4.0对应的10.1版本，10.1版本也是无法运行。编译 <code>deviceQuery</code> 出错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 降低到10.1版本出现的</span></span><br><span class="line">nvcc fatal: Unsupported gpu architecture <span class="string">&#x27;compute_30&#x27;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>升级Pytorch</p></li></ul><h3 id="下载cuda版本对应的pytorch版本">下载CUDA版本对应的Pytorch版本</h3><p>可以从<a href="https://pytorch.org/get-started/previous-versions/">这里</a>查询Pytorch各个版本支持的CUDA版本。</p><p>例如，从上述链接中查出了Pytorch 1.9.0版本支持CUDA的10.2和11.1版本。但是由于设备的GPU太新，按照10.x版本无法正常运行。所以选择CUDA 11.1版本。但还是有一个坑：</p><p>通过 <code>pip</code> 安装 Pytorch 1.9.0：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install torch==1.9.0</span><br></pre></td></tr></table></figure><p>在Python终端中，输入 <code>torch.version.cuda</code> 可以查看当前Pytorch版本支持的CUDA版本，输入 <code>torch.__version__</code> 查看当前Pytorch的版本。</p><p>输出如下：</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20220428200117828.png" alt="image-20220428200117828" style="zoom:50%;"></p><p>说明上述方法安装的Pytorch 1.9.0版本只支持CUDA 10.2，但是机器安装的是CUDA 11.1，两者之间还是不兼容。</p><p>因此需要安装支持CUDA 11.1的Pytorch1.9.0版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install torch==1.9.0+cu111 -f https://download.pytorch.org/whl/torch_stable.html</span><br></pre></td></tr></table></figure><p>这样输出就正常了，程序也能正常运行了：</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20220428200546030.png" alt="image-20220428200546030" style="zoom:50%;"></p><h2 id="多个cuda版本并存">多个CUDA版本并存</h2><p>由于第一次安装，当时安装的时候也没做好功课。结果面临要卸载之前安装好的CUDA的问题，很麻烦，而且也未必能卸载干净。</p><p>其实可以不用卸载，多个版本共存也是可以的，这样对于不同的Pytorch版本，也比较灵活。</p><p>只要修改好环境变量即可，不用的版本就注释掉：</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20220428201045821.png" alt="image-20220428201045821" style="zoom:50%;"></p><h2 id="后记">后记</h2><p>在无奈之下，我最终选择升级Pytorch，降级CUDA。不过侥幸的是，我运行的推荐使用Pytorch 1.4.0的代码也能正常运行。但是换了其他代码就不一定行了。因此在有些情况下，必须要使用低版本的Pytorch。至于怎么解决CUDA版本低带来的问题，到时候遇到了再说吧。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Pytorch </tag>
            
            <tag> CUDA </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编写第一个WebAssembly模块</title>
      <link href="posts/a8e1e305/"/>
      <url>posts/a8e1e305/</url>
      
        <content type="html"><![CDATA[<h2 id="环境">环境</h2><ul><li>操作系统：Ubuntu 18.04 64位</li><li>Chrome版本：84.0.4147.89，64位</li><li>Python版本：3.7.10</li><li>Emscripten SDK版本：3.1.2</li></ul><a id="more"></a><h2 id="预备工作">预备工作</h2><p>查看系统是否支持 <code>wasm</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&#x27;wasm&#x27;</span> /etc/mime.types</span><br></pre></td></tr></table></figure><p>若上述结果未显示，需要在文件 <code>/etc/mine.types</code> 中加入对 <code>wasm</code> 的支持：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/mime.types</span><br></pre></td></tr></table></figure><p>在其中加入 <code>application/wasm    wasm</code> ，保存文件即可。</p><h2 id="下载并安装-emscripten-sdk">下载并安装 Emscripten SDK</h2><p>Emscripten 工具包是将 C/C++代码编译为 WebAssembly 字节码的最成熟工具包。</p><p>从 GitHub 中下载代码：<a href="https://github.com/emscripten-core/emsdk" class="uri">https://github.com/emscripten-core/emsdk</a> 到本地，假设路径为 <code>EMSDK_HOME</code>。</p><p>进入到该目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> EMSDK_HOME</span><br></pre></td></tr></table></figure><p>下载 SDK 的最新工具：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./emsdk install latest</span><br></pre></td></tr></table></figure><p>运行以下命令来激活最新的 SDK：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./emsdk activate latest</span><br></pre></td></tr></table></figure><p>查看用 SDK 安装的工具列表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./emsdk list</span><br></pre></td></tr></table></figure><p>之后若想访问 Emscripten SDK 中的工具，可以使用如下途径（选择其一即可）：</p><h3 id="将相关路径加入到环境变量中">将相关路径加入到环境变量中</h3><p>例如在我的系统中，用户变量可定义在 <code>~/.bashrc</code> 中，系统变量可定义在 <code>/etc/bash.bashrc</code> 中。</p><p>往上述文件中的任意一个添加下述3条路径到环境变量 <code>PATH</code> 中：</p><ul><li><code>EMSDK_HOME</code></li><li><code>EMSDK_HOME/node/版本号/bin</code></li><li><code>EMSDK_HOME/upstream/emscripten</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;EMSDK_HOME:EMSDK_HOME/node/版本号/bin:EMSDK_HOME/upstream/emscripten:<span class="variable">$PATH</span>&quot;</span></span><br></pre></td></tr></table></figure><h3 id="激活环境">激活环境</h3><p>可在终端中输入如下命令为当前命令行激活环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> <span class="string">&quot;EMSDK_HOME/emsdk_env.sh&quot;</span></span><br></pre></td></tr></table></figure><p>也可在 <code>~/.bashrc</code> 或 <code>/etc/bash.bashrc</code> 中写入上述命令，这样每次打开终端就可以激活环境。</p><h2 id="用-emscripten-编译-cc并使用-html-模板">用 Emscripten 编译 C/C++并使用 HTML 模板</h2><p>可以创建一个模块，同时生成HTML和JavaScript文件。适用于快速测试代码，而不必创建 HTML 和 JavaScript 代码的时候。</p><p>编写程序 <code>calculate_primes.c</code> ，输出3到100000内的所有素数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;emscripten.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsPrime</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="number">2</span>) &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (value &lt;= <span class="number">1</span> || value % <span class="number">2</span> == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; (i * i) &lt;= value; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value % i == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> end = <span class="number">100000</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Prime numbers between %d and %d:\n&quot;</span>, start, end);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (IsPrime(i)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译 <code>calculate_primes.c</code> 并生成 WebAssembly 模块、JavaScript plumbing 文件和一个 HTML 模板。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emcc calculate_primes.c -o html_template.html</span><br></pre></td></tr></table></figure><p>下图中红框中标出的文件是新生成的文件。</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20220129190418016.png" alt="image-20220129190418016" style="zoom:50%;"></p><p>使用 Python 在当前路径上本地 Web 服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m http.server 8080</span><br></pre></td></tr></table></figure><p>在浏览器中打开 <a href="http://localhost:8080/html_template.html" class="uri">http://localhost:8080/html_template.html</a>：</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20220129194043637.png" alt="image-20220129194043637" style="zoom:50%;"></p><p>在上图中的黑色框中显示标准输出流中输出的内容。</p><h2 id="只让-emscripten-生成-javascript-plumbing-代码">只让 Emscripten 生成 JavaScript plumbing 代码</h2><p>可以创建一个模块，只生成 JavaScript 文件，不生成HTML文件。HTML 文件需要自己编写。这提供了一种灵活性，可以创建一个新的自定义 HTML 页面，也可以将生成的 JavaScript 引用添加到现有网页。这也是用于产品代码的典型方法，也是最常用的方法。</p><p>编译 <code>calculate_primes.c</code> ，让 Emscripten 创建 WebAssembly 模块和 JavaScript 文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emcc calculate_primes.c -o js_plumbing.js</span><br></pre></td></tr></table></figure><p>下图中红框中标出的文件是新生成的文件。</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20220129194748235.png" alt="image-20220129194748235" style="zoom:50%;"></p><p>创建HTML页面 <code>js_plumbing.html</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        HTML page I created for my WebAssembly module.</span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js_plumbing.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 Python 在当前路径上本地 Web 服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m http.server 8080</span><br></pre></td></tr></table></figure><p>在浏览器中打开 <a href="http://localhost:8080/js_plumbing.html" class="uri">http://localhost:8080/js_plumbing.html</a>：</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20220129195342982.png" alt="image-20220129195342982" style="zoom:50%;"></p><p>在浏览器的开发者工具的控制台中显示标准输出流输出的内容。</p><h2 id="让-emscripten-只生成-webassembly-文件">让 Emscripten 只生成 WebAssembly 文件</h2><p>可以只创建一个模块。此时必须自己编写 HTML 文件并下载和实例化模块所需要的 JavaScript。这个方法不太常用。</p><p>编写文件 <code>side_module.c</code>，该模块作为副模块（可以理解为不包含 <code>main()</code> 函数的C/C++模块），只包含一个递增函数 <code>Increment()</code> 和一个递减函数 <code>Decrement()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Increment</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (value + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Decrement</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (value - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译 <code>side_module.c</code> 并生成 WebAssembly 模块作为副模块（只导出 <code>Increment()</code> 这一个函数）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emcc side_module.c -s SIDE_MODULE=2 -O1 -s EXPORTED_FUNCTIONS=[<span class="string">&#x27;_Increment&#x27;</span>] -o side_module.wasm</span><br></pre></td></tr></table></figure><p>编译 <code>side_module.c</code> 并生成 WebAssembly 模块作为副模块（导出两个或多个函数）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emcc side_module.c -s SIDE_MODULE=2 -O1 -s <span class="string">&quot;EXPORTED_FUNCTIONS=[&#x27;_Increment&#x27;,&#x27;_Decrement&#x27;]&quot;</span> -o side_module.wasm</span><br></pre></td></tr></table></figure><ul><li><code>-s SIDE_MODULE=2</code> 指明在生成的模块中不包含 C 标准库代码，也不生成 JavaScript plumbing 文件。</li><li><code>-O1</code>：编译器优化标记。如果没有指定优化标记，则 Emscripten 会使用默认的 <code>-O0</code>，这表示不执行任何优化。现在这个场景下，如果不进行任何优化，那么会在试图加载这个模块的时候引发链接错误。通过移除多余的导入，添加非 <code>-O0</code> 的优化标记会修正这个问题， 因此要使用下一级优化标志 <code>-O1</code>。</li><li><code>-s EXPORTED_FUNCTIONS</code> 指定导出函数供JavaScript代码使用。要导出的函数名前需要包含下划线字符。注意上述指定多个导出函数的语法，首先是需要用双引号包裹命令行数组 <code>EXPORTED_FUNCTIONS</code>，同时数组中不同元素之间以逗号分隔，不能有空格。</li></ul><p>新生成了 <code>side_module.wasm</code> ，如下图红框标示：</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20220129202815378.png" alt="image-20220129202815378" style="zoom:50%;"></p><p>编写 HTML 文件 <code>side_module.html</code> ，用于下载并实例化刚刚生成的 WebAssembly 模块 <code>side_module.wasm</code>，并调用指定的导出函数 <code>Increment()</code> 和 <code>Decrement()</code>，输出结果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        HTML page I created for my WebAssembly module.</span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> memory = <span class="keyword">new</span> WebAssembly.Memory(&#123;<span class="attr">initial</span>: <span class="number">256</span>, <span class="attr">maximum</span>: <span class="number">256</span>&#125;);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> importObject = &#123;</span></span><br><span class="line">                env: &#123;</span><br><span class="line"><span class="javascript">                    <span class="string">&#x27;__table_base&#x27;</span>: <span class="number">0</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="string">&#x27;memory&#x27;</span>: memory,</span></span><br><span class="line"><span class="javascript">                    <span class="string">&#x27;__memory_base&#x27;</span>: <span class="number">1024</span>,</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"><span class="javascript">            <span class="comment">// 判断浏览器是否支持WebAssembly</span></span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="keyword">function</span> <span class="title">isWebAssemblySupported</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">if</span> (<span class="keyword">typeof</span> WebAssembly === <span class="string">&quot;object&quot;</span>) &#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">const</span> <span class="built_in">module</span> = <span class="keyword">new</span> WebAssembly.Module(<span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0x00</span>, <span class="number">0x61</span>, <span class="number">0x73</span>, <span class="number">0x6D</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>]));</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">if</span> (<span class="built_in">module</span> <span class="keyword">instanceof</span> WebAssembly.Module) &#123;</span></span><br><span class="line"><span class="javascript">                            <span class="keyword">const</span> moduleInstance = <span class="keyword">new</span> WebAssembly.Instance(<span class="built_in">module</span>);</span></span><br><span class="line"><span class="javascript">                            <span class="keyword">return</span> (moduleInstance <span class="keyword">instanceof</span> WebAssembly.Instance);</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="javascript">                &#125; <span class="keyword">catch</span> (err) &#123;&#125;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (isWebAssemblySupported()) &#123;</span><br><span class="line"><span class="javascript">                <span class="comment">// 判断浏览器是否支持instantiateStreaming函数，优先使用该函数</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">// instantiateStreaming相对instantiate较新，一些浏览器可能不支持</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">// 优先使用instantiateStreaming函数，支持在模块下载的同时编译代码，从而带来性能提升</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span> (<span class="keyword">typeof</span> WebAssembly.instantiateStreaming === <span class="string">&quot;function&quot;</span>) &#123;</span></span><br><span class="line"><span class="javascript">                    WebAssembly.instantiateStreaming(fetch(<span class="string">&quot;side_module.wasm&quot;</span>), importObject).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">const</span> value1 = result.instance.exports.Increment(<span class="number">17</span>);</span></span><br><span class="line"><span class="javascript">                        <span class="built_in">console</span>.log(value1.toString());</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">const</span> value2 = result.instance.exports.Decrement(<span class="number">10</span>);</span></span><br><span class="line"><span class="javascript">                        <span class="built_in">console</span>.log(value2.toString());</span></span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="javascript">                <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">                    fetch(<span class="string">&quot;side_module.wasm&quot;</span>).then(<span class="function"><span class="params">response</span> =&gt;</span> </span></span><br><span class="line">                        response.arrayBuffer()</span><br><span class="line"><span class="javascript">                    ).then(<span class="function"><span class="params">bytes</span> =&gt;</span> </span></span><br><span class="line">                        WebAssembly.instantiate(bytes, importObject)</span><br><span class="line"><span class="javascript">                    ).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">const</span> value1 = result.instance.exports.Increment(<span class="number">17</span>);</span></span><br><span class="line"><span class="javascript">                        <span class="built_in">console</span>.log(value1.toString());</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">const</span> value2 = result.instance.exports.Decrement(<span class="number">10</span>);</span></span><br><span class="line"><span class="javascript">                        <span class="built_in">console</span>.log(value2.toString());</span></span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.err(<span class="string">&quot;WebAssembly is not supported&quot;</span>);</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 Python 在当前路径上本地 Web 服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m http.server 8080</span><br></pre></td></tr></table></figure><p>在浏览器中打开 <a href="http://localhost:8080/side_module.html" class="uri">http://localhost:8080/side_module.html</a>：</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20220129203019638.png" alt="image-20220129203019638" style="zoom:50%;"></p><p>可以看到在浏览器的开发者工具的控制台中输出了正确的结果。</p><h3 id="注意">注意</h3><p>按照《WebAssembly实战》这本书上的代码并不能完成，浏览器会报错：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Uncaught</span> (in promise) Linkerror: Webassembly Instantiation: <span class="meta">Import</span> <span class="number">#1</span> module<span class="symbol">=env</span> <span class="meta">function</span>=<span class="string">&quot;__table_base&quot;</span> error: <span class="meta">global</span> <span class="meta">import</span> must be anumber</span><br></pre></td></tr></table></figure><p>报错的原因可能是Emscripten SDK版本和浏览器版本不兼容。查询资料之后按照此<a href="https://stackoverflow.com/questions/55884021/uncaught-in-promise-linkerror-webassembly-instantiation-import-1-module-en">链接</a>修改成功。</p><h2 id="参考资料">参考资料</h2><ul><li>《WebAssembly实战》</li><li><a href="https://stackoverflow.com/questions/55884021/uncaught-in-promise-linkerror-webassembly-instantiation-import-1-module-en" class="uri">https://stackoverflow.com/questions/55884021/uncaught-in-promise-linkerror-webassembly-instantiation-import-1-module-en</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> WebAssembly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C </tag>
            
            <tag> JavaScript </tag>
            
            <tag> HTML </tag>
            
            <tag> WebAssembly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《MySQL是怎样运行的》笔记：InnoDB数据页 &amp; 记录存储结构</title>
      <link href="posts/4a9603aa/"/>
      <url>posts/4a9603aa/</url>
      
        <content type="html"><![CDATA[<p>本文内容来自<a href="https://juejin.cn/book/6844733769996304392">掘金小册《MySQL是怎样运行的》</a>。纸质书早就买了，但是还是喜欢看电子版的。</p><h1 id="innodb数据页基本概念">InnoDB数据页基本概念</h1><p><code>InnoDB</code>是一个将表中的数据存储到磁盘上的存储引擎，所以即使关机后重启我们的数据还是存在的。而真正处理数据的过程是发生在内存中的，所以需要把磁盘中的数据加载到内存中，如果是处理写入或修改请求的话，还需要把内存中的内容刷新到磁盘上。<code>InnoDB</code>将数据划分为若干个<strong>页</strong>，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为 <strong><em>16</em></strong> KB。也就是在一般情况下，一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。</p><a id="more"></a><blockquote><p>为什么页的大小默认16kb？The default 16KB page size or larger is appropriate for a wide range of workloads, particularly for queries involving table scans and DML operations involving bulk updates</p></blockquote><p><code>InnoDB</code> 有多种不同类型的页。存放表中记录的页面称为数据页（官方称为索引（<code>INDEX</code>）页）。</p><h1 id="innodb行格式">InnoDB行格式</h1><p>我们平时是<strong>以记录为单位</strong>来向表中插入数据的，行格式是表中的每个记录（行）在磁盘上的存储格式。</p><p>InnoDB一共有4种行格式：<code>Compact</code>、<code>Redundant</code>、<code>Dynamic</code>、<code>Compressed</code>。其中 <code>Dynamic</code> 是InnoDB默认的行格式。</p><p>可以在创建或修改表的语句中指定行格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 (列的信息) ROW_FORMAT<span class="operator">=</span>行格式名称</span><br><span class="line">    </span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 ROW_FORMAT<span class="operator">=</span>行格式名称</span><br></pre></td></tr></table></figure><p>一条记录（行）包含两个基本部分：记录的额外信息、记录的真实数据。</p><h2 id="记录的额外信息">记录的额外信息</h2><p>存储这一行中每一列的额外信息：数据长度、是否为NULL。以及固定字节数的记录头信息，用于存储该行的其他信息。</p><p>常见的记录头信息：</p><table><colgroup><col style="width: 15%"><col style="width: 15%"><col style="width: 53%"><col style="width: 16%"></colgroup><thead><tr class="header"><th>名称</th><th>大小（单位：bit）</th><th>描述</th><th>备注</th></tr></thead><tbody><tr class="odd"><td><code>预留位1</code></td><td><code>1</code></td><td>没有使用</td><td></td></tr><tr class="even"><td><code>预留位2</code></td><td><code>1</code></td><td>没有使用</td><td></td></tr><tr class="odd"><td><code>delete_mask</code></td><td><code>1</code></td><td>标记该记录是否被删除，1为已被删除</td><td></td></tr><tr class="even"><td><code>min_rec_mask</code></td><td><code>1</code></td><td>B+树的每层非叶子节点中的最小记录都会标记为1</td><td></td></tr><tr class="odd"><td><code>n_owned</code></td><td><code>4</code></td><td>一个页面中的记录被分为若干个组，<code>n_owned</code> 表示当前记录所在分组拥有的记录数，只有该分组的最后一条记录 <code>n_owned</code> 的值才大于0。用于辅助在该页内根据主键查找对应记录。</td><td></td></tr><tr class="even"><td><code>heap_no</code></td><td><code>13</code></td><td>表示当前记录在记录堆的位置信息（当前记录在本页中存放的相对位置），自己插入的记录从2开始，0和1分别表示最小记录和最大记录</td><td></td></tr><tr class="odd"><td><code>record_type</code></td><td><code>3</code></td><td>表示当前记录的类型，<code>0</code>表示普通记录，<code>1</code>表示B+树非叶子节点记录，<code>2</code>表示最小记录，<code>3</code>表示最大记录；自己插入的记录的都是普通记录</td><td>Redundant行格式没有</td></tr><tr class="even"><td><code>n_field</code></td><td><code>10</code></td><td>表示记录中列的数量</td><td>Redundant行格式特有</td></tr><tr class="odd"><td><code>1byte_offs_flag</code></td><td><code>1</code></td><td>标记字段长度偏移列表中每个列对应的偏移量是使用1字节还是2字节表示的，1为1字节，0为2字节</td><td>Redundant行格式特有</td></tr><tr class="even"><td><code>next_record</code></td><td><code>16</code></td><td>表示下一条记录的相对位置，即表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。</td><td></td></tr></tbody></table><ul><li><p><code>next_record</code>：表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。从最小记录到最大记录，未被删除的每一条记录按照主键值从小到大顺序链接成一个<strong>单向链表</strong>，链表第一个节点是最小记录，链表最后一个节点是最大记录。</p><p>由下图可知：</p><ul><li>一条记录中的 <code>next_record</code> 值为：<code>当前行所有自定义列数据长度</code> + <code>下一行记录的额外信息长度</code> + <code>下一行所有隐藏列数据长度</code></li><li>最大记录前的记录的 <code>next_record</code> 值为：-（<code>当前行记录的额外信息长度</code> + <code>当前行之前所有数据行的长度</code> + <code>最大记录suprenum长度</code> ）</li><li>最大记录是最后一条记录， <code>next_record</code> 值为0</li></ul><p><img data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/8/16a95c10773d8cee~tplv-t2oaga2asx-watermark.image" alt="image_1c9qs1mn2t3j1nt344116nk15uf2p.png-119.7kB" style="zoom:67%;"></p><p><img data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/8/16a95c1084c440b4~tplv-t2oaga2asx-watermark.image" alt="image_1cot1r96210ph1jng1td41ouj85c13.png-120.5kB" style="zoom: 67%;"></p></li><li><p><code>delete_mask</code>：标记该记录是否被删除，1为已被删除。这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后把其他的记录在磁盘上重新排列需要性能消耗，所以只是打一个删除标记而已，所有被删除掉的记录都会根据 <code>next_record</code> 属性，按照主键从小到大的顺序链接成一个的<code>垃圾链表</code>，在这个链表中的记录占用的空间称为<code>可重用空间</code>，之后如果有新记录插入到表中的话，可能会重用这些空间，把这些被删除的记录占用的存储空间覆盖掉。避免空间的频繁分配和释放。</p><p>将 <code>delete_mask</code> 位设置为1和将被删除的记录加入到垃圾链表中其实是两个阶段，涉及到事务。</p><p><img data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/8/16a95c108ee1da43~tplv-t2oaga2asx-watermark.image" alt="image_1cul8slbp1om0p31b3u1be11gco9.png-119.6kB" style="zoom:67%;"></p></li><li><p><code>heap_no</code>：表示当前记录在本<code>页</code>中的相对位置，从图中可以看出来，自己插入的记录在本<code>页</code>中的位置从2开始依次往后递增，自己插入的第一条记录 <code>heap_no</code> 是2，第二条记录 <code>heap_no</code> 是3，以此类推。<code>heap_no</code> 为0和1的记录分别表示两条虚拟记录（自动创建的）：最小记录和最大记录。</p><ul><li>在页面前面的记录 <code>heap_no</code> 相对较小</li><li>在页面后面的记录 <code>heap_no</code> 相对较大</li><li>每申请一条记录的存储空间时，该记录比物理位置在它之前的那条记录的 <code>heap_no</code> 值大 1</li></ul></li></ul><h2 id="记录的真实数据">记录的真实数据</h2><p>存储这一行中每一列的真实数据。</p><h3 id="隐藏列">隐藏列</h3><p>除了自己定义的列以外，<code>MySQL</code>会为每个记录默认添加隐藏列，并且存放在自己定义的列前面：</p><table><thead><tr class="header"><th>列名</th><th>存储的真实列名</th><th>是否必须</th><th>占用空间</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><code>row_id</code></td><td><code>DB_ROW_ID</code></td><td>否</td><td><code>6</code>字节</td><td>行ID，唯一标识一条记录</td></tr><tr class="even"><td><code>transaction_id</code></td><td><code>DB_TRX_ID</code></td><td>是</td><td><code>6</code>字节</td><td>事务ID</td></tr><tr class="odd"><td><code>roll_pointer</code></td><td><code>DB_ROLL_PTR</code></td><td>是</td><td><code>7</code>字节</td><td>回滚指针</td></tr></tbody></table><p>其中 <code>row_id</code> 可有可无，在没有自定义主键以及<code>Unique</code>键的情况下才会添加该列。如果用户没有定义主键，则选取一个<code>Unique</code>键作为主键，如果表中连<code>Unique</code>键都没有定义的话，则<code>InnoDB</code>会为表默认添加一个 <code>row_id</code> 列作为主键。</p><figure><img data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/12/169710e973b70372~tplv-t2oaga2asx-watermark.image" alt><figcaption>image_1c9h256f9nke14311adhtu61ie2dn.png-92kB</figcaption></figure><h2 id="compact行格式">Compact行格式</h2><p><img data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/12/169710e8fafc21aa~tplv-t2oaga2asx-watermark.image" alt="image_1c9g4t114n0j1gkro2r1h8h1d1t16.png-42.4kB" style="zoom: 67%;"></p><h3 id="记录的额外信息-1">记录的额外信息</h3><ul><li><p><strong>变长字段长度列表</strong>：这一行中变长字段（列）的长度需要在这里记录，字段的长度按照该行中列的数据存放顺序<strong>逆序</strong>存放，单位是字节。不存放使用定长数据类型且字符集为定长的字段长度，该行中值为 <code>NULL</code> 的变长字段长度也不存放。如果表中所有的列都不是变长列的话，就没有这一部分。</p><ul><li>变长字段（列）：数据类型为<strong>变长数据类型</strong>的列，例如 <code>VARCHAR(M)</code> 、<code>VARBINARY(M)</code>、各种TEXT类型，各种BL0B类型，<code>M</code> 表示该列存储最多<code>M</code>个字符（注意是字符不是字节）；或者采用了变长字符集（例如 <code>gbk</code>、<code>utf8</code>）、数据类型为 <code>CHAR(M)</code> 的列（存储一个空字符串也会占用 <code>字符集对应的最少字节数 * M</code>，这样设计不容易产生碎片但比较占空间）</li><li>该列的长度占用的字节数：假设该列使用的字符集中表示一个字符最多需要使用的字节数为 <code>W</code>，如果该列允许存储的最大字节数（<code>M×W</code>）超过255字节并且真实存储的字节数（<code>L</code>）超过127字节，则使用2个字节，否则使用1个字节。</li></ul></li><li><p><strong>NULL值列表</strong>：统计该行中允许为 <code>NULL</code> 值的列的值是否为 <code>NULL</code>。每一列对应一个二进制位，二进制位按照该行中列的数据存放顺序逆序存放。该列如果为 <code>NULL</code> 则存1，不为 <code>NULL</code> 则存0。如果表中所有列都不允许存放 <code>NULL</code> 值，就没有这一部分。</p><ul><li>占用字节数：必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补<code>0</code>，不够则加一个字节，以此类推。</li></ul></li><li><p><strong>记录头信息</strong>：由固定的5个字节组成。</p></li></ul><blockquote><p>MySQL根据表结构来判断变长字段长度列表的哪个字节、NULL值列表的哪一位、记录的真实数据部分的哪个字节属于哪一列的。</p></blockquote><blockquote><p>变长字段长度列表、NULL值列表中的信息都是逆序存放，这样通过 <code>next_records</code> 向左读取就是记录头信息，向右读取就是真实数据，记录中位置靠前的字段和它们对应的字段长度信息在内存中的距离更近，可能会提高高速缓存的命中率。</p></blockquote><h3 id="记录的真实数据-1">记录的真实数据</h3><p>对于自己定义的列，只存储该行中非 <code>NULL</code> 列的数据。如果该行中该列为 <code>NULL</code>，只会存在NULL值列表中，在记录的真实数据处就不再冗余存储。</p><h2 id="redundant行格式">Redundant行格式</h2><p>早期，在 <code>MySQL5.0</code>之前使用的一种行格式。</p><p><img data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/12/169710e99a69ba3d~tplv-t2oaga2asx-watermark.image" alt="image_1c9h896lcuqi16081qub1v8c12jkft.png-36.2kB" style="zoom: 67%;"></p><h3 id="记录的额外信息-2">记录的额外信息</h3><ul><li><p><strong>字段长度偏移列表</strong>：存放一行中<strong>所有列</strong>的长度信息，按照该行中列的数据存放顺序<strong>逆序</strong>存放每个列的偏移量，即每个列中的值占用的空间在「记录的真实数据」处结束的位置。</p><ul><li>偏移量的含义：例如列1的偏移量为 <code>0x06</code> ，表示列1的数据长度6字节。列2的偏移量 <code>0x0c</code>，表示列2的数据长度为 <code>0x0c - 0x06 = 0x06</code>，即6个字节。</li><li>每个列的偏移量都占1字节或者都占2字节，取决于「记录的真实数据」部分所有数据的长度。<ul><li>当记录的真实数据占用的字节数不大于127（十六进制<code>0x7F</code>）时，每个列对应的偏移量占用1个字节，否则占用2字节。</li><li>「记录头信息」<code>1byte_offs_flag</code> 属性标识了偏移量占1字节还是2字节（1为1字节，0为2字节）</li></ul></li><li>该部分中每个字节的最高位代表该列的值是否为 <code>NULL</code>，如果该位为1，那么该列的值为 <code>NULL</code>，否则不为 <code>NULL</code>。如果该列是定长数据类型，需要在记录的真实数据中存储 <code>0x00</code> 字节占位（定长数据类型的最大长度是多少个字节，就用多少个字节）；如果该列是变长数据类型，不占用记录的真实数据中任何空间，对应的长度为0（即偏移量和上一列的偏移量相同）。<ul><li>注意，在<code>Redundant</code>行格式中，数据类型为 <code>CHAR(M)</code> 的列总是在记录的真实数据中占用对应的最大字节数（<code>M×W</code>），这样设计虽然占空间，但不会产生碎片。</li></ul></li></ul></li><li><p><strong>记录头信息</strong>：由固定的6个字节组成。</p><ul><li>与<code>Compact</code>行格式的记录头信息有两处不同：<ul><li><code>Redundant</code>行格式多了<code>n_field</code>和<code>1byte_offs_flag</code>这两个属性。</li><li><code>Redundant</code>行格式没有<code>record_type</code>这个属性。</li></ul></li></ul></li></ul><h3 id="记录的真实数据-2">记录的真实数据</h3><p>和 <code>Compact</code> 行格式类似，不同的是所有自定义的列都会存储，包括该行中 <code>NULL</code> 值且使用定长数据类型的列，都会按照该数据类型最大长度来使用 <code>0x00</code> 占位存储。</p><h2 id="行溢出">行溢出</h2><ul><li>一行中所有的定长数据类型和 <code>VARCHAR(M)</code> 类型的列（不包括隐藏列和记录头信息，但是包括列的长度、NULL值标识占用的空间）最多总共可以存<code>65535</code>个字节（字符数量因不同字符集而异），除了 <code>BLOB</code>或者<code>TEXT</code>类型的列没有上限。</li><li>MySQL中的一个页一般占16kb（16384字节），并规定一个数据页<strong>至少要存放两条记录</strong>，也就是说一行最多存到一页一半的大小就会发生溢出</li><li>如果行中的列（无论是什么数据类型）存放的数据太多，并且没有超过这个上限，可能会发生行溢出</li></ul><p><code>Compact</code> 和 <code>Redundant</code> 行格式如果某一列发生了行溢出，该列在真实数据处只存储前<code>768</code>个字节，其他字节存储到溢出页中，并在这<code>768</code>个字节后记录20字节的对应溢出页的<strong>地址</strong>和溢出页的数据的占用的<strong>长度</strong>（字节）。并且在前面只会记录在本页中的数据长度，溢出页的数据长度不会算进去。</p><blockquote><p>注意，并不是只要一列的数据超过 <code>768</code> 字节就溢出了并且把其余的那些字节放入溢出页中，一列的数据超过 <code>768</code> 字节也不一定溢出。除非是太多了，导致这一页没法存下这一行（甚至接近了一页一半的大小），才会溢出。</p></blockquote><blockquote><p>溢出页的数据类型为 <code>FIL_PAGE_TYPE_BLOB</code>，和数据页（索引页、<code>FIL_PAGE_INDEX</code>）类型不一样。</p></blockquote><figure><img data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/12/169710e9aab47ea5~tplv-t2oaga2asx-watermark.image" alt><figcaption>image_1d48e3imu1vcp5rsh8cg0b1o169.png-149kB</figcaption></figure><h2 id="dynamic和compressed行格式">Dynamic和Compressed行格式</h2><p>类似于<code>Compact</code>行格式，除了对行溢出数据处理有点不同：</p><ul><li><p><code>Compact</code> 和 <code>Redundant</code> 行格式如果某一列发生了行溢出，该列在真实数据处只存储前<code>768</code>个字节，其他字节存储到溢出页中，并在这<code>768</code>个字节后记录20字节的对应溢出页的<strong>地址</strong>和溢出页的数据的占用的<strong>长度</strong>（字节）。</p><p><img data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/12/169710e9a5d5637a~tplv-t2oaga2asx-watermark.image" alt="image_1conbskr7apj19ns1d194vs1buo1t.png-35.8kB" style="zoom:80%;"></p></li><li><p><code>Dynamic</code>和<code>Compressed</code>行格式中如果某一列发生了行溢出，是把该列所有的字节都存储到溢出页中，只在记录的真实数据处存储这20个字节。</p><p><img data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/12/169710e9b2c2b71e~tplv-t2oaga2asx-watermark.image" alt="image_1conbtnmr1sg1hao1nf41pi1eb72a.png-29.9kB" style="zoom:80%;"></p><ul><li>相对于 <code>Compact</code> 的优势是如果发生了行溢出，能至少腾出700多的字节，这样一行数据可以存储更多列或更多其他列的数据。</li></ul></li></ul><p><code>Compressed</code>行格式和<code>Dynamic</code>不同的一点是，<code>Compressed</code>行格式会采用压缩算法对页面（包括数据页、溢出页）进行压缩，以节省空间。</p><h1 id="innodb数据页结构">InnoDB数据页结构</h1><p>一个<code>InnoDB</code>数据页的存储空间总共分为7个部分。</p><p><img data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/17/16f13ee1e2dfac7c~tplv-t2oaga2asx-watermark.image" alt="img" style="zoom: 50%;"></p><table><thead><tr class="header"><th>名称</th><th>中文名</th><th>占用空间大小</th><th>简单描述</th></tr></thead><tbody><tr class="odd"><td><code>File Header</code></td><td>文件头部</td><td><code>38</code>字节</td><td>页的一些通用信息</td></tr><tr class="even"><td><code>Page Header</code></td><td>页面头部</td><td><code>56</code>字节</td><td>数据页专有的一些信息</td></tr><tr class="odd"><td><code>Infimum + Supremum</code></td><td>最小记录和最大记录</td><td><code>26</code>字节</td><td>两个虚拟的行记录</td></tr><tr class="even"><td><code>User Records</code></td><td>用户记录</td><td>不确定</td><td>实际存储的行记录内容</td></tr><tr class="odd"><td><code>Free Space</code></td><td>空闲空间</td><td>不确定</td><td>页中尚未使用的空间</td></tr><tr class="even"><td><code>Page Directory</code></td><td>页面目录</td><td>不确定</td><td>页中的某些记录的相对位置</td></tr><tr class="odd"><td><code>File Trailer</code></td><td>文件尾部</td><td><code>8</code>字节</td><td>校验页是否完整</td></tr></tbody></table><h2 id="user-recordsfree-space">User Records、Free Space</h2><p>自己插入的记录会按照指定的<code>行格式</code>存储到<code>User Records</code>部分。每插入一条记录，都会从<code>Free Space</code>部分申请一个记录大小的空间划分到<code>User Records</code>部分，当<code>Free Space</code>部分的空间全部被<code>User Records</code>部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了。</p><p>各条记录在<code>User Records</code>中存储的时候并没有空隙。</p><h2 id="infinum-suprenum">Infinum + Suprenum</h2><p>存放最小记录和最大记录，对应的 <code>heap_no</code> 分别是0和1。</p><p>这两条记录InnoDB自动生成的，每个都只由5字节大小的<code>记录头信息</code>和8字节大小的一个固定的部分组成。</p><p><img data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/8/16a95c100ff0ccc2~tplv-t2oaga2asx-watermark.image" alt="image_1c9ra45eam7t1mil9o1h3ucqdhv.png-50.4kB" style="zoom:67%;"></p><h2 id="page-directory">Page Directory</h2><p>将数据页里面的数据分为几个组，每个组<strong>最后一条记录</strong>的头信息的 <code>n_owned</code> 记录该组有多少条记录，将每个组最后一条记录的<strong>相对页面起始字节的地址偏移量</strong>按从小到大的顺序存储在Page Directory（页目录）这一部分，称这个地址偏移量为槽。</p><figure><img data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/8/16a95c10e3449897~tplv-t2oaga2asx-watermark.image" alt><figcaption>image_1d6g64af2sgj1816ktl1q22dehp.png-189.1kB</figcaption></figure><p>最小记录所在的分组只能有 <strong><em>1</em></strong> 条记录，最大记录所在的分组拥有的记录条数只能在 <strong><em>1~8</em></strong> 条之间，剩下的分组中记录的条数范围只能在是 <strong><em>4~8</em></strong> 条之间。分组按照下边的步骤进行：</p><ul><li>初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。</li><li>之后每插入一条记录，都会从<code>页目录</code>中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的<code>n_owned</code>值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。</li><li>在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在<code>页目录</code>中新增一个<code>槽</code>来记录这个新增分组中最大的那条记录的偏移量。</li></ul><p>在一个数据页中查找指定主键值的记录的过程分为两步（假设槽的编号从0开始，槽的偏移量越大，编号也就越大）：</p><ol type="1"><li>通过二分法确定该记录所在的槽的编号 <code>i</code> ，并找到该槽所在分组中主键值最小的那条记录（需要通过上一个槽 <code>i - 1</code> 的最后一条记录的<code>next_record</code>属性找到下一条记录，即当前槽的第一条记录）。</li><li>通过记录的<code>next_record</code>属性遍历该槽 <code>i</code> 所在的组中的各个记录。</li></ol><h2 id="page-header">Page Header</h2><p>Page Header记录<strong>数据页</strong>中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等。</p><table><colgroup><col style="width: 20%"><col style="width: 13%"><col style="width: 65%"></colgroup><thead><tr class="header"><th>名称</th><th>占用空间大小</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><code>PAGE_N_DIR_SLOTS</code></td><td><code>2</code>字节</td><td>在页目录中的槽数量</td></tr><tr class="even"><td><code>PAGE_HEAP_TOP</code></td><td><code>2</code>字节</td><td>还未使用的空间最小地址，也就是说从该地址之后就是<code>Free Space</code></td></tr><tr class="odd"><td><code>PAGE_N_HEAP</code></td><td><code>2</code>字节</td><td>本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）</td></tr><tr class="even"><td><code>PAGE_FREE</code></td><td><code>2</code>字节</td><td>第一个已经标记为删除的记录地址（各个已删除的记录通过<code>next_record</code>也会组成一个单链表，这个单链表中的记录可以被重新利用）</td></tr><tr class="odd"><td><code>PAGE_GARBAGE</code></td><td><code>2</code>字节</td><td>已删除记录占用的字节数</td></tr><tr class="even"><td><code>PAGE_LAST_INSERT</code></td><td><code>2</code>字节</td><td>最后插入记录的位置</td></tr><tr class="odd"><td><code>PAGE_DIRECTION</code></td><td><code>2</code>字节</td><td>记录插入的方向</td></tr><tr class="even"><td><code>PAGE_N_DIRECTION</code></td><td><code>2</code>字节</td><td>一个方向连续插入的记录数量</td></tr><tr class="odd"><td><code>PAGE_N_RECS</code></td><td><code>2</code>字节</td><td>该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录）</td></tr><tr class="even"><td><code>PAGE_MAX_TRX_ID</code></td><td><code>8</code>字节</td><td>修改当前页的最大事务ID，该值仅在二级索引中定义</td></tr><tr class="odd"><td><code>PAGE_LEVEL</code></td><td><code>2</code>字节</td><td>当前页在B+树中所处的层级</td></tr><tr class="even"><td><code>PAGE_INDEX_ID</code></td><td><code>8</code>字节</td><td>索引ID，表示当前页属于哪个索引</td></tr><tr class="odd"><td><code>PAGE_BTR_SEG_LEAF</code></td><td><code>10</code>字节</td><td>B+树叶子段的头部信息，仅在B+树的Root页定义</td></tr><tr class="even"><td><code>PAGE_BTR_SEG_TOP</code></td><td><code>10</code>字节</td><td>B+树非叶子段的头部信息，仅在B+树的Root页定义</td></tr></tbody></table><ul><li><code>PAGE_DIRECTION</code>：假如新插入的一条记录的主键值比上一条记录的主键值大，我们说这条记录的插入方向是右边，反之则是左边。用来表示最后一条记录插入方向的状态就是<code>PAGE_DIRECTION</code>。</li><li><code>PAGE_N_DIRECTION</code>：假设连续几次插入新记录的方向都是一致的，<code>InnoDB</code>会把沿着同一个方向插入记录的条数记下来，这个条数就用<code>PAGE_N_DIRECTION</code>这个状态表示。当然，如果最后一条记录的插入方向改变了的话，这个状态的值会被清零重新统计。</li></ul><h2 id="file-header">File Header</h2><p>File Header记录页本身的信息，以及该页和其他页的关系信息，例如页的编号、上一页、下一页等。对所有类型的页通用。</p><table><thead><tr class="header"><th>名称</th><th>占用空间大小</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><code>FIL_PAGE_SPACE_OR_CHKSUM</code></td><td><code>4</code>字节</td><td>页的校验和（checksum值）</td></tr><tr class="even"><td><code>FIL_PAGE_OFFSET</code></td><td><code>4</code>字节</td><td>页号，每一个页都有一个唯一的页号，<code>InnoDB</code>通过页号来唯一定位一个页。</td></tr><tr class="odd"><td><code>FIL_PAGE_PREV</code></td><td><code>4</code>字节</td><td>上一个页的页号</td></tr><tr class="even"><td><code>FIL_PAGE_NEXT</code></td><td><code>4</code>字节</td><td>下一个页的页号</td></tr><tr class="odd"><td><code>FIL_PAGE_LSN</code></td><td><code>8</code>字节</td><td>页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number）</td></tr><tr class="even"><td><code>FIL_PAGE_TYPE</code></td><td><code>2</code>字节</td><td>该页的类型</td></tr><tr class="odd"><td><code>FIL_PAGE_FILE_FLUSH_LSN</code></td><td><code>8</code>字节</td><td>仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值</td></tr><tr class="even"><td><code>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</code></td><td><code>4</code>字节</td><td>页属于哪个表空间</td></tr></tbody></table><ul><li><p><code>FIL_PAGE_SPACE_OR_CHKSUM</code>：当前页面的校验和（checksum）。这样在比较两个很长的字节串之前先比较这两个长字节串的校验和，如果校验和都不一样两个长字节串肯定是不同的（校验和相同这两个串页未必相同），省去了直接比较两个比较长的字节串的时间损耗。</p></li><li><p><code>FIL_PAGE_TYPE</code>：当前<code>页</code>的类型</p><table><thead><tr class="header"><th>类型名称</th><th>十六进制</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><code>FIL_PAGE_TYPE_ALLOCATED</code></td><td>0x0000</td><td>最新分配，还没使用</td></tr><tr class="even"><td><code>FIL_PAGE_UNDO_LOG</code></td><td>0x0002</td><td>Undo日志页</td></tr><tr class="odd"><td><code>FIL_PAGE_INODE</code></td><td>0x0003</td><td>段信息节点</td></tr><tr class="even"><td><code>FIL_PAGE_IBUF_FREE_LIST</code></td><td>0x0004</td><td>Insert Buffer空闲列表</td></tr><tr class="odd"><td><code>FIL_PAGE_IBUF_BITMAP</code></td><td>0x0005</td><td>Insert Buffer位图</td></tr><tr class="even"><td><code>FIL_PAGE_TYPE_SYS</code></td><td>0x0006</td><td>系统页</td></tr><tr class="odd"><td><code>FIL_PAGE_TYPE_TRX_SYS</code></td><td>0x0007</td><td>事务系统数据</td></tr><tr class="even"><td><code>FIL_PAGE_TYPE_FSP_HDR</code></td><td>0x0008</td><td>表空间头部信息</td></tr><tr class="odd"><td><code>FIL_PAGE_TYPE_XDES</code></td><td>0x0009</td><td>扩展描述页</td></tr><tr class="even"><td><code>FIL_PAGE_TYPE_BLOB</code></td><td>0x000A</td><td>溢出页</td></tr><tr class="odd"><td><code>FIL_PAGE_INDEX</code></td><td>0x45BF</td><td>索引页，也就是我们所说的<code>数据页</code></td></tr></tbody></table></li><li><p><code>FIL_PAGE_PREV</code> 和 <code>FIL_PAGE_NEXT</code>：分别代表本页的上一个和下一个页的页号，所有的页通过这两个属性连接成一个<strong>双向链表</strong>。<strong>并不是所有类型的页都有这两个属性</strong>，数据页（也就是类型为<code>FIL_PAGE_INDEX</code>的页）是有这两个属性的。</p><figure><img data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/8/16a95c10eb9d61ce~tplv-t2oaga2asx-watermark.image" alt><figcaption>image_1ca00fhg418pl1f1a1iav1uo3aou9.png-90.9kB</figcaption></figure></li></ul><h2 id="file-trailer">File Trailer</h2><p>File Trailer用于检验一个页是否完整。针对各种类型的页都通用。为保证从内存中同步到磁盘的页的完整性，在页的首部和尾部都会存储页中数据的校验和和页面最后修改时对应的<code>LSN</code>值，如果首部和尾部的校验和和<code>LSN</code>值校验不成功的话，就说明同步过程出现了问题。</p><p>需要检验一个页是否完整的场景：<code>InnoDB</code>存储引擎会把数据存储到磁盘上，但是磁盘速度太慢，需要以<code>页</code>为单位把数据加载到内存中处理，如果该页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中。如果在同步了一半的时候中断电了，需要判断是同步完成还是失败。</p><ul><li><p>前4个字节代表页的校验和：和<code>File Header</code>中的校验和相对应。每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为<code>File Header</code>在页面的前边，所以校验和会被首先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的。如果写了一半儿断电了，那么磁盘中的这一页的 <code>File Header</code>中的校验和是已经修改过的页的校验和，而在<code>File Trailer</code>中的校验和是原先的页的校验和，二者不同则意味着同步中间出了错。</p><blockquote><p>面试题：innoDB数据从内存同步回磁盘时如何在断电的情况下保持同步。</p><p>发现磁盘中该页的 <code>File Header</code> 和 <code>File Trailer</code> 中的校验和不同步，需要根据redo log进行恢复。</p></blockquote></li><li><p>后4个字节代表页面被最后修改时对应的日志序列位置（LSN）：也是为了校验页的完整性的。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> InnoDB </tag>
            
            <tag> 数据页 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ explicit关键字</title>
      <link href="posts/a6ee4d0c/"/>
      <url>posts/a6ee4d0c/</url>
      
        <content type="html"><![CDATA[<p>C++的 <code>explicit</code> 关键字用于修饰一个类的构造函数和拷贝构造函数，防止构造函数的隐式转换。</p><p>以下的文字仅在 <code>g++ v7.5.0</code> 和 <code>clang++ v11.0.3</code> 测试过。</p><a id="more"></a><p>之前使用 <code>string</code> 的时候总是会看到这样的用法，而且自己也总是这么使用，但是一直不知道是什么原理（也没有百度过），现在终于知道原来这是隐式转换导致的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;aaa&quot;</span>;</span><br></pre></td></tr></table></figure><p>首先先调用类型和等号右边值类型匹配的构造函数创建一个临时对象，再调用拷贝构造函数，参数传入这个临时对象，从而实现 <code>s</code> 的初始化。</p><p>自己做了一个尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cla1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    cla1(<span class="keyword">int</span> a) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;cla1(int a) &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    cla1(<span class="keyword">const</span> cla1 &amp;temp) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;cla1(const cla &amp;temp) &quot;</span> &lt;&lt; temp.a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = temp.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">cla1 <span class="title">c1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    cla1 c2 = <span class="number">2</span>;</span><br><span class="line">    cla1 c3 = c2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以下命令编译生成可执行文件，并运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ test1.cpp -o test1 &amp;&amp; ./test1</span><br></pre></td></tr></table></figure><p>发现运行结果是这样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cla1(<span class="keyword">int</span> a) <span class="number">1</span></span><br><span class="line">cla1(<span class="keyword">int</span> a) <span class="number">2</span></span><br><span class="line">cla1(<span class="keyword">const</span> cla &amp;temp) <span class="number">2</span></span><br></pre></td></tr></table></figure><p>可以发现，在创建对象 <code>c2</code> 的时候的行为并没有按照预期的先创建临时对象，再调用拷贝构造函数。而是直接调用参数类型和等号右边值类型匹配的构造函数一步到位了。了解了一下，原来是现在的编译器为了提高效率，跳过了调用拷贝构造函数这一步。如果加上 <code>-fno-elide-constructors</code> 选项就是原来这样了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ test1.cpp -o test1 -fno-elide-constructors &amp;&amp; ./test1</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cla1(<span class="keyword">int</span> a) <span class="number">1</span></span><br><span class="line">cla1(<span class="keyword">int</span> a) <span class="number">2</span></span><br><span class="line">cla1(<span class="keyword">const</span> cla &amp;temp) <span class="number">2</span></span><br><span class="line">cla1(<span class="keyword">const</span> cla &amp;temp) <span class="number">2</span></span><br></pre></td></tr></table></figure><p>如果对构造函数加上了 <code>explicit</code> 关键字，下面的代码会编译失败，因为 <code>explicit</code> 关键字抑制了隐式转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cla2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">cla2</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;cla2(int a) &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    cla2(<span class="keyword">const</span> cla2 &amp;temp) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;cla2(const cla &amp;temp) &quot;</span> &lt;&lt; temp.a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = temp.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">cla2 <span class="title">c4</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    cla2 c5 = <span class="number">2</span>; <span class="comment">// error: no viable conversion from &#x27;int&#x27; to &#x27;cla2&#x27;</span></span><br><span class="line">    cla2 c6 = c5;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果对拷贝构造函数加上了 <code>explicit</code> 关键字，下面的代码也会编译失败，因为 <code>explicit</code> 关键字抑制了拷贝构造函数的隐式调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cla3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    cla3(<span class="keyword">int</span> a) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;cla3(int a) &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">cla3</span><span class="params">(<span class="keyword">const</span> cla3 &amp;temp)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;cla3(const cla &amp;temp) &quot;</span> &lt;&lt; temp.a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = temp.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">cla3 <span class="title">c7</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    cla3 c8 = <span class="number">2</span>;</span><br><span class="line">    <span class="function">cla3 <span class="title">c9</span><span class="params">(c8)</span></span>; <span class="comment">// 显式调用不会报错</span></span><br><span class="line">    cla3 c10 = c8; <span class="comment">// error: no matching constructor for initialization of &#x27;cla3&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，如果删除了上面代码的第24句，编译器也是不会报错的。即使加了 <code>-fno-elide-constructors</code> 选项，第22行也会正常调用拷贝构造函数。</p><p>不加 <code>-fno-elide-constructors</code> 选项的结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cla3(<span class="keyword">int</span> a) <span class="number">1</span></span><br><span class="line">cla3(<span class="keyword">int</span> a) <span class="number">2</span></span><br><span class="line">cla3(<span class="keyword">const</span> cla &amp;temp) <span class="number">2</span></span><br></pre></td></tr></table></figure><p>加了 <code>-fno-elide-constructors</code> 选项的结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cla3(<span class="keyword">int</span> a) <span class="number">1</span></span><br><span class="line">cla3(<span class="keyword">int</span> a) <span class="number">2</span></span><br><span class="line">cla3(<span class="keyword">const</span> cla &amp;temp) <span class="number">2</span></span><br><span class="line">cla3(<span class="keyword">const</span> cla &amp;temp) <span class="number">2</span></span><br></pre></td></tr></table></figure><p>将拷贝构造函数变成 <code>private</code> ，以下的代码会编译失败。可以说明基本类型和 <code>class</code> 对象类型的隐式转换确实会引发拷贝构造函数的调用，只是编译器可以选择是否省略这一步。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cla1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    cla1(<span class="keyword">int</span> a) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;cla1(int a) &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    cla1(<span class="keyword">const</span> cla1 &amp;temp) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;cla1(const cla &amp;temp) &quot;</span> &lt;&lt; temp.a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = temp.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">cla1 <span class="title">c1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 以下代码都会报错</span></span><br><span class="line">    <span class="comment">// error: calling a private constructor of class &#x27;cla1&#x27;</span></span><br><span class="line">    cla1 c2 = <span class="number">2</span>;</span><br><span class="line">    <span class="function">cla1 <span class="title">c3</span><span class="params">(c2)</span></span>;</span><br><span class="line">    cla1 c4 = c2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> explicit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux -bash 挖矿病毒查杀记</title>
      <link href="posts/a0e4304d/"/>
      <url>posts/a0e4304d/</url>
      
        <content type="html"><![CDATA[<h2 id="背景">背景</h2><p>今天要在实验室的虚拟机上配环境搭系统，我就从我的一台 Ubuntu 18.04 的虚拟机复制了一台作为要配环境的虚拟机。然而发现了异样，就是我每次打开 firefox 浏览器很快就会闪退，连执行 <code>make</code> 编译源代码的进程都被杀死了。于是我查看进程发现了这样一幕：</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210512202031008.png" alt="1"></p><p>好家伙，16个核全占满了，但是内存占用率却不高。而且CPU都是名为 <code>-bash</code> 的进程占的，还一核一个。</p><p>结合之前看到的<a href="https://mp.weixin.qq.com/s/j4vfelk1Eu-rl2s8B70_CQ">公众号文章</a>怀疑自己的虚拟机被挖矿了，但是又不敢十分确定，毕竟我不相信挖矿病毒还能侵入实验室的内网（抱歉是我读书太少了，生而为人，我很抱歉）。然后百度了一番，发现符合挖矿的特征（CPU占用超高，内存占用较少），确认了虚拟机的确被挖矿了。我杀掉这个进程也没用，马上类似的进程又卷土重来了。</p><a id="more"></a><h2 id="初期的一些失败的尝试">初期的一些失败的尝试</h2><h3 id="查看tcp连接">查看TCP连接</h3><p>从文章中学到的第一个方法，就是先查看有没有异常的TCP连接。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo netstat -napt</span><br></pre></td></tr></table></figure><p>果不其然，有点东西，揪出了可疑的外网IP地址 <code>51.79.73.21</code>，可疑的TCP连接建立了。</p><blockquote><p>实在抱歉，我就是要暴露你的IP地址，谁叫你用别人的算力去挖矿，真的不讲武德。</p></blockquote><figure><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210512202846141.png" alt><figcaption>2</figcaption></figure><p>再看看这条命令，就可以看到对应的域名为 <code>vps-e476f784.vps.ovh.ca</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo lsof -p &lt;进程号&gt;</span><br></pre></td></tr></table></figure><figure><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210512203305817.png" alt><figcaption>3</figcaption></figure><h3 id="查看进程对应可执行程序的符号链接">查看进程对应可执行程序的符号链接</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ls -l /proc/&lt;pid&gt;/exe</span><br></pre></td></tr></table></figure><p>好家伙，可执行程序文件都被删除了</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210512204222502.png" alt="4" style="zoom:50%;"></p><h3 id="查看定时任务">查看定时任务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo crontab -l</span><br></pre></td></tr></table></figure><p>还真有一个</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210512204520886.png" alt="5" style="zoom:50%;"></p><p><code>/home/user/.bash/bash</code> 的内容是这样的</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210512204716533.png" alt="6" style="zoom:50%;"></p><p>看不出来在干什么，先把这个文件夹删掉再说吧</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf /home/user/.bash</span><br></pre></td></tr></table></figure><p>删掉这个定时任务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo crontab -e</span><br></pre></td></tr></table></figure><p>再杀掉这个进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">kill</span> -9 &lt;pid&gt;</span><br></pre></td></tr></table></figure><p>好像一段时间之后CPU再也不100%占用了，是成功了吗？</p><p>然而我重启了虚拟机又开始这样了，计划失败了</p><h3 id="封锁网络流量">封锁网络流量</h3><p>既然前面的方法不起作用，那我封锁你的流量总可以吧</p><p>首先编辑 hosts 文件 <code>/etc/hosts</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/hosts</span><br></pre></td></tr></table></figure><p>加入以下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 vps-e476f784.vps.ovh.ca</span><br></pre></td></tr></table></figure><p>然后通过防火墙封锁对应IP的所有流量，为了保险起见，我用 <code>iptables</code> 和 <code>ufw</code> 都设置了一遍</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -A INPUT -s 51.79.73.21 -j DROP</span><br><span class="line">sudo iptables -A OUTPUT -s 51.79.73.21 -j DROP</span><br><span class="line">sudo ufw deny from 51.79.73.21 to any</span><br><span class="line">sudo ufw <span class="built_in">enable</span></span><br></pre></td></tr></table></figure><p>重启之后还是失败了</p><h2 id="向成功迈出了一步">向成功迈出了一步</h2><p>前面所说的使用 <code>crontab -l</code> 命令是看不到某些定时任务的，需要查看 <code>/etc/crontab</code> 的内容才可以</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="regexp">/etc/</span>crontab</span><br></pre></td></tr></table></figure><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210513013148105.png" alt="7" style="zoom:50%;"></p><p>进入目录 <code>/etc/cron.hourly</code> 发现了一个可疑文件 <code>pwnrig</code>，查看它的内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/cron.hourly/pwnrig</span><br></pre></td></tr></table></figure><p>这下才看出来，<code>-bash</code> 进程的由来是 <code>/bin/crondr</code> ，该脚本将其重命名为 <code>/bin/-bash</code> ，再执行 <code>/bin/-bash</code> ，然后将 <code>/bin/-bash</code> 删除。 <code>2&gt;/dev/null</code> 的作用是为了删除这些命令的错误报告（标准错误流 <code>stderr</code> 的输出），就是为了不留痕迹地执行，太流氓了！！！</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210512214440281.png" alt="8" style="zoom:50%;"></p><p>注意，在路径 <code>/etc/cron.d</code>、 <code>/etc/cron.daily</code>、<code>/etc/cron.weekly</code>、<code>/etc/cron.monthly</code> 都有一个相同内容的 <code>pwnrig</code> 文件，在前面的图中已经标出来了</p><p>删除这些可疑文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf /etc/cron.d/pwnrig</span><br><span class="line">sudo rm -rf /etc/cron.hourly/pwnrig</span><br><span class="line">sudo rm -rf /etc/cron.daily/pwnrig</span><br><span class="line">sudo rm -rf /etc/cron.weekly/pwnrig</span><br><span class="line">sudo rm -rf /etc/cron.monthly/pwnrig</span><br></pre></td></tr></table></figure><p>但是删不掉？？？</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210512214641106.png" alt="9" style="zoom:50%;"></p><p>那就祭出大杀器 <code>chattr</code> 和 <code>lsattr</code> 来解锁，再使用 <code>rm</code> 删掉，对于这些其他文件也是一样的办法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo lsattr /etc/cron.weekly/pwnrig <span class="comment"># 查看具有的文件属性</span></span><br><span class="line">sudo chattr -R -ia /etc/cron.weekly/pwnrig <span class="comment"># 去掉属性a（文件只能在最后添加新内容）和属性i（文件不能被删除）</span></span><br></pre></td></tr></table></figure><p>再删除真正的元凶 <code>/bin/crondr</code> 、<code>/bin/-bash</code> （不知道又是从哪冒出来的，注意不是 <code>/bin/bash</code>）文件，使用同样的办法。</p><p>再通过以下命令杀掉挖矿进程，挖矿进程终于看不到了。然而将虚拟机重启之后，挖矿进程还是卷土重来了，又失败了。但是可以推断，挖矿进程卷土重来的原因是可能已经被加入到了系统启动项，总之 <code>pwnrig</code> 没删干净就对了。</p><p>在 <code>/etc</code> 下搜索文件名含有 <code>pwnrig</code> 的所有文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo find /etc -name <span class="string">&quot;*pwnrig*&quot;</span></span><br></pre></td></tr></table></figure><p>还是有很多，而且真的加入到了启动项：</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210513014211767.png" alt="10" style="zoom:50%;"></p><p>其中红框里面的需要按照上述方式先解锁再删除，没加红框的可以直接删除（如果有出入就先解锁再删除）</p><p>然后再删除其他残留文件：<code>/bin/sysdr</code>、<code>/bin/initdr</code>、<code>/bin/bprofr</code>，先解锁再删除。</p><p>最后 kill 掉挖矿进程，大功告成。</p><h2 id="防止复活的手段">防止复活的手段</h2><p>这远远还没结束。由于不同人，不同机器，感染病毒的情况不一样，现在看来是删掉了所有启动项和定时任务，但是也不能确保所有残留文件都删干净了。在网络上一番查找，某个定时任务会从 <code>pw.pwndns.pw</code> 下载一个恶意脚本 <code>update.sh</code> 文件，这个文件会下载前面所说的挖矿程序。因此需要在 <code>/etc/hosts</code> 中加入以下内容来封堵从这台主机下载恶意脚本的路径：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 pw.pwndns.pw</span><br><span class="line">127.0.0.1 pwn.pwndns.pw</span><br><span class="line">127.0.0.1 xmr-v4.pwndns.pw</span><br><span class="line">127.0.0.1 xmr-rx0.pwndns.pw</span><br></pre></td></tr></table></figure><p>然后就是重新给帐户设一个强密码（之前设的是 <code>123456</code>，应该是被破解了）。另外，之前的黑客可能是从 <code>ssh</code> 远程登录进来的，之前也把防火墙关了。为了防止他们再免密登录进来，再作以下操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf /root/.ssh</span><br><span class="line">rm -rf ~/.ssh</span><br><span class="line"><span class="comment"># 不一定要删掉，备份也行</span></span><br></pre></td></tr></table></figure><h2 id="后记">后记</h2><p>上<a href="https://www.shodan.io">Shodan</a>查一下IP地址，是加拿大的，还是自签名，真有你的</p><figure><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210513025538574.png" alt><figcaption>11</figcaption></figure><h2 id="相关链接">相关链接</h2><p>我没有做安全的相关经验，感谢提供经验的大佬们</p><ul><li><a href="https://blog.csdn.net/u013591740/article/details/109157784" class="uri">https://blog.csdn.net/u013591740/article/details/109157784</a></li><li><a href="https://blog.csdn.net/YuMingJing_/article/details/110428620" class="uri">https://blog.csdn.net/YuMingJing_/article/details/110428620</a></li><li><a href="https://blog.csdn.net/jycjyc/article/details/106770998" class="uri">https://blog.csdn.net/jycjyc/article/details/106770998</a></li><li><a href="https://blog.csdn.net/adscici/article/details/107382572" class="uri">https://blog.csdn.net/adscici/article/details/107382572</a></li><li><a href="https://baijiahao.baidu.com/s?id=1672145727359775748&amp;wfr=spider&amp;for=pc" class="uri">https://baijiahao.baidu.com/s?id=1672145727359775748&amp;wfr=spider&amp;for=pc</a></li><li><a href="https://www.antiy.cn/research/notice&amp;report/research_report/20200424.html" class="uri">https://www.antiy.cn/research/notice&amp;report/research_report/20200424.html</a></li><li><a href="http://hackdig.com/10/hack-181622.htm" class="uri">http://hackdig.com/10/hack-181622.htm</a></li><li><a href="https://www.yuque.com/genekong/zkb5i7/gbgx05" class="uri">https://www.yuque.com/genekong/zkb5i7/gbgx05</a></li><li><a href="https://www.cnblogs.com/Gsealy/p/14480365.html" class="uri">https://www.cnblogs.com/Gsealy/p/14480365.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> pwnrig </tag>
            
            <tag> 挖矿病毒 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何让Ubuntu启动显示Grub</title>
      <link href="posts/5dc33326/"/>
      <url>posts/5dc33326/</url>
      
        <content type="html"><![CDATA[<h2 id="背景">背景</h2><p>我的Ubuntu系统版本是 18.04，系统内核版本是 <code>5.4.0-72-generic</code></p><a id="more"></a><p>按照以下步骤降低内核版本，却没有降低成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt search <span class="string">&#x27;linux-image-5.0.0-23-generic&#x27;</span> </span><br><span class="line">sudo apt install <span class="string">&#x27;linux-image-5.0.0-23-generic&#x27;</span> -y </span><br><span class="line">sudo apt install <span class="string">&#x27;linux-headers-5.0.0-23-generic&#x27;</span> -y</span><br><span class="line">sudo update-initramfs -u -k all </span><br><span class="line">sudo update-grub</span><br></pre></td></tr></table></figure><p>原来是因为Grub默认以最高内核版本启动。我就想能在启动的时候显示Grub，就可以自己选择内核版本了，也可以切换到原来的内核版本。</p><h2 id="解决方法">解决方法</h2><p>编辑文件 <code>/etc/default/grub</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/default/grub</span><br></pre></td></tr></table></figure><p>注释掉 <code>GRUB_HIDDEN_TIMEOUT=0</code> 这一行（如果有），再将<code>GRUB_TIMEOUT</code>的值更改为-1。</p><p>然后输入如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-grub</span><br></pre></td></tr></table></figure><p>然后重启就可以看到Grub界面了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><h2 id="参考">参考</h2><ul><li><a href="https://ubuntuqa.com/article/1780.html" class="uri">https://ubuntuqa.com/article/1780.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> Grub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】347. 前K个高频元素</title>
      <link href="posts/f352394b/"/>
      <url>posts/f352394b/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/" class="uri">https://leetcode-cn.com/problems/top-k-frequent-elements/</a></p><p>经过这道题学会了 <code>std::priority_queue</code> 怎么使用小根堆，也复习了一遍快排</p><a id="more"></a><h2 id="题目描述">题目描述</h2><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p><blockquote><p>注意：可以按 <strong>任意顺序</strong> 返回答案</p></blockquote><p><strong>示例 1:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = <span class="comment">[1,1,1,2,2,3]</span>, k = 2</span><br><span class="line">输出: <span class="comment">[1,2]</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = <span class="comment">[1]</span>, k = 1</span><br><span class="line">输出: <span class="comment">[1]</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>k</code> 的取值范围是 <code>[1, 数组中不相同的元素的个数]</code></li><li>题目数据保证答案唯一，换句话说，数组中前 <code>k</code> 个高频元素的集合是唯一的</li></ul><p><strong>进阶：</strong>你所设计算法的时间复杂度 <strong>必须</strong> 优于 <code>O(n log n)</code> ，其中 <code>n</code> 是数组大小。</p><h2 id="暴力排序">暴力排序</h2><p>思路很直观，分为3步：</p><ul><li>统计元素出现频率，可以使用哈希表</li><li>按照频率排序</li><li>找出前K个高频元素</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="comment">// 统计元素出现频率</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            m[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 转化成数组并排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.begin(); it != m.end(); it++) &#123;</span><br><span class="line">            v.push_back(&#123;it-&gt;second, it-&gt;first&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(v.begin(), v.end());</span><br><span class="line">        <span class="comment">// 找出前K个高频元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            result.push_back(v[v.size() - <span class="number">1</span> - i].second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(n\log n)\)</span></p><p>空间复杂度：<span class="math inline">\(O(n)\)</span></p><h2 id="优先队列">优先队列</h2><p>如果用优先队列来解决这道题，首先想到的就是大根堆吧：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            m[nums[i]]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.begin(); it != m.end(); it++)</span><br><span class="line">            q.emplace(it-&gt;second, it-&gt;first);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            result.push_back(q.top().second);</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(n\log n)\)</span></p><p>空间复杂度：<span class="math inline">\(O(n)\)</span></p><p>时间复杂度仍然达不到进阶要求，跟暴力排序法也没什么本质区别。</p><p>使用小根堆解决，在遍历哈希表的时候边遍历边将哈希表的条目插入到优先队列，如果优先队列的大小超过了 <code>k</code> ，那就将优先队列队头（对应的小根堆堆顶）弹出。这样，遍历完了之后，小根堆里面就只剩出现频率前 <code>k</code> 的元素了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;a, <span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a.first &gt; b.first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">result</span><span class="params">(k)</span></span>;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;, cmp&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            m[nums[i]]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.begin(); it != m.end(); it++) &#123;</span><br><span class="line">            q.emplace(it-&gt;second, it-&gt;first);</span><br><span class="line">            <span class="keyword">if</span> (q.size() &gt; k)</span><br><span class="line">                q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            result[i] = q.top().second;</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(n\log k)\)</span> （优先队列中的元素不会超过 <code>k</code> 个）</p><p>空间复杂度：<span class="math inline">\(O(n)\)</span></p><blockquote><p>假设优先队列长度为 <code>k</code>，进行一次堆操作（插入、删除）的时间复杂度为 <span class="math inline">\(O(\log k)\)</span></p></blockquote><h2 id="快速排序">快速排序</h2><p>没有一篇题解能把这个讲清楚，看了一下午，哎，可能是我太菜了吧</p><p>借用快速排序中 <code>pivot</code> 的思想，<code>pivot</code> 将数组 <code>arr[i, ..., j]</code>分成两半部分，假设 <code>pivot</code> 在数组中的位置为 <code>q</code>：</p><ul><li>左半部分 <code>arr[i, ..., q - 1]</code></li><li>右半部分 <code>arr[q + 1, ..., end]</code></li></ul><p>为了能够使用快速排序，首先将记录 <code>nums</code> 数组中数字频度的哈希表转换为频度数组 <code>v</code>，并且让左半部分的频度都大于等于频度数组 <code>v</code> 中 <code>pivot</code> 对应的频度，右半部分小于等于 <code>pivot</code> 对应的频度。</p><p>和普通的快排不一样，普通的快排需要在数组的左右两半部分都进行递归调用，这里只需要对其中一部分进行递归调用。假设在数组 <code>v</code> 的子数组的起始位置为 <code>start</code> ，末尾位置为 <code>end</code> ，<code>index</code> 为 <code>pivot</code> 对应的位置，令 <code>N = index - start + 1</code></p><ul><li>如果 <code>k == N</code>，那么 <code>v[start, ..., index]</code> 中的元素正好构成了前 <code>N</code> 个高频元素，即前 <code>k</code> 个高频元素，直接返回即可<ul><li>注意题目描述中的细节，返回的结果可以是任意顺序的</li></ul></li><li>如果 <code>k &lt; N</code>，那么 <code>v[start, ..., index]</code> 中的元素正好构成了前 <code>N</code> 个高频元素（不一定是前 <code>k</code> 个， 因为 <code>pivot</code> 左右两部分并不保证有序），由于 <code>pivot</code> 左右两部分并不保证有序，因此需要对 <code>v[start, ..., index - 1]</code> 进行递归调用，以找到前 <code>k</code> 个高频元素</li><li>如果 <code>k &gt; N</code>，那么 <code>v[start, ..., index]</code> 中的元素正好构成了前 <code>N</code> 个高频元素，前 <code>N</code> 个高频元素肯定是前 <code>k</code> 个元素中的一部分，需要对 <code>v[index + 1, ..., end]</code> 进行递归调用，以找到剩下的 <code>k - N</code> 个结果</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 快速排序的partition算法，这是快排的其中一种实现</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; &amp;v, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 快排中常用的选取 pivot 的方式是将 v[start] 或 v[end] 作为基准</span></span><br><span class="line">        <span class="comment">// 为了降低快排发生最坏情况的可能性，就随机选取 pivot</span></span><br><span class="line">        <span class="comment">// 这是快排常用的一种优化方法</span></span><br><span class="line">        <span class="keyword">int</span> picked = rand() % (end - start + <span class="number">1</span>) + start;</span><br><span class="line">        <span class="keyword">int</span> pivot = v[picked].first;</span><br><span class="line">        swap(v[start], v[picked]);</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">while</span> (start &lt; end &amp;&amp; v[end].first &lt;= pivot)</span><br><span class="line">                end--;</span><br><span class="line">            swap(v[start], v[end]);</span><br><span class="line">            <span class="keyword">while</span> (start &lt; end &amp;&amp; v[start].first &gt;= pivot)</span><br><span class="line">                start++;</span><br><span class="line">            swap(v[start], v[end]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; &amp;v, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;result, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = partition(v, start, end);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k &lt; index - start + <span class="number">1</span>) &#123;</span><br><span class="line">            qsort(v, start, index - <span class="number">1</span>, result, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>  &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= index; i++)</span><br><span class="line">                result.push_back(v[i].second);</span><br><span class="line">            <span class="comment">// 如果k &gt; index - start + 1，前index - start + 1个元素肯定是结果的一部分</span></span><br><span class="line">            <span class="keyword">if</span> (k &gt; index - start + <span class="number">1</span>)</span><br><span class="line">                qsort(v, index + <span class="number">1</span>, end, result, k - (index - start + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            m[nums[i]]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.begin(); it != m.end(); it++) &#123;</span><br><span class="line">            v.push_back(&#123;it-&gt;second, it-&gt;first&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        qsort(v, <span class="number">0</span>, v.size() - <span class="number">1</span>, result, k);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：平均情况 <span class="math inline">\(O(n)\)</span>，最坏情况 <span class="math inline">\(O(n^{2})\)</span></p><p>空间复杂度：<span class="math inline">\(O(n)\)</span></p><h2 id="计数排序桶排序">计数排序（桶排序）</h2><p>由于 <code>nums</code> 数组中，一个数字出现的频率至多为 <code>nums</code> 的长度（此时 <code>nums</code> 数组中只有一种元素），那么可以使用计数排序来优化时间复杂度也不会占用大量的空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="comment">// 频度表，下标为nums数组中元素出现频度，元素为频度对应的数</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v(size + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            m[nums[i]]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.begin(); it != m.end(); it++) &#123;</span><br><span class="line">            v[it-&gt;second].push_back(it-&gt;first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下标越大，频度越高，因此要从后往前遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = v.size() - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[i].size()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v[i].size(); j++) &#123;</span><br><span class="line">                    result.push_back(v[i][j]);</span><br><span class="line">                    <span class="keyword">if</span> (result.size() == k)</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(n)\)</span></p><p>空间复杂度：<span class="math inline">\(O(n)\)</span></p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 优先队列 </tag>
            
            <tag> 快速排序 </tag>
            
            <tag> 计数排序 </tag>
            
            <tag> 桶排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】239. 滑动窗口最大值</title>
      <link href="posts/c2b11f10/"/>
      <url>posts/c2b11f10/</url>
      
        <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/sliding-window-maximum/" class="uri">https://leetcode-cn.com/problems/sliding-window-maximum/</a></p><p>好难啊</p><a id="more"></a><h2 id="题目描述">题目描述</h2><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3,<span class="string">-1</span>,<span class="string">-3</span>,5,3,6,7], k = 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  <span class="string">-1</span>] <span class="string">-3</span>  5  3  6  7       3</span><br><span class="line"> 1 [3  <span class="string">-1</span>  <span class="string">-3</span>] 5  3  6  7       3</span><br><span class="line"> 1  3 [<span class="string">-1</span>  <span class="string">-3</span>  5] 3  6  7       5</span><br><span class="line"> 1  3  <span class="string">-1</span> [<span class="string">-3</span>  5  3] 6  7       5</span><br><span class="line"> 1  3  <span class="string">-1</span>  <span class="string">-3</span> [5  3  6] 7       6</span><br><span class="line"> 1  3  <span class="string">-1</span>  <span class="string">-3</span>  5 [3  6  7]      7</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="comment">[1]</span>, k = 1</span><br><span class="line">输出：<span class="comment">[1]</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="comment">[1,-1]</span>, k = 1</span><br><span class="line">输出：<span class="comment">[1,-1]</span></span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="comment">[9,11]</span>, k = 2</span><br><span class="line">输出：<span class="comment">[11]</span></span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="comment">[4,-2]</span>, k = 2</span><br><span class="line">输出：<span class="comment">[4]</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li><li><code>1 &lt;= k &lt;= nums.length</code></li></ul><h2 id="优先队列">优先队列</h2><p>这道题需要一个数据结构，来存储滑动窗口中最大值、第二大的值、第三大的值、……的下标。（最初我只想到了用变量去存滑动窗口中最大值和第二大的值的下标，结果当窗口移动之后变量总是不能正确被更新，然后就做不对了；居然还想到了用栈，我真的太菜了）</p><p>首先最直观的想法应该是使用优先队列（大根堆），这样，优先队列的队头（即大根堆的堆顶）就是滑动窗口内最大的值在 <code>nums</code> 数组的下标。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q; <span class="comment">// std::priority_queue默认是大根堆</span></span><br><span class="line">        <span class="comment">// 窗口在初始位置时，将此时窗口中的数组元素加入到优先队列中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">            q.emplace(nums[i], i);</span><br><span class="line">        result.push_back(q.top().first);</span><br><span class="line">        <span class="comment">// 向右移动滑动窗口</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; size; i++) &#123;</span><br><span class="line">            q.emplace(nums[i], i);</span><br><span class="line">            <span class="comment">// 需要将所有已经移出窗口的数组元素从优先队列中删除</span></span><br><span class="line">            <span class="keyword">while</span> (q.top().second &lt;= i - k)</span><br><span class="line">                q.pop();</span><br><span class="line">            result.push_back(q.top().first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(n\log n)\)</span>（一个元素进入优先队列）</p><p>空间复杂度：<span class="math inline">\(O(n)\)</span>（优先队列所占用的空间）</p><h2 id="单调队列">单调队列</h2><p>单调队列就是队列中的所有元素都是单调递增或递减的队列。</p><p>这里的想法是用队列来存储滑动窗口中最大值的下标，以及在最大值右边的第二大的值、第三大的值、……的下标。这样，一旦窗口向右移动，并且窗口内的最大值移出了窗口，就能知道下一个该成为窗口中最大值的元素是哪个。</p><p>窗口每向右移动一格，需要做的事情：</p><ul><li>将新进入窗口的元素的下标插入到队尾，为了保持队列中存储的下标对应的元素是递减的，需要先将队列中所有比该元素小的值从队尾删除。</li><li>将队列中已经被移出窗口的下标从队头删除，队列中剩下的值可能会成为窗口内最大值的候选值。</li></ul><p>为了能够实现从队头和队尾都能删除元素，需要使用双端队列（deque）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!q.empty() &amp;&amp; nums[i] &gt;= nums[q.back()])</span><br><span class="line">                q.pop_back();</span><br><span class="line">            q.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        result.push_back(nums[q.front()]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!q.empty() &amp;&amp; nums[i] &gt;= nums[q.back()])</span><br><span class="line">                q.pop_back();</span><br><span class="line">            q.push_back(i);</span><br><span class="line">            <span class="comment">// 将已经移出窗口的下标删除</span></span><br><span class="line">            <span class="keyword">while</span> (q.front() &lt;= i - k)</span><br><span class="line">                q.pop_front();</span><br><span class="line">            result.push_back(nums[q.front()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(n)\)</span>（最坏情况是每个元素都要进入到队列和从队列中删除各一次，例如数组中的元素大小是递增的）</p><p>空间复杂度：<span class="math inline">\(O(n)\)</span>（单调队列所占用的空间）</p><h2 id="动态规划">动态规划</h2><p>从官方题解来的，卡了好半天了，哎，还是从下面两篇题解看出了一些眉目</p><p><a href="https://leetcode.com/problems/sliding-window-maximum/discuss/458121/Java-All-Solutions-(B-F-PQ-Deque-DP)-with-Explanation-and-Complexity-Analysis" class="uri">https://leetcode.com/problems/sliding-window-maximum/discuss/458121/Java-All-Solutions-(B-F-PQ-Deque-DP)-with-Explanation-and-Complexity-Analysis</a></p><p><a href="https://leetcode.com/problems/sliding-window-maximum/discuss/951894/C%2B%2B-Easy-DP-or-O(n)-or-Explained-or-No-Deque-Required-%3AD" class="uri">https://leetcode.com/problems/sliding-window-maximum/discuss/951894/C%2B%2B-Easy-DP-or-O(n)-or-Explained-or-No-Deque-Required-%3AD</a></p><p>先将整个 <code>nums</code> 数组（长度为 <code>n</code> ）分成几个互不相交且长度为 <code>k</code> 的块（最后一个块的长度可能小于 <code>k</code>），如下所示：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span> <span class="number">3</span>  -<span class="number">1</span> ｜ -<span class="number">3</span>  <span class="number">5</span>  <span class="number">3</span> ｜ <span class="number">6</span>  <span class="number">7</span></span><br></pre></td></tr></table></figure><p>那么，从下标 <code>i</code> 开始，长度为 <code>k</code> 的滑动窗口可能刚好在一个块，也有可能跨越两个块。</p><p>如果 <code>i</code> 刚好是 <code>k</code> 的倍数，那么窗口刚好只占一个块，例如：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span> <span class="number">3</span>  -<span class="number">1</span> ｜ [-<span class="number">3</span>  <span class="number">5</span>  <span class="number">3</span>] ｜ <span class="number">6</span>  <span class="number">7</span></span><br></pre></td></tr></table></figure><p>否则，窗口就会跨越两个块，例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">        <span class="selector-tag">i</span>     j  <span class="selector-tag">i</span>+k-<span class="number">1</span></span><br><span class="line">        ↓     ↓  ↓</span><br><span class="line"><span class="number">1</span>  <span class="number">3</span>  <span class="selector-attr">[-1 ｜ -3  5]</span>  <span class="number">3</span> ｜ <span class="number">6</span>  <span class="number">7</span></span><br></pre></td></tr></table></figure><p>可以看出，这种情况下，一个块被窗口的边界分成了左半部分和右半部分，分别使用两个长度为 <code>n</code> 的数组 <code>left</code> 和 <code>right</code>：</p><ul><li><code>left[i + k - 1]</code> 表示从 <code>nums[j]</code> 到 <code>nums[i + k - 1]</code> 中（窗口中的右半部分）的最大值，同时是第二个块的左半部分的最大值（以窗口右边界分隔）</li><li><code>right[i]</code> 表示从 <code>nums[i]</code> 到 <code>nums[j - 1]</code> 中（窗口中的左半部分）的最大值，同时是第一个块的右半部分的最大值（以窗口左边界分隔）</li></ul><p>因此，当窗口的起始位置为 <code>i</code> 时，窗口中的最大值可以描述为窗口中左半部分和右半部分的最大值： <span class="math display">\[\max(right[i],left[i + k - 1])\]</span> 其中，<code>left</code> 数组中的元素的递推式为（需要从左向右遍历 <code>nums</code> 数组得到）： <span class="math display">\[left[i]=\begin{cases}nums[i]&amp;i\  \text{mod} \  k=0\\ \max \left( left[i-1],nums[i]\right)  &amp;\text{else} \end{cases}\]</span> <code>right</code> 数组中的元素的递推式为（需要从右向左遍历 <code>nums</code> 数组得到）： <span class="math display">\[right[i]=\begin{cases}nums[i]&amp;i=n-1\  \text{or} \  (i+1)\  \text{mod} \  k=0\\ \max \left( right[i+1],nums[i]\right)  &amp;\text{else} \end{cases}\]</span> 注意，当窗口起始位置 <code>i</code> 刚好是 <code>k</code> 的倍数时，有： <span class="math display">\[right[i]=left[i+k-1]\]</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        vector&lt;int&gt; left(size), right(size), result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % k == <span class="number">0</span>)</span><br><span class="line">                left[i] = nums[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left[i] = max(left[i - <span class="number">1</span>], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        right[size - <span class="number">1</span>] = nums[size - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i + <span class="number">1</span>) % k == <span class="number">0</span>)</span><br><span class="line">                right[i] = nums[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right[i] = max(right[i + <span class="number">1</span>], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size - k; i++) &#123;</span><br><span class="line">            result.push_back(max(right[i], left[i + k - <span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(n)\)</span></p><p>空间复杂度：<span class="math inline">\(O(n)\)</span></p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 优先队列 </tag>
            
            <tag> 队列 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据库】关系数据理论</title>
      <link href="posts/ba7ec3b2/"/>
      <url>posts/ba7ec3b2/</url>
      
        <content type="html"><![CDATA[<p>大二学数据库时候的笔记，这段时间要准备面试，所以现在把它抖出来。但是我应该看不太懂了。</p><p>我要是在学操作系统和计算机网络的时候也有笔记就好了，这样就不愁面试了。</p><p>哦，原来数据库考索引多一些，大学白学了。</p><a id="more"></a><h2 id="不好的设计所带来的异常">不好的设计所带来的异常</h2><h3 id="冗余">冗余</h3><p>同样的信息在多个元组中重复。</p><h3 id="更新异常">更新异常</h3><p>这是由<strong>冗余</strong>导致的。修改了某个元组的信息，但是没有修改其他元组中相同的信息。导致数据的<strong>不一致性</strong>。</p><h3 id="删除异常">删除异常</h3><p>想删除这个元组的部分信息，却因为删除了元组而丢失了其他信息（这些信息只在这一个元组中出现）。违背了<strong>数据完整性</strong>。</p><h3 id="插入异常">插入异常</h3><p>想插入一个元组，但是某个主键属性值缺失（null）而导致不能插入该元组。</p><h2 id="好的设计所具有的特征">好的设计所具有的特征</h2><ul><li>保证所有信息不丢失。</li><li>含有最小数量的冗余。</li><li>保留数据之间的函数依赖。</li><li>比较好的查询性能。</li></ul><h2 id="函数依赖和多值依赖">函数依赖和多值依赖</h2><h3 id="函数依赖的定义">函数依赖的定义</h3><p>如果R的两个元组在属性A1,A2,...,An上一致（即它们对应于这些属性的分量值都相等），那么它们必定在其他属性B1,B2,...,Bm上也一致。<strong>换句话说，一组A1,A2,...,An只对应唯一的B1,B2,...,Bm。</strong></p><p>记为：A1,A2,...,An→B1,B2,...,Bm。</p><p><strong>注意：在数据库开发过程中，函数依赖（FDs）一般是用户给出的领域知识描述。如果从已有数据中找寻FDs，属于知识发现或数据挖掘。</strong></p><h3 id="属性集合的闭包">属性集合的闭包</h3><h4 id="定义">定义</h4><p>属性集合{A1,A2,...,An}的闭包为所有能从已有的函数依赖推导出的属性的集合。记为：{A1,A2,...,An}+。</p><h4 id="算法">算法</h4><p>略。</p><h4 id="用途">用途</h4><ul><li>判断某个函数依赖是否成立（能否从这个函数依赖的集合导出）。</li><li>求关系R的键。</li><li>测试是否为超键。</li></ul><h3 id="函数依赖集合的闭包">函数依赖集合的闭包</h3><h4 id="定义-1">定义</h4><p>给定关系R和在R上成立的函数依赖F，F的闭包为所有能从F中的函数依赖推导出的函数依赖的集合。记为：F+。</p><h4 id="算法-1">算法</h4><ul><li>对R的属性集合{A1,A2,...,An}，先求相应的子集（一共2^n）个。</li><li>对R的属性集合{A1,A2,...,An}每个子集X，求X的的闭包X+。</li><li>求X+的所有子集Y，并输出函数依赖X→Y到F+中。</li></ul><h4 id="用途-1">用途</h4><p>由于R的属性集合{A1,A2,...,An}一共有2<sup>n个，故算法的时间复杂度为O(2</sup>n)，为NP问题。</p><p>一般来说，不用求函数依赖集合F的闭包。因为不仅F+规模大，而且<strong>所有能从F中的函数依赖推导出的函数依赖都在F+中。</strong></p><h3 id="推导函数依赖">推导函数依赖</h3><h4 id="armstrong公理">Armstrong公理</h4><ul><li><p>自反律：A1,A2,...,An→A1,A2,...,An的子集</p></li><li><p>增广律：A1,A2,...,An→B1,B2,...,Bm, then A1,A2,...,An,C1,C2,...,Ck→B1,B2,...,Bm,C1,C2,...,Ck</p></li><li><p>传递律：A1,A2,...,An→B1,B2,...,Bm and B1,B2,...,Bm→C1,C2,...,Ck, then A1,A2,...,An→C1,C2,...,Ck</p></li></ul><h4 id="常用结论">常用结论</h4><p>这些结论都可以由Armstrong公理推导出来。</p><p>X, Y, Z都是属性集合。</p><ul><li><p>Union rule：X→Y and X→Z, then X→YZ</p></li><li><p>Decomposition rule：X→YZ, then X→Y and X→Z</p></li><li><p>Pseudo-transitivity rule：X→Y and YZ→U, then XZ→U</p></li></ul><p>由Armstrong公理的自反律推导出的函数依赖称为“平凡函数依赖”。由增广律可以消除箭头两边重复的属性。由上述Decomposition rule可以拆解箭头右边的属性。一般我们讨论的函数依赖为非平凡函数依赖，且函数依赖的箭头右边只有一个属性。</p><h4 id="判断函数依赖是否成立的方法">判断函数依赖是否成立的方法</h4><ul><li>给定函数依赖集合F和函数依赖X→Y，求X的闭包X+，如果Y在X+中，则X→Y成立。</li><li>chase检验。（和上述方法本质相同）</li></ul><h3 id="最小函数依赖集">最小函数依赖集</h3><h4 id="等价">等价</h4><p>给定函数依赖集合F和G，若G+=F+，则F与G等价。</p><p>F+=G+的充要条件是F是G+的子集，G是F+的子集。</p><h4 id="最小函数依赖集的定义">最小函数依赖集的定义</h4><p>给定函数依赖集合S，则任何与S等价的函数依赖集合都是S的基本集。满足下面三个条件的基本集B为关系的最小函数依赖集。</p><ul><li>B中所有函数依赖的右边均为单一属性。</li><li>从B中删除任何一个函数依赖后，该集合不再是基本集。</li><li>对于B中的任何一个函数依赖，如果从其左边删除一个或多个属性，B将不再是基本集。</li></ul><p>最小函数依赖集中不包括平凡函数依赖，因为可以根据第2条规则将其删除。对于函数集合S，其对应的最小函数依赖集B也不是唯一的。</p><h4 id="求法">求法</h4><p>给定函数依赖集合F。</p><ul><li>选择F中的任意一个函数依赖，去掉这个函数依赖，看F中剩余的函数依赖能否导出那个被去掉的函数依赖。如果能则去掉，反之则在F中保留。然后在F中重新选取另一个函数依赖，重复上述步骤。</li><li><del>选择F中的一个函数依赖Y→B，Y至少有两个属性，从Y中删除一个属性并记为Z。如果B能够从F中（包括Y→B）依赖推断，则使用Z→B替换Y→B。</del></li><li>一个一个地检查函数依赖左部非单个属性的依赖。例如XY→A，若要判Y为多余的，则以X→A代替XY→A是否等价？若A属于(X)+，则Y是多余属性，可以去掉。（以上步骤中，求出关系依赖集F,此时，再F的基础上，求出X或者Y的闭包，是否包含A）</li></ul><p>以各种可能的方式重复上述两个步骤，注意在选取函数依赖的时候不要选择前面选过但是原样保留在F中的函数依赖，直到F不再变化。</p><h4 id="函数依赖集的投影">函数依赖集的投影</h4><p>给定关系R和在R中成立的函数依赖集合S，R1是R的投影，T是在R1上成立的函数依赖集合。先将T初始化为空集。</p><ul><li>对于R1属性集合的每一个子集X，计算X的闭包X+。</li><li>对于所有在X+中且属于R1的属性A，将所有非平凡函数依赖X→A添加到T中。</li><li>求T的最小函数依赖集。</li></ul><h4 id="用途-2">用途</h4><ul><li>保持函数依赖集合无损连接的3NF模式分解</li><li>求由原关系R分解（投影）得出的关系的函数依赖集合，来看分解后的函数依赖是否保持了原关系中的函数依赖。（函数依赖集的投影）</li></ul><h3 id="多值依赖mvd">多值依赖（MVD）</h3><ul><li><p>在关系模式中，函数依赖不能表示属性值之间的一对多联系，这些属性之间有些虽然没有直接关系，但存在间接的关系，把没有直接联系、但有间接的联系称为多值依赖的数据依赖。</p></li><li><p>在函数依赖中，X与Y是否存在函数依赖关系，只需考察X,Y的两组属性，与别的属性无关。而在多值依赖中，X与Y是否存在多值依赖还需看属性Z。</p></li><li><p>多值依赖允许X的一个值决定Y的一组值，这种决定关系与Z取值无关。</p></li><li><p>多值依赖是全模式的依赖关系。</p></li></ul><h4 id="定义-2">定义</h4><p>A <em>multivalued dependency</em> (MVD) <em>X</em>→→<em>Y</em> is an assertion that if two tuples of a relation agree on all the attributes of <em>X</em>, then their components in the set of attributes <em>Y</em> may be swapped, and the result will be two tuples that are also in the relation.</p><p>函数依赖是多值依赖的特例。一般的多值依赖不是函数依赖。</p><p>或：设R(U)是一个属性集合U上的一个关系模式，X, Y, 和Z是U的子集，并且Z=U-X-Y，多值依赖X-&gt;-&gt;Y成立当且仅当对R的任一个关系r，r在(X,Z)上的每个值对应<strong>一组</strong>Y的值，这组值仅仅决定于X值而与Z值无关。</p><p>若X-&gt;-&gt;Y，而Z=空集，则称X-&gt;-&gt;Y为平凡的多值依赖。否则，称X-&gt;-&gt;Y为非平凡的多值依赖。</p><h4 id="规则">规则</h4><ul><li>平凡MVD：若X→→Y,而Z为空集，则称X→→Y为平凡的多值依赖；若Z不为空，则称其为非平凡的多值依赖。</li><li>传递律：X→→Y and Y→→Z, then X→→Z。Z的任何属于X的属性也要从右边除去。</li><li>互补规则：若关系R上存在多值依赖X→→Y，则R上也存在X→→Z，其中Z是R中不属于X和Y<strong>所有</strong>其他属性的集合。</li></ul><p>注意：MVD不支持MVD的分解/结合原则，即FD的右边可拆，但是MVD左右都不能拆。</p><h4 id="mvd推导">MVD推导</h4><p>chase推广</p><h4 id="投影mvd">投影MVD</h4><p>chase推广</p><h2 id="关系的键key">关系的键（key）</h2><h3 id="键的定义">键的定义</h3><p>如果下列条件满足，就认为一个或多个属性集合{A1,A2,...,An}是关系R的键（候选码）。</p><ul><li>这些属性决定了关系的所有其他属性。也就是说，关系R不可能存在两个不同的元组，他们具有相同的A1,A2,...,An值。</li><li>在{A1,A2,...,An}的真子集中，没有一个能决定关系的所有其他属性。（决定所有属性的最小属性集合）</li></ul><p>当键只包括一个单独的属性A时，称A（而不是{A}）是键。</p><h3 id="超键superkey">超键（superkey）</h3><p>一个包含键的属性集称为超键。须注意：键是超键（根据定义），但是超键不一定是键。</p><h3 id="键的求法">键的求法</h3><h4 id="从er图中寻找键">从E/R图中寻找键</h4><p>略。</p><h4 id="由关系和函数依赖集求键">由关系和函数依赖集求键</h4><ul><li>对于给定关系R和在R上成立的函数依赖集合F，在R的所有属性组成的集合A={A1,A2,...,An}，从A中去掉在F中只出现在箭头右边的属性得到集合B。</li><li>对于A中剩余的属性所组成的集合B，求B所有的子集（空集除外）的闭包B+。如果B+=A，则B是关系R的一个键。在求解的过程中，如果遇到的子集是超键（对于前面已经求出的键来说），则略过不求。</li></ul><h2 id="范式">范式</h2><ul><li>设计关系数据库时，需要遵从不同的规范要求，设计出合理的关系型数据库，<strong>这些不同的规范要求被称为不同的范式</strong>，各种范式呈递次规范，<strong>越高的范式数据库冗余越小</strong>。<strong>没有冗余的数据库未必是最好的数据库</strong>， <strong>有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据</strong>。</li><li>目前关系数据库有六种范式（按冗余程度从高到低排序）：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、Boyce-Codd范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。</li><li>所有范式都是基于约束（函数依赖、键）定义的。</li><li><strong>范式之间存在包含关系。一个数据库设计如果符合第二范式，一定也符合第一范式。如果符合第三范式，一定也符合第二范式，依次类推。</strong></li><li>一般来说，数据库满足3NF或BCNF就可以了。关系模式如果不能达到3NF及以上，会出现冗余和各种异常。分解是消除异常的方法。</li><li>关系模式的分解是为了适应实际应用，分解后减少了冗余，但查询时却要增加连接，效率下降，这都需要<strong>权衡</strong>。因此，选取设计范式应立足实际应用，适当的冗余是可以容忍和必要的。</li></ul><h3 id="关系模式的分解">关系模式的分解</h3><h4 id="分解关系模式的一般方法">分解关系模式的一般方法</h4><p>给定关系模式R和R上成立的函数依赖集合F，欲将其分解为满足更高级别范式的关系模式。</p><ul><li>检查F中存在违背某一更高级别范式条件函数依赖。如果没有，则采用比这个更高级别还要高的范式条件进行检查。</li><li>如果存在违背的函数依赖，就将其拆分为小的关系模式。</li><li>检查这些小的关系模式的函数依赖（用 <a href="#函数依赖集的投影">函数依赖集的投影</a> 的方法求）是否存在违背这个更高级别范式的函数依赖，如果存在，则还要继续分解、继续检查，直到满足这个更高级别的范式条件即可。</li><li>如果这些小的关系模式不存在违背的函数依赖，则这些关系模式都满足这个更高级别的范式。之后可以采用比这个更高级别还要高的范式重复上述步骤。</li></ul><h4 id="无损分解无损连接">无损分解、无损连接</h4><ul><li><p>分解：给定关系模式R(A1,A2,...,An)，将R分解成R1(B1,B2,...,Bn)和R2(C1,C2,...,Cn)，R1和R2都是R的投影。还要满足：{B1,B2,...,Bn}∪{C1,C2,...,Cn}={A1,A2,...,An}。</p></li><li><p>无损分解、无损连接：将关系模式分解成R1、R2、……，而R1、R2、……自然连接的生成的表R'和不仅R的关系模式相同，而且R'的行数和R的行数也应该一致（此时元组和原来的也一样，可证明），则这个分解和连接的过程是无损的，即没有信息丢失。具体的表现是：给定关系模式R(X,Y,Z)，在R上成立的函数依赖集合F={Y→X,Y→Z}，分解成R1(X,Y)和R2(Y,Z)，才能做到无损分解。</p></li><li><p>有损：R'中的行数比R中的行数多，而且这些多出来的行使得我们无法分辨哪条信息才是真的。一个具体的表现是：给定关系模式R(X,Y,Z)，Y→X,X→Z均不在R上成立，分解成R1(X,Y)和R2(Y,Z)，R1和R2自然连接的结果虽然关系模式是R'(X,Y,Z)，但是元组会比原来多，其中有的元组是虚假信息。</p></li><li><p>判断无损分解和连接的算法：chase检验。</p><p>而chase检验的本质和属性闭包算法本质相同。<del>可以将从R分解出的所有关系模式列出来，使用R上的函数依赖集合分别对每个关系模式的所有属性组成的集合分别求属性闭包，如果某一个属性闭包正好包含了R中所有的属性，则是无损连接。</del></p></li></ul><h4 id="保持函数依赖">保持函数依赖</h4><p>给定关系模式R和R上成立的函数依赖集合S，将R分解成R1和R2，分别对应函数依赖集合S1、S2。</p><ul><li>如果(S1∪S2)与S等价，即(S1∪S2)+=S+，则这个分解保持了原有函数依赖。</li><li>一个表现：S中的一个函数依赖X→Y，分解之后X只在一个关系模式中，Y只在另一个关系模式中。则没有保持原有函数依赖。</li><li>分解之后丢失了如果部分函数依赖，则自然连接回去的关系模式也会丢失相应的函数依赖。</li><li><strong>分解之后是否保持函数依赖，关键是看连接回去是否具有这个函数依赖。</strong></li></ul><p>判断分解后是否保持函数依赖的算法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对F上的每一个α→β使用下面的过程：</span></span><br><span class="line">result=α;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> each 分解后的Ri  <span class="comment">//将每个分解后的结构Ri逐个带入</span></span><br><span class="line">      t=(result∩Ri)+ ∩Ri;  <span class="comment">//这里的意思是取result与Ri的交集的闭包值，之后再与Ri取交集</span></span><br><span class="line">      result=result∪t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(result发生变化);</span><br></pre></td></tr></table></figure><p>直到一轮<code>while</code>循环之后<code>result</code>不发生变化或者中途验证了结论正确（β在<code>result</code>中，即α→β保持了）才停止。</p><h3 id="nf">1NF</h3><ul><li>最低要求的范式。</li><li>所有属性必须是原子值，不允许多值属性，复合属性及其组合。</li><li>当前关系数据库的表都是这种表，也就是通过<code>create table...</code>创建出的表都属于1NF。</li></ul><h3 id="nf-1">2NF</h3><ul><li>符合1NF，且所有的非主属性都完全依赖于主属性。</li><li>换言之，如果存在违背2NF的函数依赖，即存在一个非平凡函数依赖，非主属性由键的一部分决定，即不属于2NF。</li><li>主属性：键中的属性。</li><li>2NF要求有主键（实体唯一性）。</li></ul><h3 id="nf-2">3NF</h3><ul><li>符合2NF，并要求<strong>任何非主属性不依赖于其他非主属性，</strong>也就是在第二范式的基础上消除传递依赖（A-&gt;B-&gt;C）。</li><li>换言之，如果存在违背3NF的函数依赖，即<strong>当且仅当非平凡函数依赖箭头左边不是超键，箭头右边是非主属性</strong>，即不属于3NF。（这个非主属性可由键的一部分推出）</li><li>3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余（函数依赖级别的冗余）。</li><li>关系模式如果不能达到3NF及以上，会出现冗余和各种异常。</li><li>是对BCNF条件的妥协让步。</li></ul><h4 id="保持函数依赖和无损连接的3nf模式分解">保持函数依赖和无损连接的3NF模式分解</h4><p>对于给定关系R以及在R上成立的函数依赖集合F，</p><ul><li><p>求F的最小函数依赖集合G。</p></li><li><p>对于G的每一个函数依赖X→A，将XA作为分解出的一个关系模式。即有几组就有几张表。</p></li><li><p>如果某个关系模式被另一个关系模式所包含，删除该关系模式。</p></li><li><p>如果上一步分解出的关系模式均不包含R的超键，则增加一个关系，其模式为R的任何一个键。（如果有一个包含则不增加）</p></li></ul><p>此方法分解出的关系模式一定满足3NF。</p><h3 id="bcnf">BCNF</h3><ul><li>符合3NF，并且<strong>主属性内部不能有部分或传递依赖</strong>。这将消除对主属性子集的依赖，使主属性保持最简。（Whenever a set of attributes of <em>R</em> is determining another attribute, it should determine <strong><em>all</em></strong> attributes of <em>R</em>.）<strong>BCNF既检查非主属性，又检查主属性。当只检查非主属性时，就成了第三范式。</strong></li><li>换言之，如果存在违背BCNF的函数依赖，即<strong>当且仅当非平凡函数依赖箭头左边不是超键的时候</strong>，即不属于BCNF。</li><li>推论：所有二元关系都是BCNF。</li><li>BCNF能消除大部分类型的冗余，但是不能消除“多值函数依赖”冗余。即试图把键的两个或多个集合值属性置于同一个关系中。</li></ul><h4 id="将关系分解成bcnf二叉分解">将关系分解成BCNF（二叉分解）</h4><p>给定不属于BCNF的关系R和在R上成立的函数依赖集合F。</p><ul><li>在F中找出违背BCNF的函数依赖X→B。</li><li>求X的属性闭包X+，并将X+中的属性做成一张表R1。</li><li>将R-(X+)+X中的属性做成一张表R2。</li><li>使用 <a href="#函数依赖集的投影">函数依赖集的投影</a> 的方法求R1、R2的函数依赖集合，并检查R1、R2是否有违背BCNF的函数依赖。如果有则重复上述步骤，否则停止分解。</li></ul><p>此方法能够保证无损分解、无损连接，但不一定能保持原有的函数依赖。如果在实际应用中找不到保证函数依赖BCNF分解方式（例如，函数依赖集合F={AB→C, C→B}，键为{AB}、{AC}，不违背3NF），则可以退回3NF。</p><h3 id="nf-3">4NF</h3><ul><li><strong>满足BCNF，消除非平凡且非FD的多值依赖(MVD)。</strong>4NF就是限制关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖。</li><li>也就是说，当一个表中的非主属性互相独立时（3NF），这些非主属性不应该有多值。若有多值就违反了第四范式。</li><li>通俗地说，这种情况是试图在一张表中说多个事情，但是一般来讲，一张表就讲一个事情。</li><li>如果存在违背4NF的多值依赖，即<strong>当且仅当非平凡MVD（或者非平凡FD）箭头左边不是超键的时候</strong>，即不属于4NF。但是此时的键和超键的定义跟原来是一样的，都是基于一般的函数依赖。</li><li>推论：只有两个属性的表是BCNF，也是4NF。</li></ul><h4 id="分解成4nf">分解成4NF</h4><ul><li>关键：对于多值依赖X→→Y，使子模式的Z=Ø，仅有平凡多值依赖。</li><li>方法与BCNF分解类似。对于给定关系R，若找出违背4NF的多值依赖A1,A2,...,An→→B1,B2,...,Bm，则R可分解为两个模式：R1(A,B)，R2(A及R中所有不属于A和B的其他属性)。再用 <a href="#投影MVD">投影MVD</a> 的方法求R1、R2的函数依赖和多值依赖，并检查R1、R2是否有违背4NF的多值依赖。如果有则重复上述步骤，否则停止分解。</li></ul><h3 id="nf-4">5NF</h3><ul><li>是最终范式。<strong>消除连接依赖，并且必须保证数据完整性</strong>。</li><li>第四范式处理的是相互独立的多值情况，而第五范式则处理相互依赖的多值情况。</li></ul><h3 id="范式之间的联系">范式之间的联系</h3><p>范式之间存在包含关系。一个数据库设计如果符合第二范式，一定也符合第一范式。如果符合第三范式，一定也符合第二范式，依次类推。</p><table><thead><tr class="header"><th>性质</th><th>3NF</th><th>BCNF</th><th>4NF</th></tr></thead><tbody><tr class="odd"><td>消除FD带来的冗余</td><td>否</td><td>是</td><td>是</td></tr><tr class="even"><td>消除MVD带来的冗余</td><td>否</td><td>否</td><td>是</td></tr><tr class="odd"><td>保持FD</td><td>是</td><td>否</td><td>否</td></tr><tr class="even"><td>保持MVD</td><td>否</td><td>否</td><td>否</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 范式 </tag>
            
            <tag> 依赖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】454. 四数相加2</title>
      <link href="posts/7d64e6bd/"/>
      <url>posts/7d64e6bd/</url>
      
        <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/4sum-ii/" class="uri">https://leetcode-cn.com/problems/4sum-ii/</a></p><p>这次刷题居然是最有成就感的一次。。。</p><a id="more"></a><h2 id="题目描述">题目描述</h2><p>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 <code>(i, j, k, l)</code> ，使得 <code>A[i] + B[j] + C[k] + D[l] = 0</code>。</p><p>为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。</p><p><strong>例如:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">A = <span class="comment">[ 1, 2]</span></span><br><span class="line">B = <span class="comment">[-2,-1]</span></span><br><span class="line">C = <span class="comment">[-1, 2]</span></span><br><span class="line">D = <span class="comment">[ 0, 2]</span></span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">两个元组如下:</span><br><span class="line">1. (0, 0, 0, 1) -&gt; A<span class="comment">[0]</span> + B<span class="comment">[0]</span> + C<span class="comment">[0]</span> + D<span class="comment">[1]</span> = 1 + (-2) + (-1) + 2 = 0</span><br><span class="line">2. (1, 1, 0, 0) -&gt; A<span class="comment">[1]</span> + B<span class="comment">[1]</span> + C<span class="comment">[0]</span> + D<span class="comment">[0]</span> = 2 + (-1) + (-1) + 0 = 0</span><br></pre></td></tr></table></figure><h2 id="暴力解法会超时">暴力解法（会超时）</h2><p>最容易想的也是我最初只想到的就是暴力解法，但是肯定会超时</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; C, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; D)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; B.size(); j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; C.size(); k++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; D.size(); l++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (A[i] + B[j] + C[k] + D[l] == <span class="number">0</span>)</span><br><span class="line">                            count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(n^4)\)</span></p><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p><h2 id="哈希表">哈希表</h2><p>起初是使用两数之和那道题的思想，使用哈希表存储数组 <code>A</code> 中的信息，在哈希表中查找 <code>0 - B[j] - C[k] - D[l]</code> 对应的位置。这样就把4层for循环分成1个1层循环和1个3层循环，时间复杂度就降到 <span class="math inline">\(O(n^3)\)</span> 了。然后就又想到拆成两个两层for循环。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; C, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; D)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m; <span class="comment">// 哈希表中存储的是-(A[i] + B[j])对应的结果个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; B.size(); j++) &#123;</span><br><span class="line">                m[-(A[i] + B[j])]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; C.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; D.size(); j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> key = C[i] + D[j];</span><br><span class="line">                <span class="keyword">if</span> (m.find(key) != m.end())</span><br><span class="line">                    count += m[key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(n^2)\)</span></p><p>空间复杂度：<span class="math inline">\(O(n^2)\)</span></p><h2 id="注意">注意</h2><p>以下的代码会让程序使用内存更大。因为如果不预先判断 <code>map</code> 或者 <code>unordered_map</code> 中是否会有键相应的值，直接使用的话就会为这个键创建一个默认值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; C, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; D)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; B.size(); j++) &#123;</span><br><span class="line">                m[-(A[i] + B[j])]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; C.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; D.size(); j++) &#123;</span><br><span class="line">                count += m[C[i] + D[j]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】202. 快乐数</title>
      <link href="posts/6960ebdc/"/>
      <url>posts/6960ebdc/</url>
      
        <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/happy-number/" class="uri">https://leetcode-cn.com/problems/happy-number/</a></p><p>这题一点都不快乐……</p><a id="more"></a><h2 id="题目描述">题目描述</h2><p>编写一个算法来判断一个数 <code>n</code> 是不是快乐数。</p><p>「快乐数」定义为：</p><ul><li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li><li>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。</li><li>如果 <strong>可以变为</strong> 1，那么这个数就是快乐数。</li></ul><p>如果 <code>n</code> 是快乐数就返回 <code>true</code> ；不是，则返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight parser3"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">输入：</span><span class="number">19</span></span><br><span class="line"><span class="xml">输出：true</span></span><br><span class="line"><span class="xml">解释：</span></span><br><span class="line"><span class="number">1</span><span class="keyword">^2</span><span class="xml"> + </span><span class="number">9</span><span class="keyword">^2</span><span class="xml"> = </span><span class="number">82</span></span><br><span class="line"><span class="number">8</span><span class="keyword">^2</span><span class="xml"> + </span><span class="number">2</span><span class="keyword">^2</span><span class="xml"> = </span><span class="number">68</span></span><br><span class="line"><span class="number">6</span><span class="keyword">^2</span><span class="xml"> + </span><span class="number">8</span><span class="keyword">^2</span><span class="xml"> = </span><span class="number">100</span></span><br><span class="line"><span class="number">1</span><span class="keyword">^2</span><span class="xml"> + </span><span class="number">0</span><span class="keyword">^2</span><span class="xml"> + </span><span class="number">0</span><span class="keyword">^2</span><span class="xml"> = </span><span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">n</span> = <span class="number">2</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 2^31 - 1</code></li></ul><h2 id="一种投机取巧的方法">一种投机取巧的方法</h2><p>没想到怎么做，但还是有机会通过的。反正是觉得肯定是判断了一定的次数没判断出来那就认为不是快乐数。假设测试用例给出的数如果是快乐数，都可以在判断10000次（也许不需要这么多次）以内得出结果，那就：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> index = n % <span class="number">10</span>;</span><br><span class="line">                sum += index * index;</span><br><span class="line">                n = n / <span class="number">10</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (n);</span><br><span class="line">            <span class="keyword">if</span> (sum == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            n = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>据官方题解评论区，其实只需要判断10次就可以了！</p><figure><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210331213231190.png" alt><figcaption>image-20210331213231190</figcaption></figure><h2 id="哈希表">哈希表</h2><p>可以使用哈希表记录得出过的平方和。题目上说「无限循环」就说明某个平方和在计算的过程中肯定会出现至少两次（我怎么没想到），那就用哈希表判断一下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> index = n % <span class="number">10</span>;</span><br><span class="line">                sum += index * index;</span><br><span class="line">                n = n / <span class="number">10</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (n);</span><br><span class="line">            <span class="keyword">if</span> (s.find(sum) != s.end()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            n = sum;</span><br><span class="line">            s.insert(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另外，计算过程中出现的所有平方和不会无限增大，可以这样理解：</p><blockquote><p>因为即使一个数很大，它每个位置上的数字的平方和都不会很大。例如对于数字 <code>9999999999999</code> （13个9）来说，它每个位置上的数字的平方和为 <code>1053</code> （13为数每个位置上数字的平方和不会超过这个数），而 <code>1053</code> 每个位置上的数字的平方和就更小了。</p></blockquote><p><a href="https://leetcode-cn.com/problems/happy-number/solution/kuai-le-de-zhi-shi-dian-zeng-jia-liao-by-sweetiee/">某个大佬的题解</a>中有对应的证明，证明对一个数字计算每个位置上数字的平方和，结果会急剧减小。</p><h2 id="双指针快慢指针">双指针（快慢指针）</h2><p>当一个数很大的时候，计算过程中产生的平方和可能会导致哈希表所占的内存空间非常大。那么，如果将计算过程中出现的所有平方和都增加一个链表的尾部，那么将会形成一个有环的链表！就可以使用链表找环的方式求解！可以让空间复杂度变为 <span class="math inline">\(O(1)\)</span>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> index = n % <span class="number">10</span>;</span><br><span class="line">            sum += index * index;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (n);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fast = n, slow = n;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            slow = getNext(slow);</span><br><span class="line">            fast = getNext(getNext(fast));</span><br><span class="line">        &#125; <span class="keyword">while</span> (fast != slow);</span><br><span class="line">        <span class="keyword">return</span> fast == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210331233727506.png" alt="image-20210331233727506" style="zoom:50%;"></p><h2 id="总结">总结</h2><ul><li>总之，涉及到哈希表的题都和「检查是否重复」有关，以后做这类的题就往这个方向考虑吧</li><li>有的题可以转换成经典模型求解，比如这道题可以转换成判断链表是否有环的模型</li></ul>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】142. 环形链表2</title>
      <link href="posts/f0fa686e/"/>
      <url>posts/f0fa686e/</url>
      
        <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" class="uri">https://leetcode-cn.com/problems/linked-list-cycle-ii/</a></p><p>双指针的解法非常重要，要时常拿出来看一下</p><a id="more"></a><h2 id="题目描述">题目描述</h2><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p><p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意，<code>pos</code> 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</strong></p><p><strong>说明：</strong>不允许修改给定的链表。</p><p><strong>进阶：</strong></p><ul><li>你是否可以使用 <code>O(1)</code> 空间解决此题？</li></ul><p><strong>示例 1：</strong></p><p><img data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img" style="zoom:50%;"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">head</span> = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,-<span class="number">4</span>], <span class="attr">pos</span> = <span class="number">1</span></span><br><span class="line">输出：返回索引为 <span class="number">1</span> 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img" style="zoom:50%;"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">head</span> = [<span class="number">1</span>,<span class="number">2</span>], <span class="attr">pos</span> = <span class="number">0</span></span><br><span class="line">输出：返回索引为 <span class="number">0</span> 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img" style="zoom:50%;"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">head</span> = [<span class="number">1</span>], <span class="attr">pos</span> = -<span class="number">1</span></span><br><span class="line">输出：返回 <span class="literal">null</span></span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围在范围 <code>[0, 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li></ul><h2 id="哈希表">哈希表</h2><p>使用一个哈希表存储遍历过的节点。在遍历链表的过程中，如果该节点被遍历了两次（当前节点已经在哈希表中）则说明有环。若第一次出现被遍历过的节点，就返回该节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;ListNode*&gt; s;</span><br><span class="line">        ListNode *temp = head;</span><br><span class="line">        <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.find(temp) != s.end())</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            s.insert(temp);</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(n)\)</span></p><p>空间复杂度：<span class="math inline">\(O(n)\)</span></p><h2 id="双指针快慢指针">双指针（快慢指针）</h2><p>这个方法实在不好想出来，没想到数学推导才是重点啊！！！是我太菜了</p><p>定义快指针 <code>fast</code> 和慢指针 <code>slow</code> ，最初都指向头节点。快指针每次走两步，慢指针每次走一步，如果快慢指针相遇则说明链表有环（这个能想到，但相遇的位置不一定是<strong>链表开始入环的第一个节点</strong>）</p><p><img data-src="https://assets.leetcode-cn.com/solution-static/142/142_fig1.png" alt="fig1" style="zoom: 33%;"></p><p>借用官方题解的图，紫色的点是快指针和慢指针相遇节点位置。在相遇的时候，快指针走过的距离为： <span class="math display">\[a+n(b+c)+b=a+(n+1)b+nc\]</span> 快指针必须在环内走<span class="math inline">\(n (n\ge1)\)</span>圈才能和慢指针相遇。</p><p>而快指针走过的距离一定是慢指针走过的距离的两倍，则有： <span class="math display">\[a+(n+1)b+nc=2(a+b)\]</span> 解得： <span class="math display">\[a=(n-1)b+nc=(n-1)(b+c)+c\]</span> 即链表头节点到环的入口节点要走的距离等于<span class="math inline">\(c\)</span>再在环内走<span class="math inline">\(n-1\)</span>圈的距离。</p><p>这样，就新定义一个指针 <code>ptr</code> 指向头节点，<code>ptr</code> 和 <code>slow</code> 同时各走一步，相遇的位置即为链表开始入环的第一个节点。</p><p>特殊情况下，如果<span class="math inline">\(n\)</span>为<span class="math inline">\(1\)</span>，则<span class="math inline">\(a=c\)</span>， <code>slow</code> 走 <span class="math inline">\(c\)</span> 个节点的距离就能和 <code>ptr</code> 在链表开始入环的第一个节点相遇。</p><p>如果 <span class="math inline">\(n&gt;1\)</span> ，则 <code>slow</code> 必须在环内多转整整 <span class="math inline">\(n-1\)</span> 圈才能相遇。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *fast = head, *slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                ListNode *ptr = head;</span><br><span class="line">                <span class="keyword">while</span> (ptr != slow) &#123;</span><br><span class="line">                    ptr = ptr-&gt;next;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(n)\)</span></p><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p><h2 id="联动141.-环形链表">联动<a href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表</a></h2><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/" class="uri">https://leetcode-cn.com/problems/linked-list-cycle/</a></p><p>142和这道题相比，多了一个返回环的入口节点的要求，这道题仅仅只是判断有没有环</p><h3 id="哈希表-1">哈希表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;ListNode*&gt; s;</span><br><span class="line">        ListNode *temp = head;</span><br><span class="line">        <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.find(temp) != s.end())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            s.insert(temp);</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="双指针">双指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *fast = head, *slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="问题">问题</h2><h3 id="为何慢指针第一圈走不完一定会和快指针相遇即慢指针走了ab而不是a若干环的长度b呢">为何慢指针第一圈走不完一定会和快指针相遇？即慢指针走了a+b而不是a+若干环的长度+b呢</h3><p>引用评论区的一个评论：</p><blockquote><p>解释：为何慢指针第一圈走不完一定会和快指针相遇： 首先，第一步，快指针先进入环 第二步：当慢指针刚到达环的入口时，快指针此时在环中的某个位置（注意，快指针可能还没有走够一圈，可能已经走了超过一圈）(也可能此时相遇<strong>，此时相遇的位置就是环的入口节点</strong>) 第三步：设此时快指针和慢指针距离为x，若在第二步相遇，则x = 0； 第四步：设环的周长为n，那么看成快指针追赶慢指针，需要追赶n-x； 第五步：快指针每次都追赶慢指针1个单位，设慢指针速度1/s，快指针2/s，那么追赶需要(n-x)s 第六步：在n-x秒内，慢指针走了n-x单位，因为x&gt;=0，则慢指针走的路程小于等于n，即走不完一圈就和快指针相遇</p></blockquote><p>还有这个解释：<a href="https://mp.weixin.qq.com/s/vK0JjSTHfpAbs8evz5hH8A" class="uri">https://mp.weixin.qq.com/s/vK0JjSTHfpAbs8evz5hH8A</a></p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210330214649372.png" alt="image-20210330214649372" style="zoom:50%;"></p><p>对这里的理解：假设慢指针在进入环入口时，快指针在环的某个位置（但不是入口），快指针要走 <span class="math inline">\(k+n\)</span> 才能到达入口，相应地，慢指针要走 <span class="math inline">\((k+n)/2\)</span> （由于 <span class="math inline">\(k&lt;n\)</span>，所以 <span class="math inline">\((k+n)/2&lt;n\)</span>）。这样，如果快指针走到了入口，慢指针肯定没有走到入口，而且快指针就超过了慢指针，这显然不可能。因此，慢指针肯定没走够一圈就和快指针相遇了。</p><h3 id="为什么快指针每次必须走两步而不是三步">为什么快指针每次必须走两步，而不是三步？</h3><p>这样，两个指针可能不会相遇，而是快指针超过了慢指针，这样就死循环了。</p><blockquote><p>注意：假设把慢指针看作是静止的，那么快指针相对于慢指针的速度为走一步的速度；两个指针都进入环之后，可以看作是快指针追慢指针；如果快指针每次走两步，快指针是一个节点一个节点的靠近慢指针的，所以肯定可以和慢指针相遇，而不是跳过；如果快指针每次走三步，快指针相对于慢指针的速度为走两步的速度</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】19. 删除链表的倒数第N个结点</title>
      <link href="posts/1c8d5108/"/>
      <url>posts/1c8d5108/</url>
      
        <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" class="uri">https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/</a></p><a id="more"></a><h2 id="题目描述">题目描述</h2><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p><p><strong>示例 1：</strong></p><p><img data-src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="img" style="zoom:50%;"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1,2,3,4</span>,<span class="number">5</span>], n = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">1,2,3,5</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="comment">[1]</span>, n = 1</span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="comment">[1,2]</span>, n = 1</span><br><span class="line">输出：<span class="comment">[1]</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中结点的数目为 <code>sz</code></li><li><code>1 &lt;= sz &lt;= 30</code></li><li><code>0 &lt;= Node.val &lt;= 100</code></li><li><code>1 &lt;= n &lt;= sz</code></li></ul><h2 id="计算链表长度遍历两次">计算链表长度（遍历两次）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode *newHead = <span class="keyword">new</span> ListNode(), *temp;</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">0</span>, index = <span class="number">0</span>;</span><br><span class="line">        newHead-&gt;next = head;</span><br><span class="line">        temp = newHead;</span><br><span class="line">        <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        index = size - n;</span><br><span class="line">        temp = newHead;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        temp-&gt;next = temp-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> newHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="双指针快慢指针遍历一次">双指针（快慢指针，遍历一次）</h2><p>没想到这个方法，下次再来</p><p>定义快指针 <code>fast</code> 和慢指针 <code>slow</code> ，最初都指向虚拟头节点。快指针先单独走 <code>n + 1</code> 步，然后两个指针同时走，直到快指针走到链表末尾为止。此时慢指针指向节点的下一个节点就是要删除的节点（快指针先走 <code>n + 1</code> 步而不是 <code>n</code> 步的原因）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode *newHead = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode *fast = newHead, *slow = newHead;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        newHead-&gt;next = head;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++)</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (fast) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> newHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】206. 反转链表</title>
      <link href="posts/302b265c/"/>
      <url>posts/302b265c/</url>
      
        <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/reverse-linked-list/" class="uri">https://leetcode-cn.com/problems/reverse-linked-list/</a></p><p>大厂考的非常多的题，一定要反复刷，不能忘了，背下来吧！！！</p><a id="more"></a><h2 id="题目描述">题目描述</h2><p>反转一个单链表。</p><p><strong>示例:</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL</span><br><span class="line">输出: <span class="number">5</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong> 你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p><h2 id="我的方法迭代">我的方法（迭代）</h2><p>始终改变头节点指针 <code>head</code> 的指向</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr-&gt;next) &#123;</span><br><span class="line">            ListNode *temp = curr-&gt;next-&gt;next;</span><br><span class="line">            curr-&gt;next-&gt;next = head;</span><br><span class="line">            head = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="迭代">迭代</h2><p><code>curr</code> 表示当前遍历到的位置，<code>prev</code> 当前位置的上一个节点，<code>next</code> 是当前位置的下一个节点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *curr = head,  *prev = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">            <span class="comment">// 将原先的下一个节点记录下来，因为指向下一个节点的指针要指向原先的前一个节点</span></span><br><span class="line">            ListNode *next = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(n)\)</span></p><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p><h2 id="递归">递归</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当链表只有一个元素或者为空的时候，反转的结果就是自己</span></span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *temp = reverseList(head-&gt;next);</span><br><span class="line">        <span class="comment">// head-&gt;next-&gt;next：已经被反转的链表的末尾（NULL）</span></span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(n)\)</span></p><p>空间复杂度：<span class="math inline">\(O(n)\)</span>（递归调用栈空间最多为<span class="math inline">\(n\)</span>层，每一层的空间是常数级别）</p><blockquote><p><strong>递归算法的时间复杂度 = 递归的次数 * 每次递归的时间复杂度</strong></p><p><strong>递归算法的空间复杂度 = 每次递归的空间复杂度 * 递归深度</strong></p></blockquote><p>引用题解评论区的一句话辅助理解：</p><blockquote><p>递归的意思：我子节点下的所有节点都已经反转好了，现在就剩我和我的子节点 没有完成最后的反转了，所以反转一下我和我的子节点。</p></blockquote><p>一次递归操作前后示意图：</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210329211641698.png" alt="image-20210329211641698" style="zoom:50%;"></p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】707. 设计链表</title>
      <link href="posts/b4e42ef2/"/>
      <url>posts/b4e42ef2/</url>
      
        <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/design-linked-list/" class="uri">https://leetcode-cn.com/problems/design-linked-list/</a></p><a id="more"></a><h2 id="题目描述">题目描述</h2><p>设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：<code>val</code> 和 <code>next</code>。<code>val</code> 是当前节点的值，<code>next</code> 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 <code>prev</code> 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。</p><p>在链表类中实现这些功能：</p><ul><li>get(index)：获取链表中第 <code>index</code> 个节点的值。如果索引无效，则返回<code>-1</code>。</li><li>addAtHead(val)：在链表的第一个元素之前添加一个值为 <code>val</code> 的节点。插入后，新节点将成为链表的第一个节点。</li><li>addAtTail(val)：将值为 <code>val</code> 的节点追加到链表的最后一个元素。</li><li>addAtIndex(index,val)：在链表中的第 <code>index</code> 个节点之前添加值为 <code>val</code> 的节点。如果 <code>index</code> 等于链表的长度，则该节点将附加到链表的末尾。如果 <code>index</code> 大于链表长度，则不会插入节点。如果<code>index</code>小于0，则在头部插入节点。</li><li>deleteAtIndex(index)：如果索引 <code>index</code> 有效，则删除链表中的第 <code>index</code>个节点。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyLinkedList linkedList = <span class="keyword">new</span> MyLinkedList();</span><br><span class="line">linkedList.addAtHead(<span class="number">1</span>);</span><br><span class="line">linkedList.addAtTail(<span class="number">3</span>);</span><br><span class="line">linkedList.addAtIndex(<span class="number">1</span>,<span class="number">2</span>);   <span class="comment">//链表变为1-&gt; 2-&gt; 3</span></span><br><span class="line">linkedList.get(<span class="number">1</span>);            <span class="comment">//返回2</span></span><br><span class="line">linkedList.deleteAtIndex(<span class="number">1</span>);  <span class="comment">//现在链表是1-&gt; 3</span></span><br><span class="line">linkedList.get(<span class="number">1</span>);            <span class="comment">//返回3</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>所有<code>val</code>值都在 <code>[1, 1000]</code> 之内。</li><li>操作次数将在 <code>[1, 1000]</code> 之内。</li><li>请不要使用内置的 LinkedList 库。</li></ul><h2 id="解法">解法</h2><p>没啥好说的，就是总是容易忘掉改变链表长度 <code>len</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    ListNode *head;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    MyLinkedList() &#123;</span><br><span class="line">        head = <span class="literal">nullptr</span>;</span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        ListNode *temp = head;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == index)</span><br><span class="line">                <span class="keyword">return</span> temp-&gt;val;</span><br><span class="line">            i++;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *temp = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">        temp-&gt;next = head;</span><br><span class="line">        head = temp;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Append a node of value val to the last element of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head)</span><br><span class="line">            addAtHead(val);</span><br><span class="line">        ListNode *temp = head;</span><br><span class="line">        <span class="keyword">while</span> (temp-&gt;next)</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        temp-&gt;next = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == len)</span><br><span class="line">            addAtTail(val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (index &lt;= <span class="number">0</span>)</span><br><span class="line">            addAtHead(val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (index &gt; len)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            ListNode *curr = head;</span><br><span class="line">            <span class="keyword">while</span> (curr-&gt;next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (curr-&gt;next &amp;&amp; i + <span class="number">1</span> == index) &#123;</span><br><span class="line">                    ListNode *temp = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">                    temp-&gt;next = curr-&gt;next;</span><br><span class="line">                    curr-&gt;next = temp;</span><br><span class="line">                    len++;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">                curr = curr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Delete the index-th node in the linked list, if the index is valid. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ListNode *temp = head;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (temp-&gt;next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> == index) &#123;</span><br><span class="line">                    temp-&gt;next = temp-&gt;next-&gt;next;</span><br><span class="line">                    len--;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">                temp = temp-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>学习一下别人的代码（使用虚拟头节点）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    ListNode *head; <span class="comment">// 虚拟头节点</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    MyLinkedList() &#123;</span><br><span class="line">        head = <span class="keyword">new</span> ListNode();</span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= len || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        ListNode *temp = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index + <span class="number">1</span>; i++)</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> temp-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *temp = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">        temp-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next = temp;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Append a node of value val to the last element of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *temp = head;</span><br><span class="line">        <span class="keyword">while</span> (temp-&gt;next)</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        temp-&gt;next = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; len)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        ListNode *curr = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        ListNode *temp = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">        temp-&gt;next = curr-&gt;next;</span><br><span class="line">        curr-&gt;next = temp;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Delete the index-th node in the linked list, if the index is valid. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= len || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        ListNode *temp = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        temp-&gt;next = temp-&gt;next-&gt;next;</span><br><span class="line">        len--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】203. 移除链表元素</title>
      <link href="posts/381b9ed0/"/>
      <url>posts/381b9ed0/</url>
      
        <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/remove-linked-list-elements/" class="uri">https://leetcode-cn.com/problems/remove-linked-list-elements/</a></p><p>这么经典的题一定要能手撕啊！！！</p><a id="more"></a><h2 id="题目描述">题目描述</h2><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p><p><strong>示例 1：</strong></p><p><img data-src="https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg" alt="img" style="zoom:50%;"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="string">[1,2,6,3,4,5,6]</span>, val = <span class="number">6</span></span><br><span class="line">输出：<span class="string">[1,2,3,4,5]</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="comment">[]</span>, val = 1</span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="comment">[7,7,7,7]</span>, val = 7</span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>列表中的节点在范围 <code>[0, 10^4]</code> 内</li><li><code>1 &lt;= Node.val &lt;= 50</code></li><li><code>0 &lt;= k &lt;= 50</code></li></ul><h2 id="考虑头节点的删除逻辑">考虑头节点的删除逻辑</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (head &amp;&amp; head-&gt;val == val) &#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!head)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *temp = head;</span><br><span class="line">        <span class="keyword">while</span> (temp-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp-&gt;next-&gt;val == val) </span><br><span class="line">                temp-&gt;next = temp-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="使用虚拟头节点">使用虚拟头节点</h2><p>在真实头节点的前面新建虚拟头节点（其下一个节点为真实头节点）可以统一所有节点的删除逻辑。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *newHead = <span class="keyword">new</span> ListNode(), *temp;</span><br><span class="line">        newHead-&gt;next = head;</span><br><span class="line">        temp = newHead;</span><br><span class="line">        <span class="keyword">while</span> (temp-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp-&gt;next-&gt;val == val) </span><br><span class="line">                temp-&gt;next = temp-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="递归">递归</h2><p>某个大佬在题解里给出来的。链表和二叉树一样都是递归的结构，所以也可以用递归。每次都写不好递归终止的条件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        head-&gt;next = removeElements(head-&gt;next, val);</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;val == val)</span><br><span class="line">            <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="注意">注意</h2><p>在真实的链表删除场景下，如果使用C++应该将删除的节点内存释放掉，虚拟头节点也是。</p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】59. 螺旋矩阵2</title>
      <link href="posts/cfb5c3b1/"/>
      <url>posts/cfb5c3b1/</url>
      
        <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">https://leetcode-cn.com/problems/spiral-matrix-ii/</a></p><p>总算有一道完成最快的中等题了……</p><a id="more"></a><h2 id="题目描述">题目描述</h2><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n^2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p><p><strong>示例 1：</strong></p><figure><img data-src="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg" alt><figcaption>img</figcaption></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span></span><br><span class="line">输出：<span class="string">[[1,2,3],[8,9,4],[7,6,5]]</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：<span class="string">[[1]]</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li></ul><h2 id="按层模拟">按层模拟</h2><p>从外层到内层模拟矩阵生成，将数字依次填入空矩阵中，找出循环规律即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n - i; j++) &#123;</span><br><span class="line">                result[i][j] = ++count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n - i; j++) &#123;</span><br><span class="line">                result[j][n - <span class="number">1</span> - i] = ++count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">2</span> - i; j &gt;= i; j--) &#123;</span><br><span class="line">                result[n - <span class="number">1</span> - i][j] = ++count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">2</span> - i; j &gt; i; j--) &#123;</span><br><span class="line">                result[j][i] = ++count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(n^{2})\)</span></p><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210328021723779.png" alt="image-20210328021723779" style="zoom:50%;"></p><h2 id="按方向模拟">按方向模拟</h2><p>参考官方题解，可以按照行走的方向进行模拟，如果出现了超越数组边界或者遇到已经走过的位置的情况，则转向：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">int</span> direction[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>, col = <span class="number">-1</span>, currDir = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (count &lt; n * n) &#123;</span><br><span class="line">            <span class="keyword">int</span> newRow = row + direction[currDir][<span class="number">0</span>], newCol = col + direction[currDir][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (newRow &gt;= n || newRow &lt; <span class="number">0</span> || newCol &gt;= n || newCol &lt; <span class="number">0</span> || result[newRow][newCol] != <span class="number">0</span>)</span><br><span class="line">                currDir = (currDir + <span class="number">1</span>) % <span class="number">4</span>;;</span><br><span class="line">            row += direction[currDir][<span class="number">0</span>];</span><br><span class="line">            col += direction[currDir][<span class="number">1</span>];</span><br><span class="line">            result[row][col] = ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(n^{2})\)</span></p><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 数组 </tag>
            
            <tag> 矩阵 </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】209. 长度最小的子数组</title>
      <link href="posts/22db2e16/"/>
      <url>posts/22db2e16/</url>
      
        <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">https://leetcode-cn.com/problems/minimum-size-subarray-sum/</a></p><a id="more"></a><h2 id="题目描述">题目描述</h2><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> 。</p><p>找出该数组中满足其和 <code>≥ target</code> 的长度最小的 连续子数组 <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度。如果不存在符合条件的子数组，返回 <code>0</code> 。</p><p>示例 1：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 7, nums = <span class="comment">[2,3,1,2,4,3]</span></span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 <span class="comment">[4,3]</span> 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">target</span> = <span class="number">4</span>, <span class="attr">nums</span> = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = <span class="number">11</span>, nums = [<span class="number">1,1,1,1</span>,<span class="number">1,1,1,1</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= target &lt;= 10^9</code></li><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>1 &lt;= nums[i] &lt;= 10^5</code></li></ul><p>进阶：</p><ul><li>如果你已经实现 <code>O(n)</code> 时间复杂度的解法, 请尝试设计一个 <code>O(n log(n))</code> 时间复杂度的解法。</li></ul><h2 id="暴力解法">暴力解法</h2><p>也不知道怎么回事，想出来的第一个暴力解法居然是3个for循环的，于是就理所应当地在最后一个例子那里超时了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="keyword">int</span> minSum = INT_MAX, len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (len = <span class="number">1</span>; len &lt;= size; len++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - len + <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++)</span><br><span class="line">                    sum += nums[i + j];</span><br><span class="line">                <span class="keyword">if</span> (sum &lt; minSum &amp;&amp; sum &gt;= target)</span><br><span class="line">                    minSum = sum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (minSum &gt;= target &amp;&amp; minSum &lt; INT_MAX)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minSum &lt; INT_MAX ? len : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><del>经过题解的提示写出</del>两个for循环的版本，可以通过：</p><p>（我怎么没想到第二个循环可以边遍历边求和，只需要满足条件的最小长度就行）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="keyword">int</span> minLen = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>, j;</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &lt; size; j++) &#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt;= target) &#123;</span><br><span class="line">                    minLen = min(minLen, j - i + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minLen &lt; INT_MAX ? minLen : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(n^{2})\)</span></p><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p><h2 id="使用滑动窗口">使用滑动窗口</h2><p><code>i</code> 作为滑动窗口的起始位置，<code>j</code> 作为滑动窗口的末尾，<code>sum</code> 是在窗口内的数组元素的和。在不满足<code>sum &gt;= target</code>的条件先在末尾处扩大窗口，满足了之后再在起始处缩小窗口直到不满足条件为止。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, minLen = INT_MAX;</span><br><span class="line">        <span class="comment">// 在不满足sum &gt;= target的条件先扩大窗口</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">            <span class="comment">// 缩小窗口</span></span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">                minLen = min(minLen, j - i + <span class="number">1</span>);</span><br><span class="line">                sum -= nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minLen &lt; INT_MAX ? minLen : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(n)\)</span>（指针 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(j\)</span> 最多不会移动超过 <span class="math inline">\(n\)</span> 次，两个指针移动的总次数不会超过 <span class="math inline">\(2n\)</span> 次）</p><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p><h2 id="前缀和二分查找">前缀和+二分查找</h2><p>进阶问题需要的解法</p><p>需要开辟一个数组 <code>sums</code> 存放 <code>nums</code> 数组各个元素的前缀和，<code>sums[i]</code> 表示从 <code>nums[0]</code> 到 <code>nums[i−1]</code> 的元素之和，长度为 <code>nums</code> 数组的长度 + 1。原数组 <code>nums</code> 不是有序的，但是 <code>sums</code> 是递增的，可以进行二分查找。</p><p>遍历 <code>sums</code> 数组，通过二分查找找到 <code>&gt;= sums[i - 1] + target</code> 的第一个前缀和的位置 <code>j</code>。</p><p>这样题目的条件转化成 <code>sums[j] - sums[i - 1] &gt;= target</code>，对应于原数组 <code>nums</code> ，就是在 <code>i - 1 &lt;= pos &lt;= j - 1</code> 之间的元素总和 <code>&gt;= target</code>，这部分子数组的长度为 <code>j - i + 1</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size();</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="keyword">int</span> minLen = INT_MAX;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sums</span><span class="params">(size + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= size; i++) &#123;</span><br><span class="line">            sums[i] = sums[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= size; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> s = target + sums[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> index = binarySearch(s, sums);</span><br><span class="line">            <span class="keyword">if</span> (index &lt;= size)</span><br><span class="line">                minLen = min(minLen, index - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minLen &lt; INT_MAX ? minLen : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(n\log n)\)</span></p><p>空间复杂度：<span class="math inline">\(O(n)\)</span></p><h2 id="总结">总结</h2><ul><li>当涉及到<strong><em>连续子数组</em></strong>的时候可以考虑的方法：滑动窗口、前缀和<ul><li>构造前缀和数组是构造一个有序数组的思路之一，数组有序就可以尝试使用二分查找、双指针等方法</li></ul></li><li>使用双指针和滑动窗口都可以减少for循环的层数，降低时间复杂度<ul><li>滑动窗口是根据当前子序列和大小的情况，不断调节子序列的<strong><em>起始位置</em></strong></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】27. 移除元素</title>
      <link href="posts/db646e5f/"/>
      <url>posts/db646e5f/</url>
      
        <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/remove-element/">https://leetcode-cn.com/problems/remove-element/</a></p><p>双指针的经典题目，这次没做出来下次再来做</p><a id="more"></a><h2 id="题目描述">题目描述</h2><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong>原地</strong> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 <span class="math inline">\(O(1)\)</span> 额外空间并 <strong>原地</strong> 修改输入数组。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p>示例 1：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">nums</span> = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="attr">val</span> = <span class="number">3</span></span><br><span class="line">输出：<span class="number">2</span>, <span class="attr">nums</span> = [<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">解释：函数应该返回新的长度 <span class="number">2</span>, 并且 nums 中的前两个元素均为 <span class="number">2</span>。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 <span class="number">2</span> ，而 <span class="attr">nums</span> = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>] 或 <span class="attr">nums</span> = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>]，也会被视作正确答案。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0,1,2,2</span>,<span class="number">3,0,4,2</span>], val = <span class="number">2</span></span><br><span class="line">输出：<span class="number">5</span>, nums = [<span class="number">0,1,4,0</span>,<span class="number">3</span>]</span><br><span class="line">解释：函数应该返回新的长度 <span class="number">5</span>, 并且 nums 中的前五个元素为 <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><blockquote><p>示例中输出的数字（慢指针）就提示了用双指针了啊啊啊</p></blockquote><p>提示：</p><ul><li><code>0 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 50</code></li><li><code>0 &lt;= val &lt;= 100</code></li></ul><h2 id="暴力法">暴力法</h2><p>从左到右遍历，遇到一个等于 <code>val</code> 的元素，就将 <code>i</code> 之后的所有元素整体向前移动一格</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size(), i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == val) &#123;</span><br><span class="line">                <span class="keyword">int</span> k = i;</span><br><span class="line">                <span class="comment">// 将i之后的所有元素整体向前移动一格</span></span><br><span class="line">                <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; size; j++) &#123;</span><br><span class="line">                    nums[k] = nums[j];</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 遇到一个等于val的元素就从数组中删掉一个</span></span><br><span class="line">                size--;</span><br><span class="line">                <span class="comment">// 可能原先第i+1个元素可能还等于val，移动之后第i个元素还是val，因此下次循环i的位置不变</span></span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(n^2)\)</span></p><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p><h2 id="双指针">双指针</h2><h3 id="基于数据拷贝">基于数据拷贝</h3><p>定义慢指针 <code>i</code> 和快指针 <code>j</code> ，均从0开始。使用快指针来遍历整个数组，快指针 <code>j</code> 指向的当前元素不是 <code>val</code> 就覆盖 <code>i</code> 处的值，是 <code>val</code> 就跳过</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size(), i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] != val)</span><br><span class="line">                nums[i++] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(n)\)</span></p><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p><p>（现在觉得双指针是个神奇的技术，可以将<span class="math inline">\(O(n^2)\)</span>的时间复杂度减为<span class="math inline">\(O(n)\)</span>，但是总是想不起来怎么写，还是要多练啊）</p><h3 id="基于交换">基于交换</h3><p>上述的方法在要删除的元素很少时，会引起多次不必要的数据拷贝。因此可以将要删除的元素移动到数组的最后。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size(), i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == val) &#123;</span><br><span class="line">                swap(nums[i], nums[size - <span class="number">1</span>]);</span><br><span class="line">                <span class="comment">// 遇到一个等于val的元素就从数组中删掉一个</span></span><br><span class="line">                size--;</span><br><span class="line">                <span class="comment">// 可能被移动过来的最后一个元素仍然等于val，因此i不变，下次循环继续做交换操作</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(n)\)</span></p><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】35. 搜索插入位置</title>
      <link href="posts/597d7713/"/>
      <url>posts/597d7713/</url>
      
        <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/search-insert-position/">https://leetcode-cn.com/problems/search-insert-position/</a></p><p>很常规的一道题。</p><a id="more"></a><h2 id="题目描述">题目描述</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><p>示例 1:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: [1,3,5,6], 5</span></span><br><span class="line"><span class="section">输出: 2</span></span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: [1,3,5,6], 2</span></span><br><span class="line"><span class="section">输出: 1</span></span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: [1,3,5,6], 7</span></span><br><span class="line"><span class="section">输出: 4</span></span><br></pre></td></tr></table></figure><p>示例 4:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: [1,3,5,6], 0</span></span><br><span class="line"><span class="section">输出: 0</span></span><br></pre></td></tr></table></figure><h2 id="一次遍历的暴力法">一次遍历的暴力法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target &lt;= nums[i])</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(n)\)</span></p><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p><h2 id="二分查找">二分查找</h2><p>返回 <code>&gt;= target</code> 的第一个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size(), mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(\log n)\)</span></p><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo NexT 主题v8.0版本深度定制（三）：样式自定义</title>
      <link href="posts/d1cbbcd1/"/>
      <url>posts/d1cbbcd1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo NexT 主题v8.0版本深度定制（二）：插件</title>
      <link href="posts/b09f2018/"/>
      <url>posts/b09f2018/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>解决VMware Linux虚拟机出现的Read-only file system的问题</title>
      <link href="posts/e809bf36/"/>
      <url>posts/e809bf36/</url>
      
        <content type="html"><![CDATA[<p>今天想要用实验室的一台Ubuntu 18的虚拟机（一直处于运行状态，但是也没有做任何操作），打开它的界面之后出现了莫名其妙的错误，屏幕整个都是黑的，一直在输出类似如下的文字，也不能用命令行操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemd-journald[404]: Failed to write entry (22 items，750 bytes),ignoring: Read-only file system</span><br></pre></td></tr></table></figure><p>之前遇到这样的问题我都是直接用虚拟机快照恢复到最近的的状态，但是这台虚拟机我并没有备份快照……</p><p>从网上找了一些解决方案，总算找到了解决方法，现在记录在这里。</p><a id="more"></a><h2 id="ssh登录">SSH登录</h2><p>因为出现问题的虚拟机不能直接用命令行操作，所以先尝试使用SSH登录来使用命令行操作这台虚拟机。可以使用另外一台正常的虚拟机，打开终端，输入以下命令登录到出问题的虚拟机：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh 用户名@IP地址</span><br></pre></td></tr></table></figure><p>如果不记得这台虚拟机的IP地址，可以在虚拟机列表当中右击这台虚拟机，找到SSH选项，再点击「连接到SSH」</p><figure><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210315142441090.png" alt><figcaption>image-20210315142441090</figcaption></figure><p>首次连接会出现以下对话框，填写当前用户名，点击连接，即可登录。</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210315142635078.png" alt="image-20210315142635078" style="zoom:50%;"></p><h2 id="修复错误">修复错误</h2><p>登录到这台虚拟机之后，通过执行以下命令发现系统无法创建日志文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl --verify</span><br></pre></td></tr></table></figure><figure><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210315104333744.png" alt><figcaption>image-20210315104333744</figcaption></figure><p>然后执行此命令修复根目录挂载点下的文件系统：（注意：最好不要贸然执行这条命令，可能也会导致系统无法正常启动）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo fsck -y /</span><br></pre></td></tr></table></figure><figure><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210315104414931.png" alt><figcaption>image-20210315104414931</figcaption></figure><figure><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210315104923282.png" alt><figcaption>image-20210315104923282</figcaption></figure><p>可以发现是 <code>/dev/sda1</code> 分区出了问题，并且现在已经修复，重启虚拟机：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo shutdown -r now</span><br></pre></td></tr></table></figure><p>这样虚拟机重启之后，居然也没有进入 initramfs 命令行，直接正常进入系统了。</p><h2 id="参考">参考</h2><p><a href="https://blog.csdn.net/qin1137248135/article/details/108273596">https://blog.csdn.net/qin1137248135/article/details/108273596</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> VMware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo NexT 主题v8.0版本深度定制（一）：基础配置</title>
      <link href="posts/1f255d04/"/>
      <url>posts/1f255d04/</url>
      
        <content type="html"><![CDATA[<p>这是Hexo NexT主题v8.0版本的配置记录，以下配置在<a href="https://theme-next.js.org/docs/">主题官方文档</a>中都能直接找到，并且只记录了本人修改过的值，如果有没提到的配置可以先看看官方文档。</p><p>建议在使用新的主题之前都先看看文档啊！！！</p><a id="more"></a><h2 id="声明">声明</h2><p>本文中的站点根目录为：<code>blog/hexo/</code></p><p>站点配置文件为：<code>blog/hexo/_config.yml</code></p><p>NexT主题配置文件为：<code>blog/hexo/_config.next.yml</code></p><h2 id="安装并使用主题">安装并使用主题</h2><p>从 Hexo v5.0 版本开始，NexT主题官方推荐的安装方式是从npm安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过npm安装</span></span><br><span class="line">npm install hexo-theme-next</span><br><span class="line"><span class="comment"># 将主题配置文件拷贝到主题根目录下</span></span><br><span class="line">cp node_modules/hexo-theme-next/_config.yml _config.next.yml</span><br><span class="line"><span class="comment"># 升级NexT版本到最新版的方式</span></span><br><span class="line">npm install hexo-theme-next@latest</span><br></pre></td></tr></table></figure><p>打开站点配置文件，搜索 <code>theme</code> 关键字，将其值改为 <code>next</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure><p>注意：在主题根目录下的 <code>themes/</code> 子目录下不能有和 <code>next</code> 同名的子目录，否则从npm新安装的主题不能生效。</p><p>这样，在主题根目录下执行以下命令，从浏览器打开<a href="http://localhost:4000">http://localhost:4000</a>就可以看到主题效果了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo s --debug</span><br></pre></td></tr></table></figure><h2 id="基础配置">基础配置</h2><h3 id="更改主题样式">更改主题样式</h3><p>打开主题配置文件，搜索 <code>scheme</code> 关键字，将其值修改为以下四个值的任意一个（采用哪个就把哪一行的注释取消掉，将不采用的样式值注释掉），我用的是 <code>Mist</code> 样式：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment"># scheme: Muse</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="comment">#scheme: Gemini</span></span><br></pre></td></tr></table></figure><h3 id="黑暗模式">黑暗模式</h3><p>打开主题配置文件，搜索 <code>darkmode</code> 关键字，将其值修改为 <code>true</code> 即可启用黑暗模式：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">darkmode:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="修改网站图标">修改网站图标</h3><p>将网站图标文件放置在站点根目录下的 <code>source/images/</code> 文件夹中。</p><p>打开主题配置文件，搜索 <code>favicon</code> 关键字，修改配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">favicon:</span></span><br><span class="line">  <span class="attr">small:</span> <span class="string">/images/xxx.ico</span></span><br><span class="line">  <span class="attr">medium:</span> <span class="string">/images/xxx.ico</span></span><br><span class="line">  <span class="attr">apple_touch_icon:</span> <span class="string">/images/xxx.ico</span></span><br><span class="line">  <span class="attr">safari_pinned_tab:</span> <span class="string">/images/xxx.ico</span></span><br><span class="line">  <span class="comment">#android_manifest: /manifest.json</span></span><br></pre></td></tr></table></figure><p>网站图标素材来源：</p><ul><li><a href="http://www.easyicon.net/">EasyIcon</a></li><li><a href="https://realfavicongenerator.net/">Favicon Generator</a></li></ul><h3 id="在侧边栏和文章底下显示许可证信息">在侧边栏和文章底下显示许可证信息</h3><p>打开主题配置文件，搜索 <code>creative_commons</code> 关键字，修改配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">by-nc-sa</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">language:</span></span><br></pre></td></tr></table></figure><p><code>language</code> 设置为空则默认采用站点的语言。</p><h3 id="网站菜单项配置">网站菜单项配置</h3><p>稍后再写</p><p>显示设置：</p><p>打开主题配置文件，搜索 <code>menu_settings</code> 关键字：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu_settings:</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">badges:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li><code>icons</code> 为 <code>true</code> 则显示菜单图标</li><li><code>badges</code> 为 <code>true</code> 则显示文章、标签、类别的数目</li></ul><p>两个选项都设置为 <code>true</code> 的效果如下：</p><figure><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210313170644837.png" alt><figcaption>image-20210313170644837</figcaption></figure><h2 id="侧边栏配置">侧边栏配置</h2><h3 id="侧边栏显示位置">侧边栏显示位置</h3><p>可设置显示在左侧（<code>left</code>）还是右侧（<code>right</code>）。</p><p>打开主题配置文件，搜索 <code>sidebar</code> 关键字，将选项 <code>position</code> 的值改为 <code>left</code> 或 <code>right</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sidebar:</span></span><br><span class="line">  <span class="comment"># Sidebar Position.</span></span><br><span class="line">  <span class="comment"># position: left</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">right</span></span><br></pre></td></tr></table></figure><h3 id="自动打开侧边栏">自动打开侧边栏</h3><p>NexT的默认设置是打开一个有目录索引的页面会自动打开侧边栏。</p><p>打开主题配置文件，搜索 <code>sidebar</code> 关键字，将选项 <code>display</code> 的值改为以下四个值：</p><ul><li><code>post</code>：默认值，打开一个有目录索引的页面（例如文章正文页面）会自动打开侧边栏，用户可以手动打开或关闭</li><li><code>always</code> ：访问站点的每个页面都自动打开侧边栏，用户可以手动打开或关闭</li><li><code>hide</code> ：访问站点的每个页面都不会自动打开侧边栏，用户可以手动打开或关闭</li><li><code>remove</code>：完全移除侧边栏，用户也不可以手动打开或关闭</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sidebar:</span></span><br><span class="line">  <span class="attr">display:</span> <span class="string">post</span></span><br><span class="line">  <span class="comment">#display: always</span></span><br><span class="line">  <span class="comment">#display: hide</span></span><br><span class="line">  <span class="comment">#display: remove</span></span><br></pre></td></tr></table></figure><h3 id="显示头像">显示头像</h3><p>打开主题配置文件，搜索 <code>avatar</code> 关键字，修改 <code>url</code> 选项。<code>url</code> 是头像文件所在的路径，如果是本地文件可放在站点根目录下的 <code>source/images/</code> 文件夹中，也可以是网络中的URL（例如：<code>http(s)://example.com/avatar.png</code>）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Sidebar Avatar</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="comment"># Replace the default image and set the url here.</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/images/avatar.jpg</span></span><br></pre></td></tr></table></figure><h3 id="设置圆形且可以旋转的头像">设置圆形且可以旋转的头像</h3><p>打开主题配置文件，搜索 <code>avatar</code> 关键字，修改以下两个选项为 <code>true</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Sidebar Avatar</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be dispalyed in circle.</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be rotated with the cursor.</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这样侧边栏的头像就是圆形的了，而且鼠标移动到头像上会有旋转效果。</p><h3 id="显示社交链接">显示社交链接</h3><p>打开主题配置文件，搜索 <code>social</code> 关键字，设置要显示的社交链接（取消掉注释）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="comment">#GitHub: https://github.com/yourname || fab fa-github</span></span><br><span class="line">  <span class="comment">#E-Mail: mailto:yourname@gmail.com || fa fa-envelope</span></span><br><span class="line">  <span class="comment">#Weibo: https://weibo.com/yourname || fab fa-weibo</span></span><br><span class="line">  <span class="comment">#Google: https://plus.google.com/yourname || fab fa-google</span></span><br><span class="line">  <span class="comment">#Twitter: https://twitter.com/yourname || fab fa-twitter</span></span><br><span class="line">  <span class="comment">#FB Page: https://www.facebook.com/yourname || fab fa-facebook</span></span><br><span class="line">  <span class="comment">#StackOverflow: https://stackoverflow.com/yourname || fab fa-stack-overflow</span></span><br><span class="line">  <span class="comment">#YouTube: https://youtube.com/yourname || fab fa-youtube</span></span><br><span class="line">  <span class="comment">#Instagram: https://instagram.com/yourname || fab fa-instagram</span></span><br><span class="line">  <span class="comment">#Skype: skype:yourname?call|chat || fab fa-skype</span></span><br></pre></td></tr></table></figure><p>如果主题配置文件中没有给出（例如QQ、微信等），则按照以下格式增加：</p><p>格式：<code>网站名: 链接 || 图标</code></p><p>在主题配置文件中，搜索 <code>social_icons</code> 关键字，社交链接显示格式可以配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">social_icons:</span></span><br><span class="line">  <span class="comment"># 显示社交网站图标</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 只显示图标，不显示网站名</span></span><br><span class="line">  <span class="attr">icons_only:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># 如果设置为true，鼠标放在社交网站链接上会有淡入淡出的效果</span></span><br><span class="line">  <span class="attr">transition:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="禁用目录自动编号">禁用目录自动编号</h3><p>在主题配置文件中，搜索 <code>toc</code> 关键字，将选项 <code>number</code> 的值改为 <code>false</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="attr">number:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="目录文字换行显示">目录文字换行显示</h3><p>在主题配置文件中，搜索 <code>toc</code> 关键字，将选项 <code>wrap</code> 的值改为 <code>true</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这样如果目录中的文字超出了侧边栏的宽度可以换行显示，否则就会显示一个省略号，目录中的文字不能显示完整。</p><h3 id="只在侧边栏显示返回顶部按钮">只在侧边栏显示返回顶部按钮</h3><p>在主题配置文件中，搜索 <code>back2top</code> 关键字，进行以下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">back2top:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Back to top in sidebar.</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="页脚配置">页脚配置</h2><h3 id="显示网站开始年份">显示网站开始年份</h3><p>在主题配置文件中，搜索 <code>footer</code> 关键字，将选项 <code>since</code> 的值改为一个年份，格式类似 <code>© 2019 - 2020</code></p><p>若注释掉这个选项则只显示当前年份。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">since:</span> <span class="number">2019</span></span><br></pre></td></tr></table></figure><h3 id="显示一个跳动的小爱心">显示一个跳动的小爱心</h3><p>在主题配置文件中，搜索 <code>footer</code> 关键字，按照如下方法配置 <code>icon</code> 选项：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">icon:</span></span><br><span class="line">    <span class="comment"># 默认是一个爱心图标（fa fa-heart），来自Font Awesome，若更改为其他图标可访问https://fontawesome.com/icons</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">fa</span> <span class="string">fa-heart</span></span><br><span class="line">    <span class="comment"># 跳动效果</span></span><br><span class="line">    <span class="attr">animated:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 图标颜色，16进制颜色值</span></span><br><span class="line">    <span class="attr">color:</span> <span class="string">&quot;#ff0000&quot;</span></span><br></pre></td></tr></table></figure><h3 id="显示作者名">显示作者名</h3><p>在主题配置文件中，搜索 <code>footer</code> 关键字，配置 <code>copyright</code> 选项：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">copyright:</span></span><br></pre></td></tr></table></figure><p>如果 <code>copyright</code> 选项为空，则取站点配置文件中的作者名。</p><h3 id="去掉强力驱动">去掉「强力驱动」</h3><p>在主题配置文件中，搜索 <code>footer</code> 关键字，配置 <code>powered</code> 选项为 <code>false</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">powered:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="文章配置">文章配置</h2><h3 id="显示文章底部标签图标">显示文章底部标签图标</h3><p>默认情况下，文章底部标签的格式都是 <code># 标签名</code>。</p><p>在主题配置文件中，搜索 <code>tag_icon</code> ，并将其值设置为 <code>true</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tag_icon:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这样文章底部的标签就是显示成这样，更美观：</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210313183818634.png" alt="image-20210313183818634" style="zoom:50%;"></p><h3 id="显示相关文章">显示相关文章</h3><p>首先需要在站点根目录下安装对应的插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-related-popular-posts</span><br></pre></td></tr></table></figure><p>然后一定要执行一下 <code>hexo clean</code> ！</p><p>在主题配置文件中，搜索 <code>related_posts</code> ，进行以下设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">related_posts:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">title:</span> <span class="comment"># 可自行定制这一栏的标题</span></span><br><span class="line">  <span class="comment"># 是否在主页显示</span></span><br><span class="line">  <span class="attr">display_in_home:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">params:</span></span><br><span class="line">    <span class="comment"># 最多显示几条</span></span><br><span class="line">    <span class="attr">maxCount:</span> <span class="number">5</span></span><br><span class="line">    <span class="comment">#PPMixingRate: 0.0</span></span><br><span class="line">    <span class="comment">#isDate: false</span></span><br><span class="line">    <span class="comment">#isImage: false</span></span><br><span class="line">    <span class="comment">#isExcerpt: false</span></span><br></pre></td></tr></table></figure><h3 id="在文章标题后面显示编辑按钮">在文章标题后面显示编辑按钮</h3><p>在主题配置文件中，搜索 <code>post_edit</code> ，将 <code>enable</code> 选项设置为 <code>true</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_edit:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">https://github.com/user-name/repo-name/tree/branch-name/subdirectory-name/</span></span><br></pre></td></tr></table></figure><p>以我的配置为例，首先我将站点根目录作为Git仓库，并上传到了自己的GitHub远程仓库中。<code>url</code> 选项配置如下：</p><ul><li>如果进入源代码界面，则格式为：<code>https://github.com/user-name/repo-name/tree/branch-name/subdirectory-name/</code></li><li>如果进入编辑界面，则格式为：<code>https://github.com/user-name/repo-name/edit/branch-name/subdirectory-name/</code></li></ul><h3 id="更改代码块样式">更改代码块样式</h3><p>从v5.0开始，Hexo提供了 <a href="https://github.com/highlightjs/highlight.js">highlight.js</a> （默认）和 <a href="https://github.com/PrismJS/prism">prismjs</a> 两种代码高亮库的支持。highlight.js的主题样式多一些。</p><p>如果需要使用 highlight.js ，首先在站点配置文件中，进行以下设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 自动检测代码块的语言</span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 行号显示</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># tab替换字符</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;  &#x27;</span></span><br><span class="line">  <span class="comment"># highlight.js不支持行号显示，如果需要显示行号，必须将wrap设置为true</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 当hljs设置为true时，所有代码块的HTML输出均会给class添加hljs-前缀，无论wrap是否开启</span></span><br><span class="line">  <span class="attr">hljs:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>如果需要使用 prismjs，则在站点配置文件中，进行以下设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">prismjs:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">preprocess:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;  &#x27;</span></span><br></pre></td></tr></table></figure><p>在主题配置文件中，搜索 <code>codeblock</code> ，进行以下设置：</p><p>代码块所有可以设置的主题都可以在<a href="https://theme-next.js.org/highlight/">这里</a>查看。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="comment"># Code Highlight theme</span></span><br><span class="line">  <span class="comment"># All available themes: https://theme-next.js.org/highlight/</span></span><br><span class="line">  <span class="comment"># 设置 highlight.js 的主题</span></span><br><span class="line">  <span class="attr">theme:</span></span><br><span class="line">    <span class="attr">light:</span> <span class="string">default</span></span><br><span class="line">    <span class="attr">dark:</span> <span class="string">tomorrow-night</span></span><br><span class="line">  <span class="comment"># 设置 prismjs 的主题</span></span><br><span class="line">  <span class="attr">prism:</span></span><br><span class="line">    <span class="attr">light:</span> <span class="string">prism</span></span><br><span class="line">    <span class="attr">dark:</span> <span class="string">prism-dark</span></span><br><span class="line">  <span class="comment"># Add copy button on codeblock</span></span><br><span class="line">  <span class="attr">copy_button:</span></span><br><span class="line">    <span class="comment"># 启用复制代码按钮</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Available values: default | flat | mac</span></span><br><span class="line">    <span class="comment"># 显示Mac风格代码块，必须使用highlight.js</span></span><br><span class="line">    <span class="attr">style:</span> <span class="string">mac</span></span><br></pre></td></tr></table></figure><p>注意，如果使用 prismjs 的 additional themes（如下图），需要先在站点根目录下安装 <code>prism-themes</code> 插件。</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210313202353957.png" alt="image-20210313202353957" style="zoom:50%;"></p><p>在站点根目录下安装 <code>prism-themes</code> 插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install prism-themes</span><br></pre></td></tr></table></figure><h2 id="页面配置">页面配置</h2><h3 id="修改文本对齐方式为左对齐">修改文本对齐方式为左对齐</h3><p>NexT的文章正文中默认的文本对齐方式是 <code>justify</code> ，会实现文字的两端对齐，但是这样会让有些行的文字间隔拉得很大，感觉不好看。所以就改成左对齐了。</p><p>在主题配置文件中，搜索 <code>text_align</code> ，进行以下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">text_align:</span></span><br><span class="line">  <span class="comment"># Available values: start | end | left | right | center | justify | justify-all | match-parent</span></span><br><span class="line">  <span class="attr">desktop:</span> <span class="string">left</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="string">left</span></span><br></pre></td></tr></table></figure><h3 id="返回顶部按钮显示百分比">返回顶部按钮显示百分比</h3><p>在主题配置文件中，搜索 <code>back2top</code> 关键字，进行以下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">back2top:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Scroll percent label in b2t button.</span></span><br><span class="line">  <span class="attr">scrollpercent:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="显示阅读进度条">显示阅读进度条</h3><p>在主题配置文件中，搜索 <code>reading_progress</code> 关键字，进行以下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">reading_progress:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Available values: top | bottom</span></span><br><span class="line">  <span class="comment"># 在页面顶部还是底部显示</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">top</span></span><br><span class="line">  <span class="comment"># 颜色，16进制颜色值</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">&quot;#37c6c0&quot;</span></span><br><span class="line">  <span class="comment"># 阅读进度条占页面的高度</span></span><br><span class="line">  <span class="attr">height:</span> <span class="string">3px</span></span><br></pre></td></tr></table></figure><h3 id="启用书签">启用书签</h3><p>启用书签可以在关闭页面时自动保存页面的阅读进度，同时还会在页面左上角显示一个书签按钮，点击按钮也可以保存阅读进度。效果如下：</p><figure><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210313211002379.png" alt><figcaption>image-20210313211002379</figcaption></figure><p>在主题配置文件中，搜索 <code>bookmark</code> 关键字，进行以下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">bookmark:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Customize the color of the bookmark.</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">&quot;#222&quot;</span></span><br><span class="line">  <span class="comment"># If auto, save the reading progress when closing the page or clicking the bookmark-icon.</span></span><br><span class="line">  <span class="comment"># If manual, only save it by clicking the bookmark-icon.</span></span><br><span class="line">  <span class="attr">save:</span> <span class="string">auto</span></span><br></pre></td></tr></table></figure><h3 id="页面右上角显示github-banner">页面右上角显示GitHub Banner</h3><p>在主题配置文件中，搜索 <code>github_banner</code> 关键字，进行以下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># `Follow me on GitHub` banner in the top-right corner.</span></span><br><span class="line"><span class="attr">github_banner:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">permalink:</span> <span class="string">https://github.com/yourname</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">Follow</span> <span class="string">me</span> <span class="string">on</span> <span class="string">GitHub</span></span><br></pre></td></tr></table></figure><p>显示效果如下：</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210313211220853.png" alt="image-20210313211220853" style="zoom:50%;"></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
          <category> 主题配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> NexT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客更新记录</title>
      <link href="posts/e980311c/"/>
      <url>posts/e980311c/</url>
      
        <content type="html"><![CDATA[<h2 id="section">2021-07-28</h2><ul><li>优化响应式布局下的页面显示（尤其是移动端）</li></ul><a id="more"></a><h2 id="section-1">2021-04-05</h2><ul><li>增加主页和其他页面的封面图（样式还没调整完）</li></ul><h2 id="section-2">2021-03-27</h2><ul><li>加入加载动画</li><li>更换看板娘的后端API来源（因为想要血小板），感谢<a href="https://akilar.top/posts/5b8f515f/">Akilar</a>大佬</li></ul><h2 id="section-3">2021-03-21</h2><ul><li>加入黑夜模式，并可切换白天/黑夜模式</li><li>修改看板娘前端部分代码，以适配博客</li></ul><h2 id="section-4">2021-03-19</h2><ul><li>加入「说说」页面，功能由<a href="https://www.heson10.com/posts/25624.html">黑石哔哔</a>提供（感谢大佬）</li></ul><h2 id="section-5">2021-03-13</h2><ul><li>将NexT版本升级到v8.2.2版本</li><li>修改主题样式，加入看板娘</li></ul><h2 id="section-6">2021-02-18</h2><ul><li>将Hexo版本升级到v5.3.0版本</li></ul><h2 id="section-7">2020-07-07</h2><ul><li>将本地博客站点迁移到Mac电脑中</li></ul><h2 id="section-8">2019-07-31</h2><ul><li>搭建Hexo博客（版本v3.9.0）并部署到GitHub Pages上，使用NexT v5.1.4主题并深度定制</li><li>将NexT主题升级到v7.3.0，重新定制</li></ul>]]></content>
      
      
      <categories>
          
          <category> 公告 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>eBPF C编程入门</title>
      <link href="posts/de8a1cd/"/>
      <url>posts/de8a1cd/</url>
      
        <content type="html"><![CDATA[<p>以下是B站中「Linux内核之旅」的直播「<a href="https://www.bilibili.com/video/BV1f54y1h74r">BPF C编程入门</a>」的笔记。省略了一些内容。</p><a id="more"></a><h2 id="环境配置">环境配置</h2><p>当前使用的系统环境：Ubuntu 18.04 64位</p><h3 id="下载并解压内核源码">下载并解压内核源码</h3><p>首先要查看系统的内核版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br><span class="line"><span class="comment"># 5.4.0-65-generic</span></span><br></pre></td></tr></table></figure><p>然后去<a href="http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel/">这里</a>下载对应版本的内核源码，对于上面输出的版本，那么可以从页面中进入 <code>v5.x/</code> 目录下载 <code>linux-5.4.tar.gz</code>，这是对应的<a href="http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel/v5.x/linux-5.4.tar.gz">链接</a>。</p><p>进入下载的目录，使用以下命令将下载好的内核源码解压到 <code>/usr/src/</code> 中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf linux-5.4.tar.gz -C /usr/src/</span><br></pre></td></tr></table></figure><h3 id="安装依赖项">安装依赖项</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install libncurses5-dev flex bison libelf-dev binutils-dev libssl-dev</span><br></pre></td></tr></table></figure><h3 id="安装-clang-llvm">安装 clang 、LLVM</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install clang llvm</span><br></pre></td></tr></table></figure><p>以下的步骤需要在刚刚下载好的内核源码的目录下执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/src/linux-5.4</span><br></pre></td></tr></table></figure><h3 id="配置内核">配置内核</h3><p>生成 <code>.config</code> 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make defconfig</span><br></pre></td></tr></table></figure><h3 id="修复modpost模块的报错">修复modpost模块的报错</h3><p>执行以下两个命令的其中之一，如果不做这一步，编译BPF程序样例的时候会出现 <code>modpost: not found</code> 的错误。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make modules_prepare <span class="comment"># 修复模块</span></span><br><span class="line">make scripts <span class="comment"># 补全脚本</span></span><br></pre></td></tr></table></figure><h3 id="关联内核头文件">关联内核头文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make headers_install</span><br></pre></td></tr></table></figure><h3 id="编译内核bpf程序样例">编译内核BPF程序样例</h3><p>内核源码有很多BPF程序样例，都在子目录 <code>samples/bpf/</code> 下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make M=samples/bpf/</span><br></pre></td></tr></table></figure><p>忽略输出的各种警告或者其他错误。</p><p>输出类似下图：</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210309154736147.png" alt="image-20210309154736147" style="zoom:50%;"></p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210309155153382.png" alt="image-20210309155153382" style="zoom:50%;"></p><h3 id="运行一个示例程序">运行一个示例程序</h3><p>必须在root权限下执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sockex1</span><br></pre></td></tr></table></figure><p>该程序可以统计不同类型报文数据量。</p><p>出现类似下面的结果则说明成功运行，环境搭建完成。</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210309155324665.png" alt="image-20210309155324665" style="zoom:50%;"></p><h2 id="编写hello-world程序并在内核源码树编译">编写hello world程序并在内核源码树编译</h2><p>注意，以下程序源文件需要从内核源码树中编译，因此均需放在文件夹 <code>samples/bpf/</code> 下。</p><h3 id="编写程序">编写程序</h3><p>首先新建 <code>hello_kern.c</code> 作为BPF程序，编写内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;uapi/linux/bpf/h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;bpf_helpers.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BPF程序类型为kprobe，跟踪的内核函数为sys_write</span></span><br><span class="line">SEC(<span class="string">&quot;kprobe/sys_write&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf_prog</span><span class="params">(<span class="keyword">void</span> *ctx)</span> <span class="comment">// BPF程序，函数名自定义</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> msg[] = <span class="string">&quot;hello world!\n&quot;</span>;</span><br><span class="line">    bpf_trace_printk(mas, <span class="keyword">sizeof</span>(msg)); <span class="comment">// 将字符串写入管道文件trace_pipe中的BPF辅助函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> _license <span class="title">SEC</span><span class="params">(<span class="string">&quot;license&quot;</span>)</span> </span>= <span class="string">&quot;GPL&quot;</span>; <span class="comment">// 声明GPL许可证</span></span><br></pre></td></tr></table></figure><p>该程序的功能为：当检测到内核函数 <code>sys_write()</code> 调用时，输出 <code>hello world!</code> 。</p><p>然后新建 <code>hello_user.c</code> 作为用户态的BPF程序加载器，编写内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;bpf_load.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 通过bpf()系统调用，将BPF程序的字节码加载进内核</span></span><br><span class="line">    <span class="keyword">if</span> (load_bpf_file(<span class="string">&quot;hello_kern.o&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    read_trace_pipe(); <span class="comment">// 读取trace_pipe的内容</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序的功能为：当检测到内核函数 <code>sys_write()</code> 调用时，输出 <code>hello world!</code> 。</p><p><code>SEC()</code>宏的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEC(NAME) __attribute__((section(NAME), used))</span></span><br></pre></td></tr></table></figure><p>参数<code>NAME</code>为节名称，该宏修饰一个变量或函数，则被修饰的变量或函数的内容将被编译到ELF文件中<code>NAME</code>名称对应的节中。</p><h3 id="修改makefile编译程序">修改Makefile，编译程序</h3><p>在 <code>Makefile</code> 文件增加以下内容，把刚刚编写的、需要编译的新程序加进来：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># List of programs to build</span></span><br><span class="line">hostprogs-y := hello</span><br><span class="line"></span><br><span class="line"><span class="comment"># Libbpf dependencies</span></span><br><span class="line">hello-objs := bpf_load.o hello_user.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># Tell kbuild to always build the programs</span></span><br><span class="line">always += hello_kern.o</span><br></pre></td></tr></table></figure><p>增加的位置：</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210309162309744.png" alt="image-20210309162309744" style="zoom:50%;"></p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210309162408830.png" alt="image-20210309162408830" style="zoom:50%;"></p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210309162509775.png" alt="image-20210309162509775" style="zoom:50%;"></p><p>然后返回到内核源码根目录，重新编译 <code>samples/bpf/</code> 中的程序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ../..</span><br><span class="line">make M=samples/bpf/</span><br></pre></td></tr></table></figure><p>会生成含有BPF程序字节码的目标文件（<code>hello_kern.o</code>，ELF格式）、用户态的BPF程序加载器目标文件（<code>hello_user.o</code>）、用户态的BPF程序加载器可执行文件（<code>hello</code>）。</p><p>在root权限下运行 <code>hello</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./hello</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210309162816482.png" alt="image-20210309162816482" style="zoom:50%;"></p><h2 id="使用工具分析包含bpf程序字节码的目标文件中的信息">使用工具分析包含BPF程序字节码的目标文件中的信息</h2><h3 id="使用readelf查看elf节头信息">使用readelf查看ELF节头信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -S hello_kern.o</span><br></pre></td></tr></table></figure><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210309202616421.png" alt="image-20210309202616421" style="zoom:50%;"></p><h3 id="使用objdump查看各个节中的内容">使用objdump查看各个节中的内容</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -s hello_kern.o</span><br></pre></td></tr></table></figure><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210309203432639.png" alt="image-20210309203432639" style="zoom:50%;"></p><h3 id="查看bpf字节码反汇编表示">查看BPF字节码反汇编表示</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llvm-objdump -d hello_kern.o</span><br></pre></td></tr></table></figure><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210309204528788.png" alt="image-20210309204528788" style="zoom:50%;"></p><p>第10条指令<code>call 6</code> 中的6是辅助函数<code>bpf_trace_printk()</code>的id。</p><figure><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210309214859176.png" alt><figcaption>image-20210309214859176</figcaption></figure><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210309214910218.png" alt="image-20210309214910218" style="zoom:50%;"></p><h2 id="bpftools的使用">bpftools的使用</h2><p>进入 <code>tools/bpf/bpftool</code>，首先编译生成bpftool可执行文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>现在将前面编译生成的 <code>hello</code> 程序一直运行，</p><p>查看正在运行的BPF程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bpftool prog show</span><br></pre></td></tr></table></figure><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210309211329234.png" alt="image-20210309211329234" style="zoom:50%;"></p><p>上面id为217的程序就是 <code>hello_kern</code> 程序。</p><p>查看 <code>hello_kern</code> 程序运行时的字节码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bpftool prog dump xlated id 217 opcodes</span><br></pre></td></tr></table></figure><figure><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210309212005752.png" alt><figcaption>image-20210309212005752</figcaption></figure><p>除了第10条指令有所不同外，其他都一样。</p><p>查看jit之后的BPF字节码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bpftool prog dump jited id 217 opcodes</span><br></pre></td></tr></table></figure><figure><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210309212417402.png" alt><figcaption>image-20210309212417402</figcaption></figure><p>经过jit之后BPF字节码已经被翻译成本地机器码。</p><h2 id="clangllvm">clang、LLVM</h2><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210309214940198.png" alt="image-20210309214940198" style="zoom:50%;"></p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210309215001201.png" alt="image-20210309215001201" style="zoom:50%;"></p><p>查看LLVM所有支持的后端：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llc --version</span><br></pre></td></tr></table></figure><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210309225058835.png" alt="image-20210309225058835" style="zoom:50%;"></p><p>将必要的宏从源码中提取出来，放在 <code>hello_kern.c</code> 的前面：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __BPF_FUNC_MAPPER(FN)\</span></span><br><span class="line">  FN(unspec),\</span><br><span class="line">  FN(map_lookup_elem),\</span><br><span class="line">  FN(map_update_elem),\</span><br><span class="line">  FN(map_delete_elem),\</span><br><span class="line">  FN(probe_read),\</span><br><span class="line">  FN(ktime_get_ns),\</span><br><span class="line">  FN(trace_printk),\</span><br><span class="line">  FN(get_prandom_u32),\</span><br><span class="line">  FN(get_smp_processor_id),\</span><br><span class="line">  FN(skb_store_bytes),\</span><br><span class="line">  FN(l3_csum_replace),\</span><br><span class="line">  FN(l4_csum_replace),\</span><br><span class="line">  FN(tail_call),\</span><br><span class="line">  FN(clone_redirect),\</span><br><span class="line">  FN(get_current_pid_tgid),\</span><br><span class="line">  FN(get_current_uid_gid),\</span><br><span class="line">  FN(get_current_comm),\</span><br><span class="line">  FN(get_cgroup_classid),\</span><br><span class="line">  FN(skb_vlan_push),\</span><br><span class="line">  FN(skb_vlan_pop),\</span><br><span class="line">  FN(skb_get_tunnel_key),\</span><br><span class="line">  FN(skb_set_tunnel_key),\</span><br><span class="line">  FN(perf_event_read),\</span><br><span class="line">  FN(redirect),\</span><br><span class="line">  FN(get_route_realm),\</span><br><span class="line">  FN(perf_event_output),\</span><br><span class="line">  FN(skb_load_bytes),\</span><br><span class="line">  FN(get_stackid),\</span><br><span class="line">  FN(csum_diff),\</span><br><span class="line">  FN(skb_get_tunnel_opt),\</span><br><span class="line">  FN(skb_set_tunnel_opt),\</span><br><span class="line">  FN(skb_change_proto),\</span><br><span class="line">  FN(skb_change_type),\</span><br><span class="line">  FN(skb_under_cgroup),\</span><br><span class="line">  FN(get_hash_recalc),\</span><br><span class="line">  FN(get_current_task),\</span><br><span class="line">  FN(probe_write_user),\</span><br><span class="line">  FN(current_task_under_cgroup),\</span><br><span class="line">  FN(skb_change_tail),\</span><br><span class="line">  FN(skb_pull_data),\</span><br><span class="line">  FN(csum_update),\</span><br><span class="line">  FN(set_hash_invalid),\</span><br><span class="line">  FN(get_numa_node_id),\</span><br><span class="line">  FN(skb_change_head),\</span><br><span class="line">  FN(xdp_adjust_head),\</span><br><span class="line">  FN(probe_read_str),\</span><br><span class="line">  FN(get_socket_cookie),\</span><br><span class="line">  FN(get_socket_uid),\</span><br><span class="line">  FN(set_hash),\</span><br><span class="line">  FN(setsockopt),\</span><br><span class="line">  FN(skb_adjust_room),\</span><br><span class="line">  FN(redirect_map),\</span><br><span class="line">  FN(sk_redirect_map),\</span><br><span class="line">  FN(sock_map_update),\</span><br><span class="line">  FN(xdp_adjust_meta),\</span><br><span class="line">  FN(perf_event_read_value),\</span><br><span class="line">  FN(perf_prog_read_value),\</span><br><span class="line">  FN(getsockopt),\</span><br><span class="line">  FN(override_return),\</span><br><span class="line">  FN(sock_ops_cb_flags_set),\</span><br><span class="line">  FN(msg_redirect_map),\</span><br><span class="line">  FN(msg_apply_bytes),\</span><br><span class="line">  FN(msg_cork_bytes),\</span><br><span class="line">  FN(msg_pull_data),\</span><br><span class="line">  FN(bind),\</span><br><span class="line">  FN(xdp_adjust_tail),\</span><br><span class="line">  FN(skb_get_xfrm_state),\</span><br><span class="line">  FN(get_stack),\</span><br><span class="line">  FN(skb_load_bytes_relative),\</span><br><span class="line">  FN(fib_lookup),\</span><br><span class="line">  FN(sock_hash_update),\</span><br><span class="line">  FN(msg_redirect_hash),\</span><br><span class="line">  FN(sk_redirect_hash),\</span><br><span class="line">  FN(lwt_push_encap),\</span><br><span class="line">  FN(lwt_seg6_store_bytes),\</span><br><span class="line">  FN(lwt_seg6_adjust_srh),\</span><br><span class="line">  FN(lwt_seg6_action),\</span><br><span class="line">  FN(rc_repeat),\</span><br><span class="line">  FN(rc_keydown),\</span><br><span class="line">  FN(skb_cgroup_id),\</span><br><span class="line">  FN(get_current_cgroup_id),\</span><br><span class="line">  FN(get_local_storage),\</span><br><span class="line">  FN(sk_select_reuseport),\</span><br><span class="line">  FN(skb_ancestor_cgroup_id),\</span><br><span class="line">  FN(sk_lookup_tcp),\</span><br><span class="line">  FN(sk_lookup_udp),\</span><br><span class="line">  FN(sk_release),\</span><br><span class="line">  FN(map_push_elem),\</span><br><span class="line">  FN(map_pop_elem),\</span><br><span class="line">  FN(map_peek_elem),\</span><br><span class="line">  FN(msg_push_data),\</span><br><span class="line">  FN(msg_pop_data),\</span><br><span class="line">  FN(rc_pointer_rel),\</span><br><span class="line">  FN(spin_lock),\</span><br><span class="line">  FN(spin_unlock),\</span><br><span class="line">  FN(sk_fullsock),\</span><br><span class="line">  FN(tcp_sock),\</span><br><span class="line">  FN(skb_ecn_set_ce),\</span><br><span class="line">  FN(get_listener_sock),\</span><br><span class="line">  FN(skc_lookup_tcp),\</span><br><span class="line">  FN(tcp_check_syncookie),\</span><br><span class="line">  FN(sysctl_get_name),\</span><br><span class="line">  FN(sysctl_get_current_value),\</span><br><span class="line">  FN(sysctl_get_new_value),\</span><br><span class="line">  FN(sysctl_set_new_value),\</span><br><span class="line">  FN(strtol),\</span><br><span class="line">  FN(strtoul),\</span><br><span class="line">  FN(sk_storage_get),\</span><br><span class="line">  FN(sk_storage_delete),\</span><br><span class="line">  FN(send_signal),\</span><br><span class="line">  FN(tcp_gen_syncookie),</span><br><span class="line"></span><br><span class="line"><span class="comment">/* integer value in &#x27;imm&#x27; field of BPF_CALL instruction selects which helper</span></span><br><span class="line"><span class="comment"> * function eBPF program intends to call</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __BPF_ENUM_FN(x) BPF_FUNC_ ## x</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">bpf_func_id</span> &#123;</span></span><br><span class="line">  __BPF_FUNC_MAPPER(__BPF_ENUM_FN)</span><br><span class="line">  __BPF_FUNC_MAX_ID,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> __BPF_ENUM_FN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEC(NAME) __attribute__((section(NAME), used))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">int</span> <span class="params">(*bpf_trace_printk)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, <span class="keyword">int</span> fmt_size, ...)</span> </span>= </span><br><span class="line">  (<span class="keyword">void</span> *) BPF_FUNC_trace_printk;</span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;kprobe/sys_write&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf_prog</span><span class="params">(<span class="keyword">void</span> *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;       </span><br><span class="line">        <span class="keyword">char</span> msg[] = <span class="string">&quot;hello world!\n&quot;</span>;</span><br><span class="line">        bpf_trace_printk(msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;       </span><br><span class="line"><span class="keyword">char</span> _license[] SEC(<span class="string">&quot;license&quot;</span>) = <span class="string">&quot;GPL&quot;</span>;</span><br></pre></td></tr></table></figure><p>这样可以使用clang直接编译生成BPF字节码（<code>-target bpf</code> 选项）。</p><p>一步完成编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -O2 -Wall -target bpf -c hello_kern.c -o hello_kern.o</span><br></pre></td></tr></table></figure><p>先使用clang前端编译生成LLVM IR（<code>.ll</code>）文件，再调用LLVM后端llc生成BPF字节码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clang -O2 -Wall -emit-llvm -S hello_kern.c</span><br><span class="line">llc hello_kern.ll -march=bpf -filetype=obj -o hello_kern.o</span><br></pre></td></tr></table></figure><p>LLVM IR是一种类似汇编语言的底层语言。</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210309224853232.png" alt="image-20210309224853232" style="zoom:50%;"></p><p>通过这种方式生成的包含BPF字节码的目标文件和通过内核源码树编译生成的一模一样。</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210309210033757.png" alt="image-20210309210033757" style="zoom:50%;"></p>]]></content>
      
      
      <categories>
          
          <category> eBPF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> eBPF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用vue-cli 3及以上版本创建Vue 2.x项目的方法</title>
      <link href="posts/eebb2f15/"/>
      <url>posts/eebb2f15/</url>
      
        <content type="html"><![CDATA[<p>最近刚学Vue，是从2.x版本开始的，以后有必要了再学3.x版本的（但是以后大概不会深究这个框架了，因为以后我要做后端）。然而vue-cli不同版本创建项目的方式有所不同，我最初都分不清，因此在这记录一下。</p><a id="more"></a><h2 id="操作步骤">操作步骤</h2><p>首先vue-cli 2.x版本和3及以上版本的安装方式不同：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install -g vue-cli <span class="comment"># 2.x版本</span></span><br><span class="line">npm install -g @vue/cli <span class="comment"># 3及以上版本</span></span><br><span class="line"><span class="comment"># 如果之前已安装vue-cli 2.x版本，升级到3及以上版本需要先卸载旧版本：</span></span><br><span class="line"><span class="comment"># npm uninstall -g vue-cli</span></span><br></pre></td></tr></table></figure><p>使用vue-cli 2.x版本通过以下命令创建的项目是Vue 2.x版本的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue init webpack xxx</span><br></pre></td></tr></table></figure><p>如果使用vue-cli 3及以上版本通过以下命令创建的项目是Vue 3.x版本的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create xxx</span><br></pre></td></tr></table></figure><p>如果使用了vue-cli 3及以上版本，但是仍然要创建Vue 2.x 版本的项目，需要先安装 <code>@vue/cli-init</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli-init</span><br></pre></td></tr></table></figure><p>然后创建Vue 2.x 版本的项目的方式和在vue-cli 2.x版本创建项目的方式是一样的。</p><p>在vue-cli 3及以上版本，第一次创建Vue 2.x 版本的项目之前（使用 <code>vue init</code> 命令），如果不安装 <code>@vue/cli-init</code> 会出现如下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Command vue init requires a global addon to be installed.</span><br><span class="line">Please run npm i -g @vue/cli-init and try again.</span><br></pre></td></tr></table></figure><h2 id="参考">参考</h2><ul><li><a href="https://cli.vuejs.org/zh/guide/creating-a-project.html#使用图形化界面">Vue官网</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> vue-cli </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在vue-cli项目定制Ant Design Vue主题的各种坑</title>
      <link href="posts/f449b2f7/"/>
      <url>posts/f449b2f7/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2><p>这段时间在学习用Vue（版本2.x）写一个简单的网页，然后将其重构成一个vue-cli项目。界面的UI使用了Ant Design Vue（版本1.x）。由于自己有严重的强迫症，不想让所有控件都使用默认的配色和样式，所以就尝试按照官网提供的方法重新定制主题。</p><a id="more"></a><p>创建Vue 2.x项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue init webpack xxx</span><br></pre></td></tr></table></figure><p>在项目中安装Ant Design Vue：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install ant-design-vue --save</span><br></pre></td></tr></table></figure><p>因为我想修改的不仅仅是主题中的变量，因此我选择了覆盖主题原有样式 <code>.less</code> 文件的方法。</p><p>首先在项目中安装 <code>less</code> 和 <code>less-loader</code>（这样默认安装最新版）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install less less-loader --save</span><br></pre></td></tr></table></figure><p>在 <code>xxx/src/</code> 文件夹中，创建 <code>style</code> 文件夹，在这个文件夹中新建两个 <code>.less</code> 文件，</p><p><code>xxx/src/style/index.less</code> 的内容：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;~ant-design-vue/dist/antd.less&#x27;</span>; <span class="comment">// 引用主题原来默认的.less文件</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;./theme.less&#x27;</span>; <span class="comment">// 覆盖默认主题的变量和样式</span></span><br></pre></td></tr></table></figure><p><code>xxx/src/style/theme.less</code> 的内容：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@primary-color:</span> <span class="number">#4499c2</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.@&#123;popover-prefix-cls&#125;</span> &#123;</span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-tag">-title</span> &#123;</span><br><span class="line">        <span class="attribute">padding</span>: <span class="number">15px</span> <span class="number">20px</span>;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-tag">-inner</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-tag">-inner-content</span> &#123;</span><br><span class="line">        <span class="attribute">padding</span>: <span class="number">20px</span> <span class="number">20px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.@&#123;card-prefix-cls&#125;</span> &#123;</span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-tag">-bordered</span> &#123;</span><br><span class="line">        <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#e8e8e8</span>;</span><br><span class="line">        <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>xxx/src/main.js</code> 中增加这些内容：</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210306012605946.png" alt="image-20210306012605946" style="zoom:50%;"></p><h2 id="解决方法">解决方法</h2><h3 id="module-build-failed-typeerror-this.getoptions-is-not-a-function">Module build failed: TypeError: this.getOptions is not a function</h3><p>修改主题之后定制项目出现如下的报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> error  <span class="keyword">in</span> ./src/style/index.less</span><br><span class="line"></span><br><span class="line">Module build failed: TypeError: this.getOptions is not a <span class="keyword">function</span></span><br><span class="line">    at Object.lessLoader (/Users/betty/vue/xxx/node_modules/less-loader/dist/index.js:21:24)</span><br><span class="line"></span><br><span class="line"> @ ./src/style/index.less 4:14-198 13:3-17:5 14:22-206</span><br><span class="line"> @ ./src/main.js</span><br><span class="line"> @ multi (webpack)-dev-server/client?http://localhost:8080 webpack/hot/dev-server ./src/main.js</span><br></pre></td></tr></table></figure><p><code>less-loader</code> 版本太高，需要降级（原来的版本可以在 <code>xxx/package.json</code> 中查看，忘截图了）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall less-loader</span><br><span class="line">npm install less-loader@5.0.0 --save</span><br></pre></td></tr></table></figure><h3 id="inline-javascript-is-not-enabled">Inline JavaScript is not enabled</h3><p>上一个问题解决了之后又报错了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> error  <span class="keyword">in</span> ./src/style/index.less</span><br><span class="line"></span><br><span class="line">Module build failed: </span><br><span class="line"></span><br><span class="line">// https://github.com/ant-design/ant-motion/issues/44</span><br><span class="line">.bezierEasingMixin();</span><br><span class="line">^</span><br><span class="line">Inline JavaScript is not enabled. Is it <span class="built_in">set</span> <span class="keyword">in</span> your options?</span><br><span class="line">      <span class="keyword">in</span> /Users/betty/vue/xxx/node_modules/ant-design-vue/lib/style/color/bezierEasing.less (line 110, column 0)</span><br><span class="line"></span><br><span class="line"> @ ./src/style/index.less 4:14-198 13:3-17:5 14:22-206</span><br><span class="line"> @ ./src/main.js</span><br><span class="line"> @ multi (webpack)-dev-server/client?http://localhost:8080 webpack/hot/dev-server ./src/main.js</span><br></pre></td></tr></table></figure><p>由于项目的Vue版本是2.x，故按照下图修改 <code>xxx/build/utils.js</code> ：</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210306011339784.png" alt="image-20210306011339784" style="zoom:50%;"></p><h3 id="operation-on-an-invalid-type">Operation on an invalid type</h3><p>上一个问题解决了之后又又又报错了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> error  <span class="keyword">in</span> ./src/style/index.less</span><br><span class="line"></span><br><span class="line">Module build failed: </span><br><span class="line"></span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 8px + @font-size-base * @line-height-base / 2 - @font-size-base / 2;</span><br><span class="line">  ^</span><br><span class="line">Operation on an invalid <span class="built_in">type</span></span><br><span class="line">      <span class="keyword">in</span> /Users/betty/vue/xxx/node_modules/ant-design-vue/lib/alert/style/index.less (line 29, column 4)</span><br><span class="line"></span><br><span class="line"> @ ./src/style/index.less 4:14-198 13:3-17:5 14:22-206</span><br><span class="line"> @ ./src/main.js</span><br><span class="line"> @ multi (webpack)-dev-server/client?http://localhost:8080 webpack/hot/dev-server ./src/main.js</span><br></pre></td></tr></table></figure><p>降低 <code>less</code> 版本到 4.0 以下成功解决：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall less</span><br><span class="line">npm install less@2.7.3 --save</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>为了避免上述问题，在vue-cli中的Vue 2.x项目中使用Antd定制主题的时候，安装 <code>less</code> 和 <code>less-loader</code> 的时候应该指定低版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install less@2.7.3 less-loader@5.0.0 --save</span><br></pre></td></tr></table></figure><h2 id="参考">参考</h2><ul><li><a href="https://blog.csdn.net/weixin_43438052/article/details/114140449">https://blog.csdn.net/weixin_43438052/article/details/114140449</a></li><li><a href="https://blog.csdn.net/weixin_45748897/article/details/103701003">https://blog.csdn.net/weixin_45748897/article/details/103701003</a></li><li><a href="https://github.com/vueComponent/ant-design-vue/issues/3665">https://github.com/vueComponent/ant-design-vue/issues/3665</a></li><li><a href="https://www.yuque.com/u2090330/gn7vz8/qpcdo6">https://www.yuque.com/u2090330/gn7vz8/qpcdo6</a></li><li><a href="https://1x.antdv.com/docs/vue/customize-theme-cn/">Antd官网定制主题方法（1.x版本）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> vue-cli </tag>
            
            <tag> 前端 </tag>
            
            <tag> Antd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 更新到 5.0 版本之后遇到的坑及解决</title>
      <link href="posts/4ceb5096/"/>
      <url>posts/4ceb5096/</url>
      
        <content type="html"><![CDATA[<p>我在 19 年下半年使用 Hexo 搭建了这个博客，使用了 NexT 主题。到现在 Hexo 版本一直停留在 3.9.0，现在版本已经都到 5.3.0 了；NexT 主题停留在 7.3.0 版本，现在都已经到 8.x 了。至于选择更新的动机，是因为我想升级一下博客的 UI （之前自己手动在 NexT 主题上搞了一个暗黑的 UI 配上 canvas next 动画之后的界面简直像虫子爬，现在觉得好丑），然后从 Butterfly 等比较现代的主题中学习一些升级的思路。然而，我把新版本 Butterfly 下载下来之后，准备启用它试试看，结果报了这个错：</p><a id="more"></a><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/Snipaste_2021-02-17_23-16-26.png" alt="1" style="zoom:50%;"></p><p>因为我的 Hexo 版本太低不支持。那就先更新 Hexo 试试看吧。</p><h2 id="更新步骤">更新步骤</h2><p>首先在自己的博客文件夹下打开终端。</p><p>首先输入 <code>hexo -v</code> 检查一下版本：</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210218003902347.png" alt="2" style="zoom:50%;"></p><p>然后输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install -g npm-check</span><br><span class="line">npm-check <span class="comment"># 检查安装的所有插件当中需要升级的插件</span></span><br><span class="line">npm install -g npm-upgrade</span><br><span class="line">npm-upgrade <span class="comment"># 更新 package.json</span></span><br><span class="line">npm update <span class="comment"># 更新所有插件及依赖</span></span><br></pre></td></tr></table></figure><p>出现了很多警告：</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210218004345647.png" alt="3" style="zoom:50%;"></p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210218004411360.png" alt="4" style="zoom:50%;"></p><p>deprecated可以忽略，然后又发现了这个：</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210218004453609.png" alt="5" style="zoom:50%;"></p><p>输入以下命令手动安装未成功安装的依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install chokidar@^3.3.0</span><br></pre></td></tr></table></figure><p>最后检查一下版本，可以看到升级成功了：</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210218004643537.png" alt="6" style="zoom:50%;"></p><h2 id="遇到的坑及解决">遇到的坑及解决</h2><p>注意上图的错误，我最初给忽略了（虽然不知道忽略了会带来什么问题）。</p><p>在同一个终端中，我先手贱输了命令 <code>hexo s --debug</code> ，结果通过浏览器打开 http://localhost:/4000 发现看不到正常页面了，只能看到没有被渲染的源代码：</p><figure><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210218004948348.png" alt><figcaption>7</figcaption></figure><p>先解决上面那个 <code>external_link</code> 的问题吧，在 Hexo 的 <code>_config.yml</code> 中搜索 <code>external_link</code> 属性发现的确是布尔值。按照提示打开<a href="https://hexo.io/zh-cn/docs/configuration.html">链接</a>，参考这里给出的默认值：</p><figure><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210218005827267.png" alt><figcaption>8</figcaption></figure><p>修改 Hexo 的 <code>_config.yml</code> 如下：</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210218005953747.png" alt="9" style="zoom:50%;"></p><p>重新输入命令 <code>hexo s --debug</code> 之后还是这样，<code>hexo clean</code> 也运行了，浏览器缓存也清了也没用。我打开别的页面也还是这样：</p><figure><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210218010921123.png" alt><figcaption>10</figcaption></figure><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210218011622499.png" alt="11">输入命令 <code>hexo g</code> 重新生成静态文件居然没报错。从上面两个图来看，应该就是页面渲染出问题了。我也没有改对应的 layout 文件。</p><p>然后我就尝试更换主题，从 NexT 更换到 Butterfly 也有同样的问题：</p><figure><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210218012914787.png" alt><figcaption>12</figcaption></figure><p>更换到默认主题 landscape 就没有问题。值得注意的是 landscape 使用的是 ejs 模版引擎（我安装了 <code>Hexo-renderer-ejs</code>），但是 NexT 使用的是 swig ，Butterfly 使用的是 pug。后两个主题我没有安装对应的 renderer（之前就没安装过但是也能用 NexT）。</p><p>我执行以下命令重新安装插件也不起作用，<code>package.json</code> 里面的 Hexo 版本也对得上，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rm -rf node_modules</span><br><span class="line">npm cache clean --force</span><br><span class="line">npm install <span class="comment"># 重新安装</span></span><br></pre></td></tr></table></figure><p>经过一番搜索，我终于找到了这个<a href="https://github.com/next-theme/hexo-theme-next/issues/4">链接</a>，这是 NexT 官方写的 issue。这里写着：</p><figure><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210218020603184.png" alt><figcaption>13</figcaption></figure><p>可以知道 swig 缺乏维护，Hexo 从 5.0 版本开始不再提供对 swig 的支持，但是仍然可以安装 swig renderer。根据上图提示，输入如下命令安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-swig</span><br></pre></td></tr></table></figure><p>同理，Butterfly 主题无法渲染的问题可以这样解决：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug</span><br></pre></td></tr></table></figure><p>重新执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s --debug</span><br></pre></td></tr></table></figure><p>打开 http://localhost:4000 终于能看到页面而不是源代码了：</p><figure><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210218022534857.png" alt><figcaption>14</figcaption></figure><blockquote><p>上图参考了 BNDong 大佬的<a href="https://github.com/BNDong/Cnblogs-Theme-SimpleMemory">代码</a>自己瞎整了一个封面，由于我太菜了，现在改的不太好，如果有时间我单独写一篇博客描述这个。先感谢 BNDong 大佬！！！</p></blockquote><p>但是导航栏又不能正常显示了，在同一个 issue 中看到这里才知道这是 Hexo 高版本带来的图标无法正常显示的问题：</p><p><img id="15" data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210218021730351.png" alt="15" style="zoom:50%;"></p><p>所以为了升级 UI 我决定升级 NexT 到 8.x 吧。毕竟现在 NexT 也提供了对黑暗模式的支持。然而我又才知道 NexT 8.x 版本<strong>又又又换了个仓库</strong>（而且两次换仓库还都是因为上一个仓库的管理者放弃了维护），而且模版文件格式也改成了 <code>.njk</code>（和 <code>.swig</code> 语法类似），这就说明我必须得用新的代码升级主题了！！！</p><figure><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210218025850814.png" alt><figcaption>16</figcaption></figure><figure><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210218030101699.png" alt><figcaption>17</figcaption></figure><h2 id="总结">总结</h2><p>综上，</p><ul><li><p>如果使用了旧版本 NexT 主题并且 Hexo 升级到了 5.0 及以上版本，并且模版文件无法渲染（只能看到源代码），可以先在博客文件夹下尝试以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-swig</span><br></pre></td></tr></table></figure><p>Butterfly 主题出现同样的问题也可以尝试以下命令解决：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug</span><br></pre></td></tr></table></figure><p>再执行以下命令，再用浏览器打开 http://localhost:/4000 （浏览器先清缓存）应该就能看到页面了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s --debug</span><br></pre></td></tr></table></figure><p>NexT 主题的其他兼容性问题（例如图标不能正常显示）只能通过升级 NexT 或者降级 Hexo 解决，参考官方 <a href="https://github.com/next-theme/hexo-theme-next/issues/4">issue</a> 和<a href="#15">图15</a>。<del>如果你是大佬也可以徒手修改旧版 NexT 主题在新版 Hexo 中出问题的地方。</del></p></li><li><p>NexT 主题实在太难用了，绝大多数自定义教程都过时了，换主题吧。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> NexT </tag>
            
            <tag> npm </tag>
            
            <tag> Butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Wireshark抓包分析TCP协议</title>
      <link href="posts/7ce21a5/"/>
      <url>posts/7ce21a5/</url>
      
        <content type="html"><![CDATA[<p>我来炒冷饭了……这个Wireshark分析案例其实是我以前的作业。内容是从浏览器通过HTTP协议（注意，是HTTP不是HTTPS）访问某个网页，并分析TCP连接的全过程（包括三个阶段：连接的建立、数据传输、连接的关闭）。</p><p>由于当时作业的重点是对TCP协议的分析，再加上我当时对应用层协议的学习也不够重视。所以我主要在传输层的层面上进行了分析，并没有对应用层协议（HTTP）进行分析。后来才发现大厂的面试经常会考HTTP/HTTPS协议，为了能够复习TCP协议和HTTP协议（也怕我今后找不到这个作业了），所以就把它贴到博客上了。如果以后有空的话我再简单分析这里面的HTTP报文（或者是其他应用层协议，例如DNS）吧。</p><p>分析的流程可能有不少问题，如果读者发现了什么问题请及时指正。</p><a id="more"></a><hr><h2 id="实验环境">实验环境</h2><ol type="1"><li>Windows 10 64位专业版</li><li>Wireshark Version 2.4.1</li><li>Google Chrome</li></ol><h2 id="抓包前准备">抓包前准备</h2><p>这里就以最常用的百度为例进行分析。</p><p>先打开cmd，输入命令<code>ping</code>查询域名<code>www.baidu.com</code>对应的IP地址。</p><p><img data-src="/posts/7ce21a5/2.PNG" width="50%" height="50%"></p><p>由此得知<code>www.baidu.com</code>的IP地址为<code>39.156.66.18</code>。</p><p id="div-border-left-red">注意：在这里DNS解析出来的IP地址是不唯一的。大网站访问的用户很多，单个服务器无法负担如此高的访问流量，为了做到DNS负载均衡，通常都是一个域名对应多个内部服务器IP地址的。</p><h2 id="开始抓包">开始抓包</h2><p>打开Wireshark，选中图中的网卡<code>WLAN</code>，并双击打开它，这就开始了捕获流经网卡<code>WLAN</code>的数据包。</p><p><img data-src="/posts/7ce21a5/1.PNG" width="50%" height="50%"></p><p>然后打开Google Chrome，输入URL：<code>http://39.156.66.18</code>。由此也可进入百度首页。</p><p><img data-src="/posts/7ce21a5/3.PNG" width="50%" height="50%"></p><figure><img data-src="/posts/7ce21a5/4.PNG" alt><figcaption>4</figcaption></figure><p>过一段时间后（以确保TCP连接已经正常被关闭），在Wireshark停止捕获数据包，并在本地保存文件为<code>baidu.pcapng</code>。下载<a href="https://pan.baidu.com/s/143gFBlBf090yqTX5kFWZ2Q">链接</a>在此，提取码为 he6e。</p><h2 id="对tcp连接过程的分析">对TCP连接过程的分析</h2><p>在Wireshark中打开文件<code>baidu.pcapng</code>。并输入过滤器：<code>tcp and ip.addr==39.156.66.18 and tcp.port==8031</code>。以下是本次TCP连接的所有数据包（共78条记录）：</p><figure><img data-src="/posts/7ce21a5/29.PNG" alt><figcaption>29</figcaption></figure><figure><img data-src="/posts/7ce21a5/30.PNG" alt><figcaption>30</figcaption></figure><figure><img data-src="/posts/7ce21a5/31.PNG" alt><figcaption>31</figcaption></figure><h3 id="tcp连接建立">TCP连接建立</h3><p>下图中的前三个数据包（标号为12、14、15）表示TCP建立连接的过程（三次握手）。</p><figure><img data-src="/posts/7ce21a5/5.PNG" alt><figcaption>5</figcaption></figure><h4 id="第一次握手">第一次握手</h4><p><strong>第一次握手</strong>（12），客户端（源IP<code>10.130.170.79</code>，源端口<code>8031</code>）向服务器端（目的IP<code>39.156.66.18</code>，目的端口<code>80</code>）发送建立连接的请求。此时序列号<code>Seq</code>为0，标志位<code>Syn</code>被置1，数据段长度为0。由于是客户端发起连接，期望服务器端发送的下一个序列号还不知道，所以<code>Ack</code>字段被置0。</p><figure><img data-src="/posts/7ce21a5/6.PNG" alt><figcaption>6</figcaption></figure><p>客户端还在选项字段中约定了一些值，共12 Byte。例如MSS（最大报文段长度）为1460 Byte，即客户端的一次接收的报文段的数据长度最多为1460 Byte；窗口放大因子为8，表明在之后客户端发送的数据包的实际通告窗口大小为<code>Wnd</code>字段的值左移8位（2<sup>8</sup> = 256），当然在<code>Syn</code>为1的报文段是不乘以这个因子的；<code>SACK permitted</code>为允许选择重传；NOP选项为填充的0字节，以凑够TCP首部为4的倍数。由于选项字段为12 Byte，TCP首部的基础长度为20 Byte，因此这个数据包总的TCP首部长度为32 Byte。</p><figure><img data-src="/posts/7ce21a5/13.PNG" alt><figcaption>13</figcaption></figure><h4 id="第二次握手">第二次握手</h4><p><strong>第二次握手</strong>（14），服务器同意建立连接，向客户端发回连接确认。服务器端的序列号<code>Seq</code>也为0，标志位<code>Syn</code>和<code>Ack</code>被置1，数据段长度也为0。此时，服务器端期望收到的序列号<code>Ack</code>为1，虽然客户端建立连接的请求并不携带任何数据，但是<code>Syn</code>为1的报文段是一个特殊的报文段，也需要消耗一个序列号，因此期望的序列号为上一个报文段的<code>Seq+1</code>。</p><figure><img data-src="/posts/7ce21a5/7.PNG" alt><figcaption>7</figcaption></figure><p>服务器端也在选项中约定了一些值，共12 Byte。MSS（最大报文段长度）为1452 Byte，即服务器端的一次接收的报文段的数据长度最多为1452 Byte；窗口放大因子为5，表明在之后服务器端发送的数据包的实际通告窗口大小为<code>Wnd</code>字段的值左移5位（2<sup>5</sup> = 32），当然在<code>Syn</code>为1的报文段是不乘以这个因子的；也允许选择重传。由于选项字段为12 Byte，TCP首部的基础长度为20 Byte，因此这个数据包总的TCP首部长度为32 Byte。</p><figure><img data-src="/posts/7ce21a5/14.PNG" alt><figcaption>14</figcaption></figure><p>由于这些选项只在标志位<code>Syn</code>为1的时候才有，因此客户端或服务器端之后发送的数据包大部分都没有选项字段（除了选择重传选项以外），因此这些首部的长度都为20 Byte。选项部分的空字节是穿插在中间的，并非紧接在所有选项之后数据段之前，是为了字节对齐，让不空的选项从4 Byte的整数倍开始。如下图所示：（注意下图的数据是大端对齐）</p><p><img data-src="/posts/7ce21a5/38.PNG" width="50%" height="50%"></p><h4 id="第三次握手">第三次握手</h4><p><strong>第三次握手</strong>（15），客户端收到连接确认以后，还要向服务器端确认。此时序列号<code>Seq</code>变为1，标志位<code>Syn</code>被置0，<code>Ack</code>被置1，数据段长度也为0。此时，客户端期望收到的序列号<code>Ack</code>为1，虽然服务器端的连接确认也并不携带任何数据，但是这也是一个特殊的报文段，也需要消耗一个序列号，因此期望的序列号也为上一个报文段的<code>Seq+1</code>。</p><figure><img data-src="/posts/7ce21a5/8.PNG" alt><figcaption>8</figcaption></figure><p>至此，一个TCP连接成功建立，接下来就可以传输数据了。</p><p>事实上，在TCP中的连接建立请求中客户端会随机选择一个序列号，在连接确认时服务器端也会随机选择一个序列号。但是在Wireshark 中看到的起始序列号都为0。查阅资料发现，为了方便分析，Wireshark在序列号上默认采用相对值，后面的<code>seq</code>和<code>Ack</code>都在这个0值的基础上累加，而不是绝对序列号。也可以在首选项中设置为采用绝对序列号。</p><p><img data-src="/posts/7ce21a5/9.PNG" width="50%" height="50%"></p><h3 id="数据传输过程">数据传输过程</h3><p>首先（16），客户端向服务器端发送一个HTTP（版本1.1）的GET请求，这个是来自应用层的数据段，长度为434 Byte。由此可见HTTP的确是使用TCP建立连接的。此时序列号<code>Seq</code>仍为1，标志位<code>Ack</code>仍为1，<code>Psh</code>被置1，数据段长度为434。此时，客户端期望收到的序列号<code>Ack</code>仍为1（因为服务器端还没回应）。<code>Psh</code>被置1表示发送方希望接收方把数据立即上交给上层应用进程，而不是等到缓存填满。由于TCP中连接建立后所发送的报文段标志位<code>Ack</code>都会置1，因此在后续分析中，关闭连接前就不再提及标志位<code>Ack</code>了。<code>Seq</code>仍为1的原因是在第三次握手的时候，客户端的<code>Seq</code>为1，没有携带数据，而第三次握手的报文段只有标志位<code>Ack</code>为1，是普通报文段，是可以携带数据的，若不携带数据则不消耗序列号。</p><figure><img data-src="/posts/7ce21a5/10.PNG" alt><figcaption>10</figcaption></figure><p>之后（19），服务器端对客户端的上个报文段进行确认。序列号<code>Seq</code>为1，标志位<code>Ack</code>仍为1，数据段长度为0。期望收到的序列号<code>Ack</code>为435，是上一个客户端的报文段的<code>len+Seq</code>。之后在正常情况下，一方发送的报文段数据长度为<code>len</code>；下次对方发来的报文段中<code>Ack</code>的值为上次这一方发送的报文段数据长度<code>len+Seq</code>，<code>Seq</code>值为上次这一方发送的报文段的<code>Ack</code>字段值，因此后续分析中的正常情况也不详细说明了。在Wireshark中，正常的TCP报文段以绿色标记，异常的（丢失、乱序等）以黑色标记。</p><figure><img data-src="/posts/7ce21a5/11.PNG" alt><figcaption>10</figcaption></figure><p>第20个数据包，服务器端继续发送报文段，序列号<code>Seq</code>仍为1（因为19号数据包的报文段数据长度为0，不消耗序列号），<code>Ack</code>仍为435（因为客户端还没有确认），数据段长度为1460。</p><figure><img data-src="/posts/7ce21a5/12.PNG" alt><figcaption>11</figcaption></figure><p>第21个数据包，服务器端也继续发送报文段。序列号<code>Seq</code>为15349，不等于上一个数据包的<code>Seq+len</code>。<code>Ack</code>仍为435（因为客户端还没有确认），数据段长度为1460。Wireshark将这个数据包用黑色作标记，标记是<code>TCP Previous segment not captured</code>，表示[上一个报文段的<code>Seq+len</code>, 这个报文段的<code>Seq</code>)的报文段没有在这个数据包捕获之前被捕获，由此认为这些报文段可能是丢失了或者是出现了长延时。</p><figure><img data-src="/posts/7ce21a5/15.PNG" alt><figcaption>15</figcaption></figure><p>第22个来自服务器端的数据包同理，<code>Seq</code>为17723，<code>Ack</code>为435，数据段长度为2。下面主要对异常情况作解释，因此会分析的简略一些。</p><p>第23个数据包，是客户端发来的确认。<code>Seq</code>是435，<code>Ack</code>是1461，数据段长度为0。也就是说来自服务器端的<code>Seq</code>为1461及之后的报文段没有收到。并且首部长度变为32 Byte，因为多了选择确认的选项。第24个数据包的内容除了首部选择确认的选项以外和这个一样，Wireshark将其标记为第一个重复ACK<code>TCP Dup ACK 23#1</code>。</p><figure><img data-src="/posts/7ce21a5/16.PNG" alt><figcaption>16</figcaption></figure><p>23和24号数据包的选项部分为选择重传，左边界(left edge)和右边界(right edge)表示已经正确接收的字节序列号。即21号和22号数据包已被正确接收。下图为24号数据包的选项，共20 Byte。在服务器端<code>Seq</code>为[1461,15349)，[16809,17723)，17725及之后的报文段没有收到。</p><p><img data-src="/posts/7ce21a5/18.PNG" width="50%" height="50%"></p><p>以下是25号到50号数据包的截图：</p><figure><img data-src="/posts/7ce21a5/34.PNG" alt><figcaption>34</figcaption></figure><p>25、26、27号数据包均来自服务器端。25号数据包的<code>Seq</code>为9509，26号数据包的<code>Seq</code>为1461，27号数据包的<code>Seq</code>为2921。25和26号数据包的数据段长度为1460，27号数据包数据段长度为1176。在Wireshark中，如果序列号大的数据包先被捕获，则被标记为乱序<code>TCP Out-Of-Order</code>。</p><p>28号数据包是23号数据包的第二个副本。选项部分已指示服务器端的<code>Seq</code>为9509的报文段已成功收到。在<code>Seq</code>为[1461,9509)，[10969,15349)，[16809,17723)，17725及之后的没有收到。</p><p><img data-src="/posts/7ce21a5/19.PNG" width="50%" height="50%"></p><p>29号、30号数据包均来自客户端，<code>Seq</code>均为435，数据段长度均为0。29号数据包的<code>Ack</code>为2921，30号数据包的<code>Ack</code>为4097。说明服务器端<code>Seq</code>为2921的报文段已被正确接收。由30号的选择确认选项可知，<code>Seq</code>为[4097,9509)的报文段还没收到。</p><p><img data-src="/posts/7ce21a5/20.PNG" width="50%" height="50%"></p><p>31号到35号，客户端没有发送<code>Ack</code>为6873的报文段，但是发送了<code>Ack</code>为8333的报文段，由于TCP是累积确认的，因此服务器端<code>Seq</code>为8333之前的报文段均已正确接收。由于服务器端前面出现过乱序标记，前面已接收的序列号仍然有空洞，仍然是乱序，因此31、32、33即使不乱序也被标记为乱序。</p><p>注意，36、37号数据包中没有出现来自服务器端的<code>Seq</code>为9509的报文段，因为早已被正确接收。</p><p>38号到43号的分析略。</p><p>44、45号是来自服务器端的HTTP响应，继续传输网页，都很正常。没有乱序标记的原因是<code>Seq</code>为17723之前的包都已经按序接收了（没有空洞了），后面的数据包也是按序的。<code>Seq</code>分别为：17725、19185，数据段长度均为1460。</p><p>46号的<code>Seq</code>为21821。46到49号表示服务器端的<code>Seq</code>为[20845,21821)的报文段没有收到，可能出现了丢失或长延时。50号表明这个报文段出现了长延时，因此乱序。50号数据包收到以后，前面的报文段已经按序，51到64号数据包也是按序接收的，因此51到64号数据包没有乱序标记。</p><p>以下是51号64号数据包的截图：</p><figure><img data-src="/posts/7ce21a5/35.PNG" alt><figcaption>35</figcaption></figure><p>51号到64号都很正常。不再过多分析。其中64号数据包的<code>Seq</code>为435，<code>Ack</code>为34678，数据段长度为0，首部长度 20 Byte。</p><p>以下是65号到86号数据包的截图：</p><figure><img data-src="/posts/7ce21a5/36.PNG" alt><figcaption>36</figcaption></figure><p>65到67号数据包被标记为<code>TCP Spurious Retransmission</code>（伪重传），表明这三个包是服务器端重传的，<code>Seq</code>分别为：1461、2921、4097。这是不必要的重传。由上述的记录可知，这三个报文段并没有丢失，只是时延比较长，导致了失序，被判定为丢失。</p><p>68、68、70号数据包是64号的三个副本。下图分别是这三个包的选择确认选项。指示服务器端这三个报文段早已被正确接收，不要再重传了。</p><p><img data-src="/posts/7ce21a5/23.PNG" width="50%" height="50%"></p><p><img data-src="/posts/7ce21a5/22.PNG" width="50%" height="50%"></p><p><img data-src="/posts/7ce21a5/21.PNG" width="50%" height="50%"></p><p>71号到79号数据包同理。在这里服务器端重传报文段的<code>Seq</code>分别是：5413、6873、8333、10969、12429、13889。由这些数据包可以看出，这些被重传报文段的序列号并没有在前面客户端的<code>Ack</code>的选择确认选项中指明收到了（虽然出现过了相应的<code>Ack</code>）。</p><p>80到84号，服务器端继续进行网页传输。80号数据包的<code>Seq</code>是34678，没有任何异常标记。因为服务器端还没有发送这个报文段，因此没有快速重传<code>TCP Fast Retransmission</code>的标记。尽管来自客户端的<code>Ack</code>34678的报文段已经重复了很多次。后面81~84号的<code>Seq</code>分别为：36138、37598、39058、40518。</p><p>85号数据包是客户端对78、79号数据包的回应。选择确认选项如下：</p><p><img data-src="/posts/7ce21a5/37.PNG" width="50%" height="50%"></p><p>86号数据包来自客户端，<code>Ack</code>为41963，表明在此之前的报文段均已正确接收。此时网页应该已经传完了。所以在485号数据包之前这个TCP连接一直没有数据的传输。</p><p>485号数据包，客户端向服务器端发送一个Keep-Alive数据包，以确认在长时间无数据交互时对方的状态是否还正常。<code>Seq</code>值被减1，数据部分只有一个0字节；<code>Ack</code>值没变。</p><figure><img data-src="/posts/7ce21a5/32.PNG" alt><figcaption>32</figcaption></figure><p>486号数据包，服务器端对这个Keep-Alive数据包作确认回应，表明自己的状态正常。<code>Seq</code>是41963，是上次这个Keep-Alive数据包的<code>Ack</code>值，<code>Seq</code>是435，是上次这个Keep-Alive数据包的<code>Ack</code>值+1，数据段长度为0。之后在1135号数据包之前这个TCP连接一直没有数据的传输。</p><figure><img data-src="/posts/7ce21a5/33.PNG" alt><figcaption>33</figcaption></figure><p>在建立连接的时候，客户端通告自己的MSS为1460。而一个网页的容量远大于1460 Byte。因此网页的HTTP报文在传输层被分成了很多个报文段。在网页传输的过程中，双方的通告窗口总是足够，没有出现窗口满了的情况。</p><h3 id="tcp连接关闭">TCP连接关闭</h3><p>下图中的最后四个数据包（标号为1135、1136、1137、1139）表示TCP释放连接的过程（四次挥手）。由于长时间没有数据传输并且双方状态正常，服务器端选择关闭这个连接并释放资源，以节省资源为其他客户端传输网页。</p><figure><img data-src="/posts/7ce21a5/24.PNG" alt><figcaption>24</figcaption></figure><h4 id="第一次挥手">第一次挥手</h4><p><strong>第一次挥手</strong>（1135），服务器端发送连接释放的报文段，请求关闭服务器端到客户端的连接。此时序列号<code>Seq</code>为41963，<code>Ack</code>为435。标志位<code>Fin</code>和<code>Ack</code>都被置1，数据段长度为0。</p><figure><img data-src="/posts/7ce21a5/25.PNG" alt><figcaption>25</figcaption></figure><h4 id="第二次挥手">第二次挥手</h4><p><strong>第二次挥手</strong>（1136），客户端向服务器端对连接释放报文段进行确认。此时序列号<code>Seq</code>为435，<code>Ack</code>为41964（须注意，<code>Fin</code>被置为1的报文段也是一个特殊的报文段，不携带数据也需要消耗一个序列号，因此期望的序列号为上一格连接释放请求的<code>Seq+1</code>。）。标志位只有<code>Ack</code>被置1，数据段长度为0。此时服务器端到客户端的连接被释放，但是客户端到服务器端的连接没有被释放。</p><figure><img data-src="/posts/7ce21a5/26.PNG" alt><figcaption>26</figcaption></figure><h4 id="第三次挥手">第三次挥手</h4><p><strong>第三次挥手</strong>（1137），由于服务器端到客户端的连接已经被释放，并且客户端也没有要发送的数据，因此客户端请求关闭客户端到服务器端的连接。此时<code>Seq</code>为435，<code>Ack</code>为41964，标志位<code>Fin</code>和<code>Ack</code>都被置1，数据段长度为0。因为上一次挥手发送的报文段只是一个普通的报文段（只有标志位<code>Ack</code>为1），因此没有数据的时候不消耗序列号，因此<code>Seq</code>是435。</p><figure><img data-src="/posts/7ce21a5/27.PNG" alt><figcaption>27</figcaption></figure><h4 id="第四次挥手">第四次挥手</h4><p><strong>第四次挥手</strong>（1139），服务器端对客户端的连接释放报文段进行确认。此时序列号<code>Seq</code>为41964，<code>Ack</code>为436（<code>Fin</code>不携带数据也需要消耗一个序列号），标志位只有<code>Ack</code>被置1，数据段长度为0。如果客户端收到这个<code>Ack</code>，则客户端立即进入关闭状态，此时服务器端要等待两倍段生存期的时间才能真正进入关闭状态，因为<code>Ack</code>可能丢失并需要重传。</p><figure><img data-src="/posts/7ce21a5/28.PNG" alt><figcaption>28</figcaption></figure><p>至此，对这次TCP连接的分析结束。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> Wireshark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Wireshark </tag>
            
            <tag> TCP </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】75. 颜色分类</title>
      <link href="posts/6bcee09b/"/>
      <url>posts/6bcee09b/</url>
      
        <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/sort-colors/">https://leetcode-cn.com/problems/sort-colors/</a></p><a id="more"></a><h2 id="三次遍历">三次遍历</h2><p>看到题干的第一反应……我这个渣渣大概只能想到这个办法了，有点类似计数排序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> red = <span class="number">0</span>, white = <span class="number">0</span>, blue = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>)</span><br><span class="line">                red++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == <span class="number">1</span>)</span><br><span class="line">                white++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == <span class="number">2</span>)</span><br><span class="line">                blue++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; red; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; red + white; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; red + white + blue; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[i] = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="两次遍历">两次遍历</h2><p>参考官方题解，引入交换可以减少遍历的次数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="comment">// 先把0交换到正确的位置</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(nums[i], nums[j]);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从0之后的位置开始遍历，将1交换到正确的位置</span></span><br><span class="line">        <span class="keyword">for</span> (i = j; i &lt; size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(nums[i], nums[j]);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="一次遍历">一次遍历</h2><p>官方题解给了两个模版，说是使用了双指针，但是我看不懂官方题解的描述，真的是看代码才勉强知道什么意思的。</p><p>将0和1交换到正确的位置：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p0 = <span class="number">0</span>, p1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(nums[i], nums[p0]);</span><br><span class="line">                <span class="comment">// 如果p0 &lt; p1，上一步的交换势必会把原先位置p0上的1交换到位置i</span></span><br><span class="line">                <span class="comment">// 所以要将位置i的1交换到位置p1所指的位置上</span></span><br><span class="line">                <span class="comment">// 0和1都交换了，p0和p1都要+1</span></span><br><span class="line">                <span class="comment">// 否则说明目前还没有1被交换，但是第一个1也要交换到正确的位置，所以p1还是要+1</span></span><br><span class="line">                <span class="keyword">if</span> (p0 &lt; p1)</span><br><span class="line">                    swap(nums[i], nums[p1]);</span><br><span class="line">                p0++;</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(nums[i], nums[p1]);</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>将0和2交换到正确的位置：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="keyword">int</span> p0 = <span class="number">0</span>, p2 = size - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// p2+1及之后的数字肯定是2，所以当i&gt;p2的时候就可以退出主循环</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= p2; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 首先把2交换到正确的位置上</span></span><br><span class="line">            <span class="comment">// 但是，交换了一次有可能位置i上还是2</span></span><br><span class="line">            <span class="comment">// 这表明交换前位置p2上的数字就是2，位置i上的2也需要交换到p2的前一个位置上</span></span><br><span class="line">            <span class="comment">// 所以p2-1之后还要循环和位置p2上的数字交换，直到位置i上不是2为止</span></span><br><span class="line">            <span class="comment">// 否则位置i上的这个2永远不会被交换到正确的位置上</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt;= p2 &amp;&amp; nums[i] == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(nums[i], nums[p2]);</span><br><span class="line">                p2--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 退出上面的循环之后，如果位置i上是0，需要交换到正确的位置</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(nums[i], nums[p0]);</span><br><span class="line">                p0++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面两个模版我是真看不懂怎么想出来的，直到看到官方题解下面的一个题解，才知道可以借助快速排序的 partition，毕竟这道题的本质也是排序。所以有了以下的代码，上面（将0和2交换到正确的位置）的代码只要稍微重构一下就能得到下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="keyword">int</span> p0 = <span class="number">0</span>, p2 = size - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= p2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 整个nums数组的位置分成3部分：</span></span><br><span class="line">            <span class="comment">// [0, p0)里面的数字一定是0</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(nums[i], nums[p0]);</span><br><span class="line">                p0++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// [p0, i)里面的数字一定是1</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// (p2, size - 1]里面的数字一定是2</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(nums[i], nums[p2]);</span><br><span class="line">                p2--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// [i, p2]里面是什么数字未定义，如果i &gt; p2表示此区间为空</span></span><br><span class="line">            <span class="comment">// nums数组正好被分成了3部分，结束循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>我当时用了三次遍历很快就能做出来这个题（甚至直接调用排序的库函数都能做出来），还觉得这题这么简单肯定不会是中等难度的吧。但是如何减少遍历次数的思路，尤其是如何实现只遍历一次就能完成这道题的思路，真的很难想出来，这大概是这道题为什么是中等难度的原因吧。然而，我估计面试官要是考这道题肯定不会只考最简单的做法吧。</p><p>嗯，是时候复习一下快速排序了……</p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 快速排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python爬虫学习】BeautifulSoup中.text和.string的区别</title>
      <link href="posts/1b5d2414/"/>
      <url>posts/1b5d2414/</url>
      
        <content type="html"><![CDATA[<p>爬虫的时候解析网页经常需要提取标签中的文本部分，如果使用 BeautifulSoup 解析我经常是使用 <code>.text</code> ，但是也有用 <code>.string</code> 的，但是没想到这两者有很大区别。而且总是使用 <code>.text</code> 也为我带来了不少麻烦（由于它也会输出子标签的内容）。因此将两者的区别记录并总结。</p><a id="more"></a><h2 id="一些例子">一些例子</h2><h3 id="情形一">情形一</h3><p>对于以下情形：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">html = <span class="string">&#x27;&lt;p&gt;aaa&lt;/p&gt;&#x27;</span></span><br><span class="line">soup = BeautifulSoup(html, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">print(soup.p.text)</span><br><span class="line">print(soup.p.string)</span><br><span class="line">print(<span class="built_in">type</span>(soup.p.text))</span><br><span class="line">print(<span class="built_in">type</span>(soup.p.string))</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aaa</span><br><span class="line">aaa</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">str</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> &#x27;<span class="title">bs4</span>.<span class="title">element</span>.<span class="title">NavigableString</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure><p>可以看出 <code>.text</code> 和 <code>.string</code> 的第一个区别是，如果标签内只有一个文本段，但是前者的类型为 <code>str</code> ，后者的类型为 <code>NavigableString</code>。</p><h3 id="情形二">情形二</h3><p>考虑以下复杂一点的情形：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">html = <span class="string">&quot;&quot;&quot;&lt;div&gt;aaa</span></span><br><span class="line"><span class="string">&lt;p&gt;</span></span><br><span class="line"><span class="string">    bbb</span></span><br><span class="line"><span class="string">    ccc</span></span><br><span class="line"><span class="string">    &lt;a&gt;ddd&lt;/a&gt;</span></span><br><span class="line"><span class="string">&lt;/p&gt;eee&lt;b&gt;fff&lt;/b&gt; &lt;/div&gt;&quot;&quot;&quot;</span></span><br><span class="line">soup = BeautifulSoup(html, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">print(soup.div.text)</span><br><span class="line">print(<span class="string">&#x27;-&#x27;</span> * <span class="number">10</span>)</span><br><span class="line">print(soup.div.string)</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">aaa</span><br><span class="line"></span><br><span class="line">    bbb</span><br><span class="line">    ccc</span><br><span class="line">    ddd</span><br><span class="line">eeefff </span><br><span class="line">----------</span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="情形三">情形三</h3><p>对于以下的情形：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">html = <span class="string">&#x27;&lt;p&gt;&lt;b&gt;aaa&lt;/b&gt;&lt;/p&gt;&#x27;</span></span><br><span class="line">soup = BeautifulSoup(html, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">print(soup.p.text)</span><br><span class="line">print(soup.p.string)</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aaa</span><br><span class="line">aaa</span><br></pre></td></tr></table></figure><p>但是改成这样，输出就变成了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">html = <span class="string">&#x27;&#x27;&#x27;&lt;p&gt;</span></span><br><span class="line"><span class="string">&lt;b&gt;aaa&lt;/b&gt; &lt;/p&gt;&#x27;&#x27;&#x27;</span></span><br><span class="line">soup = BeautifulSoup(html, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">print(soup.p.text)</span><br><span class="line">print(soup.p.string)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">aaa</span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure><p>这两个例子的区别仅仅只是是否在 <code>&lt;p&gt;</code> 标签内换行而已，但是输出结果就完全不一样了。这是为什么呢？</p><p>BeautifulSoup 还提供了 <code>.strings</code> 属性。如果对一个标签调用 <code>.strings</code> 会返回一个生成器，如果遍历这个生成器可以获取该标签内所有文本。</p><p>对于上述在 <code>&lt;p&gt;</code> 标签内没换行的例子，以下语句及对应的输出如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(soup.p.strings)</span><br><span class="line">print(<span class="built_in">list</span>(soup.p.strings))</span><br><span class="line">print(<span class="built_in">type</span>(<span class="built_in">list</span>(soup.p.strings)[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;generator <span class="built_in">object</span> Tag._all_strings at <span class="number">0x10dbf0750</span>&gt;</span><br><span class="line">[<span class="string">&#x27;aaa&#x27;</span>]</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">bs4</span>.<span class="title">element</span>.<span class="title">NavigableString</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure><p>可以看出此时 <code>&lt;p&gt;</code> 标签中只有一段文本，如果遍历 <code>.strings</code> 生成器得到的字符串的类型也是 <code>NavigableString</code>。</p><p>但是在 <code>&lt;p&gt;</code> 标签换行的话，以下语句及对应的输出如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="built_in">list</span>(soup.p.strings))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;aaa&#x27;</span>, <span class="string">&#x27; &#x27;</span>]</span><br></pre></td></tr></table></figure><p>可以看出此时 <code>&lt;p&gt;</code> 标签中有 3 段文本。</p><p>对于一个标签的开始和关闭标签之间的区域，只要在标签之间（可以是同一个标签的开始和关闭标签之间，也可以是该标签的开始标签和子标签的开始标签，也可以是子标签的关闭标签和该标签的关闭标签之间，也可以是子标签的关闭标签另一个子标签的开始标签之间）出现了字符（包括换行等空白符），这一部分就算是该标签内的一段文本，在情形二当中就更容易看出来了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">html = <span class="string">&quot;&quot;&quot;&lt;div&gt;aaa</span></span><br><span class="line"><span class="string">&lt;p&gt;</span></span><br><span class="line"><span class="string">    bbb</span></span><br><span class="line"><span class="string">    ccc</span></span><br><span class="line"><span class="string">    &lt;a&gt;ddd&lt;/a&gt;</span></span><br><span class="line"><span class="string">&lt;/p&gt;eee&lt;b&gt;fff&lt;/b&gt; &lt;/div&gt;&quot;&quot;&quot;</span></span><br><span class="line">soup = BeautifulSoup(html, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">print(<span class="built_in">list</span>(soup.div.strings))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;aaa\n&#x27;</span>, <span class="string">&#x27;\n    bbb\n    ccc\n    &#x27;</span>, <span class="string">&#x27;ddd&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;eee&#x27;</span>, <span class="string">&#x27;fff&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>]</span><br></pre></td></tr></table></figure><p>情形二和情形三表明 <code>.text</code> 和 <code>.string</code> 的第二个区别是，对于标签中含有多段文本的情形，前者会将这些文本按出现先后顺序拼接然后输出，后者只会输出 <code>None</code>；如果标签内只有一段文本后者才不会输出 <code>None</code>。</p><h3 id="情形四">情形四</h3><p>对于以下情形：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">html = <span class="string">&#x27;&lt;div&gt;&lt;/div&gt;&#x27;</span></span><br><span class="line">soup = BeautifulSoup(html, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">print(soup.div.text)</span><br><span class="line">print(soup.div.string)</span><br><span class="line">print(<span class="built_in">list</span>(soup.div.strings))</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="literal">None</span></span><br><span class="line">[]</span><br></pre></td></tr></table></figure><p>可以看出 <code>.text</code> 和 <code>.string</code> 的第三个区别是，如果标签内没有文本，前者输出空字符串，后者输出 <code>None</code> 。</p><h3 id="情形五">情形五</h3><p>考虑以下情形：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">html = <span class="string">&#x27;&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;&#x27;</span></span><br><span class="line">soup = BeautifulSoup(html, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">print(soup.a.text)</span><br><span class="line">print(soup.a.string)</span><br><span class="line">print(<span class="built_in">list</span>(soup.a.strings))</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> Elsie </span><br><span class="line">[]</span><br></pre></td></tr></table></figure><p>可以看出，<code>.string</code> 输出了注释中的内容！</p><p>如果改成这样，对应输出为：</p><p>考虑以下情形：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">html = <span class="string">&#x27;&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;&#x27;</span></span><br><span class="line">soup = BeautifulSoup(html, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">print(soup.a.text)</span><br><span class="line">print(soup.a.string)</span><br><span class="line">print(<span class="built_in">list</span>(soup.a.strings))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aaabbb</span><br><span class="line"><span class="literal">None</span></span><br><span class="line">[<span class="string">&#x27;aaa&#x27;</span>, <span class="string">&#x27;bbb&#x27;</span>]</span><br></pre></td></tr></table></figure><p>此时 <code>.string</code> 输出为 <code>None</code>。</p><p>再改成这样，则对应输出为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">html = <span class="string">&#x27;&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;&lt;!----&gt;&lt;/a&gt;&#x27;</span></span><br><span class="line">soup = BeautifulSoup(html, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">print(soup.a.text)</span><br><span class="line">print(soup.a.string)</span><br><span class="line">print(<span class="built_in">type</span>(soup.a.string))</span><br><span class="line">print(<span class="built_in">list</span>(soup.a.strings))</span><br><span class="line">print(<span class="built_in">len</span>(soup.a.string))</span><br><span class="line">print(<span class="built_in">len</span>(<span class="built_in">str</span>(soup.a.string)))</span><br><span class="line">print(<span class="built_in">ord</span>(soup.a.string))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">bs4</span>.<span class="title">element</span>.<span class="title">Comment</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">[]</span></span><br><span class="line"><span class="class">1</span></span><br><span class="line"><span class="class">1</span></span><br><span class="line"><span class="class">32</span></span><br></pre></td></tr></table></figure><p>如果注释内容为空，<code>.string</code> 会返回一个空格。注意，如果 <code>.string</code> 返回的内容是注释里面的内容，则类型为 <code>Comment</code>。</p><p>情形五表明注释也会分隔文本段。但是遍历 <code>.strings</code> 不会出现注释中的内容（即： <code>.strings</code> 不会出现非 <code>NavigableString</code> 类型的内容）。因此 <code>.text</code> 和 <code>.string</code> 的第四个区别是，如果标签内含有注释，虽然注释可以分隔文本段，但是前者和 <code>.strings</code> 会忽略掉注释，后者则会考虑注释的内容（如果注释为空则返回空格）。</p><h2 id="总结">总结</h2><p><code>.text</code> 和 <code>.string</code> 的区别总结如下：</p><ul><li>如果调用两者返回的都是字符串，那么调用前者返回的类型为 <code>str</code> ，后者返回的类型为 <code>NavigableString</code>（如果返回注释里面的内容，则类型为 <code>Comment</code>）；</li><li>根据标签内文本段的个数：<ul><li>如果标签中含有多段文本，前者会将这些文本按出现先后顺序拼接然后输出（不包括注释中的内容），后者只会输出 <code>None</code>；</li><li>如果标签内只有一段文本后者才不会输出 <code>None</code>。如果这段文本不是注释，则前后者输出的文本是一样的；如果这段文本在注释里面，前者输出空字符串，后者输出注释中的内容；</li><li>如果标签内没有文本且不含注释，前者输出空字符串，后者输出 <code>None</code>；如果有注释，且注释内容为空，则前者输出空字符串，后者输出一个空格。</li></ul></li></ul><h2 id="补充">补充</h2><h3 id="text-和-get_text">.text 和 get_text() ？</h3><p>调用前者相当于调用后者且不带参数。</p><h3 id="test-和-.strings-的关系">.test 和 .strings 的关系？</h3><p><code>.test</code> 相当于 <code>''.join([str(s) for s in .strings])</code></p><h3 id="如何获取注释中的内容">如何获取注释中的内容？</h3><ul><li>如果标签中只有注释且没有其他文本，则调用 <code>.string</code> 即可。</li><li>调用 <code>.contents</code> 返回该标签包含的所有直接子标签（类型为 <code>Tag</code>），文本（类型为 <code>NavigableString</code>）和注释组成的列表，该列表中类型为 <code>Comments</code> 的元素为注释。</li></ul><h3 id="如何获取标签内特定的文本段">如何获取标签内特定的文本段？</h3><p>可以用位置下标索引列表 <code>list(.strings)</code>，或者遍历 <code>.strings</code> 返回符合条件的元素，等等。</p><h3 id="strings-和-.stripped_strings">.strings 和 .stripped_strings？</h3><p>都是生成器。遍历后者输出的字符串如果不为空则会去掉首尾所有空白字符，不输出仅包含空白字符的字符串。</p><h2 id="参考">参考</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/30911642">Python BeautifulSoup 中.text与.string的区别</a></li><li><a href="https://blog.csdn.net/f156207495/article/details/78074240/">BeautifulSoup中的.text方法和get_text()方法的区别</a></li><li><a href="https://www.cnblogs.com/gl1573/p/9958716.html">【Python 库】bs4 中 string 属性和 text 属性的区别及背后的原理</a></li><li><a href="https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/">BeautifulSoup官方文档</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> BeautifulSoup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python爬虫学习】爬取虾米音乐旧版网站评论</title>
      <link href="posts/9789a339/"/>
      <url>posts/9789a339/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>说起虾米音乐要关闭的事，其实刚有这个通知的时候就知道了，但是由于本人拖延症实在是太严重，可能也是因为平时一般都用网易云不常用虾米的原因吧，看到这个通知之后我也就没有过多的反应了。直到 2 月 4 号，也就是关闭的前一天晚上，我才匆忙想起来这个事，然后就赶紧按照教程把收藏的歌单导出到 QQ 音乐和网易云了，还存了旧版的静态网页。还好，收藏的歌单不多，很快就备份完了。</p><p>但是等到 2 月 5 号零点之后，旧版网站 emumo.xiami.com 已经不能访问了，进入新版网站会自动跳转到音螺平台（coach.xiami.com）。但是我的 iOS 端居然还能用，只是歌单再也不能一键导出到其他平台了。也就是这一天我才想起来我没有把歌曲的评论爬取备份下来！直到中午，我的 iOS 端除了评论还能看，缓存的歌还能放之外其他功能都废了。然后我就在评论区和知乎里面，再加上自己也一起摸索各种打开网页版的方法……</p><a id="more"></a><p>之后终于找到了目前还能看的旧版网站域名 i.xiami.com ，但是打开页面之后很多地方（歌手、专辑、歌单、歌曲详情等等）仍然会链接到那个已经打不开的旧版网站。</p><p>经过了一番千辛万苦的摸索，终于在当天晚上弄到了我要爬取评论的页面：（目前均已无法访问）</p><ul><li>歌手页：<a href="https://i.xiami.com/yanchi">https://i.xiami.com/yanchi</a></li><li>专辑页：<a href="https://i.xiami.com/album/xkHeQldf94d">https://i.xiami.com/album/xkHeQldf94d</a></li><li>歌曲页：<a href="https://i.xiami.com/song/mQPxAZ751cb">https://i.xiami.com/song/mQPxAZ751cb</a></li></ul><p>那就开始吧：</p><h2 id="分析">分析</h2><p>首先我想要爬取的是短评，通过 Chrome 浏览器打开的样子如下图所示：</p><p><img data-src="/posts/9789a339/1.png" alt="1" style="zoom:50%;"></p><p>为了尽可能保护隐私，已将头像等个人信息打码处理。</p><p>打开开发者工具分析元素，可知头像、个人信息、评论内容对应的元素：</p><figure><img data-src="/posts/9789a339/2.png" alt><figcaption>2</figcaption></figure><p>也可以看出来这些信息肯定都只在 <code>class</code> 为 <code>post_item</code> 的 <code>&lt;div&gt;</code> 标签里面。</p><p>由于时间紧（怕现在这个可用的域名也突然停服了），所以就不爬取头像了，反正也无关紧要，我只想看评论内容就行。</p><p>另外评论内容在 <code>class</code> 为 <code>brief</code> 的 <code>&lt;div&gt;</code> 标签里面，属于 <code>class</code> 为 <code>post_item</code> 的 <code>&lt;div&gt;</code> 标签的子标签，这里面的情况有点复杂：</p><p>例如下图：</p><p><img data-src="/posts/9789a339/3.png" alt="3" style="zoom:50%;"></p><p>里面的表情包是以 <code>&lt;img&gt;</code> 子标签的形式出现的，还夹杂在文本里面，底部还有客户端的 <code>&lt;a&gt;</code> 标签：</p><figure><img data-src="/posts/9789a339/4.png" alt><figcaption>4</figcaption></figure><p>一条评论里面可能还会嵌套回复的评论标签（但是要注意里面没有赞和踩）：</p><p><img data-src="/posts/9789a339/5.png" alt="5" style="zoom:50%;"></p><p><img data-src="/posts/9789a339/6.png" alt="6" style="zoom:50%;"></p><p>注意这个 <code>class</code> 为 <code>post_item</code> 的 <code>&lt;div&gt;</code> 标签是 <code>class</code> 为 <code>brief</code> 的 <code>&lt;div&gt;</code> 标签的子标签。</p><p>在 <code>class</code> 为 <code>brief</code> 的 <code>&lt;div&gt;</code> 标签的所有直接子标签中，<code>id</code> 为 <code>brief_</code> 加上若干数字的 <code>&lt;div&gt;</code> 标签中一定包含评论内容。</p><p>再看翻页的部分：</p><p><img data-src="/posts/9789a339/7.png" alt="7" style="zoom:50%;"></p><p><img data-src="/posts/9789a339/8.png" alt="8" style="zoom:50%;"></p><p>「下一页」按钮所属的 <code>&lt;a&gt;</code> 标签的 <code>class</code> 为 <code>p_redirect_l</code>。</p><p>奇怪的地方出现了，<code>href="javascript:;"</code> 不是代表点击后没有任何反应吗？可是点击下一页肯定有反应的。</p><p>首先查看源代码，可以发现 <code>href</code> 标签是一个链接：</p><figure><img data-src="/posts/9789a339/9.png" alt><figcaption>9</figcaption></figure><p>但是定位到翻页的代码一看是这样的：</p><figure><img data-src="/posts/9789a339/10.png" alt><figcaption>10</figcaption></figure><p>点击事件是在 js 代码中分配的，而不是在标签上直接定义的。</p><p>这样不仅不会发生页面跳转，并且按钮也会有点击事件。W3C 不推荐在 <code>href</code> 中嵌入 js 代码。</p><h2 id="代码">代码</h2><h3 id="全局变量">全局变量</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># base_url = &#x27;https://i.xiami.com/album/xkHeQldf94d&#x27;</span></span><br><span class="line"><span class="comment"># base_url = &#x27;https://i.xiami.com/yanchi&#x27;</span></span><br><span class="line">base_url = <span class="string">&#x27;https://i.xiami.com/song/mQPxAZ751cb&#x27;</span> <span class="comment"># 要爬取的页面</span></span><br><span class="line">page_count = <span class="number">0</span> <span class="comment"># 页面数</span></span><br><span class="line"></span><br><span class="line">comment_count = <span class="number">0</span> <span class="comment"># 评论个数</span></span><br><span class="line">comment_list = [] <span class="comment"># 评论内容列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于分离出评论内容</span></span><br><span class="line">from_iphone = <span class="string">&#x27;来自iPhone客户端&#x27;</span></span><br><span class="line">from_android = <span class="string">&#x27;来自android客户端&#x27;</span></span><br><span class="line"></span><br><span class="line">num_pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\d+&#x27;</span>) <span class="comment"># 匹配至少1个数字</span></span><br><span class="line">brief_pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;^brief\_\d+&#x27;</span>) <span class="comment"># 匹配评论文本内容所在的标签</span></span><br><span class="line">date_pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\d&#123;4&#125;\-\d&#123;2&#125;\-\d&#123;2&#125;&#x27;</span>) <span class="comment"># 匹配日期</span></span><br></pre></td></tr></table></figure><h3 id="seleniumbeautifulsoup">Selenium、BeautifulSoup</h3><p>这次是使用了 <code>Selenium</code> 库打开 Chrome ，模拟手动点击网页。使用 <code>BeautifulSoup</code> 辅助解析网页。</p><h4 id="导入相关库">导入相关库</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options</span><br></pre></td></tr></table></figure><h4 id="打开和关闭-chrome-浏览器">打开和关闭 Chrome 浏览器</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">chrome_options = Options()</span><br><span class="line">chrome_options.add_argument(<span class="string">&#x27;--headless&#x27;</span>) <span class="comment"># 无头模式，即不弹出浏览器执行</span></span><br><span class="line">chrome_options.add_argument(<span class="string">&#x27;--disable-gpu&#x27;</span>) <span class="comment"># 禁用硬件加速，防止造成卡顿</span></span><br><span class="line">driver = webdriver.Chrome(options=chrome_options) <span class="comment"># 打开 chromedriver 和浏览器</span></span><br><span class="line"><span class="comment"># 这里调用 Chrome 浏览器没有路径参数，需要将 chromedriver 所在的路径添加到环境变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 爬取任务结束后，需要关闭浏览器和 chromedriver，防止占用过多系统资源：</span></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure><h4 id="通过-get-请求获取页面">通过 get 请求获取页面</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.get(base_url)</span><br></pre></td></tr></table></figure><h4 id="解析请求到的页面">解析请求到的页面</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">soup = BeautifulSoup(driver.page_source, <span class="string">&#x27;html.parser&#x27;</span>) <span class="comment"># soup 变量代表文档的根节点</span></span><br></pre></td></tr></table></figure><h4 id="在文档树中查找评论对应的所有元素">在文档树中查找评论对应的所有元素</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">comments = soup.find_all(<span class="string">&#x27;div&#x27;</span>, class_=<span class="string">&#x27;comment_item&#x27;</span>)</span><br><span class="line"><span class="comment"># 在 find_all() 函数中，recursive 参数默认为 True，表示递归查找所有子孙节点（否则只查找直接子节点）</span></span><br></pre></td></tr></table></figure><p>上述写法等价为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">comments = soup.find_all(<span class="string">&#x27;div&#x27;</span>, attrs=&#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;comment_item&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><p>对于非标准定义的属性必须使用这种写法。</p><h4 id="解析个人信息">解析个人信息</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">info = comment.find(<span class="string">&#x27;div&#x27;</span>, class_=<span class="string">&#x27;info&#x27;</span>) <span class="comment"># 个人信息对应的元素</span></span><br><span class="line">author = info.find(<span class="string">&#x27;span&#x27;</span>, class_=<span class="string">&#x27;author&#x27;</span>) <span class="comment"># 昵称和签名</span></span><br><span class="line">author_name = author.a.text <span class="comment"># 昵称和签名合起来的文本</span></span><br><span class="line">author_quote = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 提取签名文本</span></span><br><span class="line"><span class="keyword">if</span> author.text.find(<span class="string">&#x27;(&#x27;</span>) &gt;= <span class="number">0</span> <span class="keyword">and</span> author.text[-<span class="number">1</span>] == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">  author_quote = author.text[author.text.find(<span class="string">&#x27;(&#x27;</span>) + <span class="number">1</span>:-<span class="number">1</span>]</span><br><span class="line">comment_time = info.find(<span class="string">&#x27;span&#x27;</span>, class_=<span class="string">&#x27;time&#x27;</span>).text <span class="comment"># 评论时间</span></span><br><span class="line"><span class="comment"># 嵌套评论节点没有赞和踩的信息，所以要分开处理</span></span><br><span class="line">agree = <span class="number">0</span></span><br><span class="line">agree_obj = info.find(<span class="string">&#x27;span&#x27;</span>, class_=<span class="string">&#x27;ageree&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> agree_obj != <span class="literal">None</span>:</span><br><span class="line">    agree = <span class="built_in">int</span>(agree_obj.a.text[<span class="number">2</span>:-<span class="number">1</span>])</span><br><span class="line">disagree = <span class="number">0</span></span><br><span class="line">disagree_obj = info.find(<span class="string">&#x27;span&#x27;</span>, class_=<span class="string">&#x27;disageree&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> disagree_obj != <span class="literal">None</span>:</span><br><span class="line">  disagree = <span class="built_in">int</span>(disagree_obj.a.text[<span class="number">2</span>:-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>在 <code>BeautifulSoup</code> 中，<code>find()</code> 和 <code>find_all()</code> 用法类似，只是前者只返回找到的第一个元素（如果没有就返回 <code>None</code>），后者返回所有找到的元素（如果没有就返回空列表）。</p><h4 id="解析评论">解析评论</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">brief_obj = comment.find(<span class="string">&#x27;div&#x27;</span>, class_=<span class="string">&#x27;brief&#x27;</span>).find(</span><br><span class="line">    <span class="string">&#x27;div&#x27;</span>, <span class="built_in">id</span>=brief_pattern)</span><br><span class="line">brief = <span class="string">&#x27;&#x27;</span></span><br><span class="line">smile_list = []</span><br><span class="line"><span class="keyword">for</span> el <span class="keyword">in</span> brief_obj.contents:</span><br><span class="line">    <span class="keyword">if</span> el.name == <span class="string">&#x27;img&#x27;</span>: <span class="comment"># 如果该 tag 是 &lt;img&gt;</span></span><br><span class="line">        curr_num = num_pattern.findall(el[<span class="string">&#x27;src&#x27;</span>])[<span class="number">0</span>] <span class="comment"># 匹配表情代号</span></span><br><span class="line">        brief += <span class="string">&#x27;[smile_%s]&#x27;</span> % curr_num <span class="comment"># 用此文本替换出现的表情图片</span></span><br><span class="line">        smile_list.append(<span class="string">&#x27;./xiami_smile/&#x27;</span> + curr_num + <span class="string">&#x27;.png&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> el.name == <span class="literal">None</span>: <span class="comment"># 如果是文本则没有标签名</span></span><br><span class="line">        brief += <span class="built_in">str</span>(el)</span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        brief += el.text</span><br><span class="line">from_where = <span class="string">&#x27;&#x27;</span></span><br><span class="line">brief = brief.strip()</span><br><span class="line"><span class="comment"># 过滤客户端来源</span></span><br><span class="line"><span class="keyword">if</span> brief.find(from_android) &gt;= <span class="number">0</span>:</span><br><span class="line">    brief = brief[:brief.find(from_android)].rstrip()</span><br><span class="line">    from_where = from_android</span><br><span class="line"><span class="keyword">elif</span> brief.find(from_iphone) &gt;= <span class="number">0</span>:</span><br><span class="line">    brief = brief[:brief.find(from_iphone)].rstrip()</span><br><span class="line">    from_where = from_iphone</span><br></pre></td></tr></table></figure><ul><li><p><code>find()</code> 和 <code>find_all()</code> 的标签或属性参数可以是正则表达式对象（第 2 行），会通过正则表达式的 <code>match()</code> 匹配内容</p></li><li><p>对于一个节点变量 <code>obj</code> ，可以通过 <code>obj.contents</code> 获取该节点的所有直接子节点。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup=BeautifulSoup(<span class="string">&#x27;&lt;p&gt;sss&lt;a&gt;ddd&lt;/a&gt;&lt;span&gt;&quot;aaa&quot;&lt;a&gt;&quot;bbb&quot;&lt;/a&gt;&quot;ccc&quot;&lt;/span&gt;rrr&lt;/p&gt;&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup                                                                        </span><br><span class="line">&lt;html&gt;&lt;body&gt;&lt;p&gt;sss&lt;a&gt;ddd&lt;/a&gt;&lt;span&gt;&quot;aaa&quot;&lt;a&gt;&quot;bbb&quot;&lt;/a&gt;&quot;ccc&quot;&lt;/span&gt;rrr&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup.contents</span><br><span class="line">[&lt;html&gt;&lt;body&gt;&lt;p&gt;sss&lt;a&gt;ddd&lt;/a&gt;&lt;span&gt;&quot;aaa&quot;&lt;a&gt;&quot;bbb&quot;&lt;/a&gt;&quot;ccc&quot;&lt;/span&gt;rrr&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup.p.contents</span><br><span class="line">[&#x27;sss&#x27;, &lt;a&gt;ddd&lt;/a&gt;, &lt;span&gt;&quot;aaa&quot;&lt;a&gt;&quot;bbb&quot;&lt;/a&gt;&quot;ccc&quot;&lt;/span&gt;, &#x27;rrr&#x27;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(soup.p.contents[<span class="number">0</span>])</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">bs4</span>.<span class="title">element</span>.<span class="title">NavigableString</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span>(<span class="params">soup.p.contents[<span class="number">1</span>]</span>)</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> &#x27;<span class="title">bs4</span>.<span class="title">element</span>.<span class="title">Tag</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span>(<span class="params">soup.p.contents[<span class="number">1</span>].text</span>)</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> &#x27;<span class="title">str</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">soup</span>.<span class="title">p</span>.<span class="title">span</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">span</span>&gt;&quot;<span class="title">aaa</span>&quot;&lt;<span class="title">a</span>&gt;&quot;<span class="title">bbb</span>&quot;&lt;/<span class="title">a</span>&gt;&quot;<span class="title">ccc</span>&quot;&lt;/<span class="title">span</span>&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">soup</span>.<span class="title">a</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">a</span>&gt;<span class="title">ddd</span>&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">soup</span>.<span class="title">span</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">span</span>&gt;&quot;<span class="title">aaa</span>&quot;&lt;<span class="title">a</span>&gt;&quot;<span class="title">bbb</span>&quot;&lt;/<span class="title">a</span>&gt;&quot;<span class="title">ccc</span>&quot;&lt;/<span class="title">span</span>&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">soup</span>.<span class="title">div</span> # 结果为 <span class="title">None</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">soup</span>.<span class="title">name</span></span></span><br><span class="line"><span class="class">&#x27;[<span class="title">document</span>]&#x27;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">soup</span>.<span class="title">p</span>.<span class="title">a</span>[&#x27;<span class="title">href</span>&#x27;]</span></span><br><span class="line"><span class="class"><span class="title">Traceback</span> (<span class="params">most recent call last</span>):</span></span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">&quot;/Users/betty/Library/Python/3.7/lib/python/site-packages/bs4/element.py&quot;</span>, line <span class="number">1406</span>, <span class="keyword">in</span> __getitem__</span><br><span class="line">    <span class="keyword">return</span> self.attrs[key]</span><br><span class="line">KeyError: <span class="string">&#x27;href&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure></li><li><p>通过<code>obj.text</code> 获取该节点连同所有子节点的文本，类型为 <code>str</code>。</p></li><li><p>通过 <code>obj.contents</code> 返回的结果中，对于文本节点，例如上述的 <code>contents[0]</code> ，类型为 <code>NavigableString</code>；普通的标签（例如 <code>contents[1]</code>）的类型为 <code>Tag</code>。</p></li><li><p>如果 <code>obj</code> 是普通标签，<code>obj.name</code> 结果为其标签名；如果是文本则 <code>obj.name</code> 结果为 <code>None</code>；如果是根节点（<code>soup</code>）则为 <code>[document]</code></p></li><li><p>通过 <code>obj</code> 直接引用子标签，例如 <code>obj.p</code> 、<code>obj.a</code>，的效果和 <code>find('p')</code> 、<code>find('a')</code> 类似。</p></li><li><p>通过 <code>obj['attr']</code> 可以得到对应的属性（例如 <code>obj['src']</code> 、<code>obj['href']</code>），若不存在该属性将抛出 <code>KeyError</code> 异常。</p></li></ul><h4 id="翻页">翻页</h4><p>解析完一页的评论以后需要翻到下一页，采用模拟点击的方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">next_page = driver.find_element_by_class_name(<span class="string">&#x27;p_redirect_l&#x27;</span>) <span class="comment"># 通过类名获取元素</span></span><br><span class="line">next_page.click() <span class="comment"># 模拟点击，之后无需再调用 driver.get(base_url)</span></span><br></pre></td></tr></table></figure><h3 id="随机延时">随机延时</h3><p>设置随机延时是为了防止服务器设置了反爬策略（也许有更好的方法）<del>，同时也想多看看输出的评论</del>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">time.sleep(random.randint(<span class="number">5</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure><h3 id="去除-html-转义字符">去除 HTML 转义字符</h3><p>通过以上步骤得到的评论内容 <code>brief</code> 含有 HTML 转义字符，需要通过以下方式去除：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> html</span><br><span class="line">brief = html.unescape(brief)</span><br></pre></td></tr></table></figure><h3 id="将爬取结果写入-json-文件">将爬取结果写入 JSON 文件</h3><p>首先将一条评论的信息（<code>dict</code>）加入到列表 <code>comment_list</code> 中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 评论解析完毕，加入 comment_list</span></span><br><span class="line">comment_info = &#123;</span><br><span class="line">    <span class="string">&#x27;comment_num&#x27;</span>: comment_count,</span><br><span class="line">    <span class="string">&#x27;author_name&#x27;</span>: author_name,</span><br><span class="line">    <span class="string">&#x27;author_quote&#x27;</span>: author_quote,</span><br><span class="line">    <span class="string">&#x27;comment_time&#x27;</span>: comment_time,</span><br><span class="line">    <span class="string">&#x27;agree&#x27;</span>: agree,</span><br><span class="line">    <span class="string">&#x27;disagree&#x27;</span>: disagree,</span><br><span class="line">    <span class="string">&#x27;brief&#x27;</span>: brief,</span><br><span class="line">    <span class="string">&#x27;from_where&#x27;</span>: from_where,</span><br><span class="line">    <span class="string">&#x27;smile_list&#x27;</span>: smile_list</span><br><span class="line">&#125;</span><br><span class="line">comment_list.append(comment_info)</span><br></pre></td></tr></table></figure><p>写入 JSON 文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="comment"># 生成 JSON 字符串</span></span><br><span class="line"><span class="comment"># data = json.dumps(comment_list, ensure_ascii=False, indent=8)</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./short_comments_test1_song.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    json.dump(comment_list, f, ensure_ascii=<span class="literal">False</span>, indent=<span class="number">8</span>)</span><br><span class="line"><span class="comment"># ensure_ascii=False 保证输出中文</span></span><br><span class="line"><span class="comment"># indent: 格式化输出，值表示一个 tab 缩进是几个空格，值为 0 则整个输出结果只有一行</span></span><br></pre></td></tr></table></figure><h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> html</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options</span><br><span class="line"></span><br><span class="line"><span class="comment"># base_url = &#x27;https://i.xiami.com/album/xkHeQldf94d&#x27;</span></span><br><span class="line"><span class="comment"># base_url = &#x27;https://i.xiami.com/yanchi&#x27;</span></span><br><span class="line">base_url = <span class="string">&#x27;https://i.xiami.com/song/mQPxAZ751cb&#x27;</span></span><br><span class="line">page_count = <span class="number">0</span></span><br><span class="line">comment_count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">comment_list = []</span><br><span class="line">from_iphone = <span class="string">&#x27;来自iPhone客户端&#x27;</span></span><br><span class="line">from_android = <span class="string">&#x27;来自android客户端&#x27;</span></span><br><span class="line">num_pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\d+&#x27;</span>)</span><br><span class="line">brief_pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;^brief\_\d+&#x27;</span>)</span><br><span class="line">date_pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\d&#123;4&#125;\-\d&#123;2&#125;\-\d&#123;2&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">chrome_options = Options()</span><br><span class="line">chrome_options.add_argument(<span class="string">&#x27;--headless&#x27;</span>)</span><br><span class="line">chrome_options.add_argument(<span class="string">&#x27;--disable-gpu&#x27;</span>)</span><br><span class="line">driver = webdriver.Chrome(options=chrome_options)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_short_comment</span>():</span></span><br><span class="line">    <span class="keyword">global</span> page_count</span><br><span class="line">    <span class="keyword">global</span> comment_count</span><br><span class="line">    time.sleep(random.randint(<span class="number">5</span>, <span class="number">10</span>))</span><br><span class="line">    page_count += <span class="number">1</span></span><br><span class="line">    print(<span class="string">&#x27;In page %d:&#x27;</span> % page_count)</span><br><span class="line">    <span class="keyword">if</span> page_count == <span class="number">1</span>:</span><br><span class="line">        driver.get(base_url)</span><br><span class="line">    soup = BeautifulSoup(driver.page_source, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line">    comments = soup.find(<span class="string">&#x27;div&#x27;</span>, class_=<span class="string">&#x27;wall_list&#x27;</span>).find_all(</span><br><span class="line">        <span class="string">&#x27;div&#x27;</span>, class_=<span class="string">&#x27;post_item&#x27;</span>)</span><br><span class="line">    <span class="comment"># 遍历该页所有评论</span></span><br><span class="line">    <span class="keyword">for</span> comment <span class="keyword">in</span> comments:</span><br><span class="line">        comment_count += <span class="number">1</span></span><br><span class="line">        info = comment.find(<span class="string">&#x27;div&#x27;</span>, class_=<span class="string">&#x27;info&#x27;</span>)</span><br><span class="line">        author = info.find(<span class="string">&#x27;span&#x27;</span>, class_=<span class="string">&#x27;author&#x27;</span>)</span><br><span class="line">        author_name = author.a.text</span><br><span class="line">        author_quote = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> author.text.find(<span class="string">&#x27;(&#x27;</span>) &gt;= <span class="number">0</span> <span class="keyword">and</span> author.text[-<span class="number">1</span>] == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">            author_quote = author.text[author.text.find(<span class="string">&#x27;(&#x27;</span>) + <span class="number">1</span>:-<span class="number">1</span>]</span><br><span class="line">        comment_time = info.find(<span class="string">&#x27;span&#x27;</span>, class_=<span class="string">&#x27;time&#x27;</span>).text</span><br><span class="line">        agree = <span class="number">0</span></span><br><span class="line">        agree_obj = info.find(<span class="string">&#x27;span&#x27;</span>, class_=<span class="string">&#x27;ageree&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> agree_obj != <span class="literal">None</span>:</span><br><span class="line">            agree = <span class="built_in">int</span>(agree_obj.a.text[<span class="number">2</span>:-<span class="number">1</span>])</span><br><span class="line">        disagree = <span class="number">0</span></span><br><span class="line">        disagree_obj = info.find(<span class="string">&#x27;span&#x27;</span>, class_=<span class="string">&#x27;disageree&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> disagree_obj != <span class="literal">None</span>:</span><br><span class="line">            disagree = <span class="built_in">int</span>(disagree_obj.a.text[<span class="number">2</span>:-<span class="number">1</span>])</span><br><span class="line">        brief_obj = comment.find(<span class="string">&#x27;div&#x27;</span>, class_=<span class="string">&#x27;brief&#x27;</span>).find(</span><br><span class="line">            <span class="string">&#x27;div&#x27;</span>, <span class="built_in">id</span>=brief_pattern)</span><br><span class="line">        brief = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        smile_list = []</span><br><span class="line">        <span class="keyword">for</span> el <span class="keyword">in</span> brief_obj.contents:</span><br><span class="line">            <span class="keyword">if</span> el.name == <span class="string">&#x27;img&#x27;</span>:</span><br><span class="line">                curr_num = num_pattern.findall(el[<span class="string">&#x27;src&#x27;</span>])[<span class="number">0</span>]</span><br><span class="line">                brief += <span class="string">&#x27;[smile_%s]&#x27;</span> % curr_num</span><br><span class="line">                smile_list.append(<span class="string">&#x27;./xiami_smile/&#x27;</span> + curr_num + <span class="string">&#x27;.png&#x27;</span>)</span><br><span class="line">            <span class="keyword">elif</span> el.name == <span class="literal">None</span>:</span><br><span class="line">                brief += <span class="built_in">str</span>(el)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                brief += el.text</span><br><span class="line">        from_where = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        brief = brief.strip()</span><br><span class="line">        <span class="keyword">if</span> brief.find(from_android) &gt;= <span class="number">0</span>:</span><br><span class="line">            brief = brief[:brief.find(from_android)].rstrip()</span><br><span class="line">            from_where = from_android</span><br><span class="line">        <span class="keyword">elif</span> brief.find(from_iphone) &gt;= <span class="number">0</span>:</span><br><span class="line">            brief = brief[:brief.find(from_iphone)].rstrip()</span><br><span class="line">            from_where = from_iphone</span><br><span class="line">        brief = html.unescape(brief)</span><br><span class="line">        print(<span class="string">f&#x27;<span class="subst">&#123;comment_count&#125;</span>: <span class="subst">&#123;brief&#125;</span>&#x27;</span>)</span><br><span class="line">        comment_info = &#123;</span><br><span class="line">            <span class="string">&#x27;comment_num&#x27;</span>: comment_count,</span><br><span class="line">            <span class="string">&#x27;author_name&#x27;</span>: author_name,</span><br><span class="line">            <span class="string">&#x27;author_quote&#x27;</span>: author_quote,</span><br><span class="line">            <span class="string">&#x27;comment_time&#x27;</span>: comment_time,</span><br><span class="line">            <span class="string">&#x27;agree&#x27;</span>: agree,</span><br><span class="line">            <span class="string">&#x27;disagree&#x27;</span>: disagree,</span><br><span class="line">            <span class="string">&#x27;brief&#x27;</span>: brief,</span><br><span class="line">            <span class="string">&#x27;from_where&#x27;</span>: from_where,</span><br><span class="line">            <span class="string">&#x27;smile_list&#x27;</span>: smile_list</span><br><span class="line">        &#125;</span><br><span class="line">        comment_list.append(comment_info)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        next_page = driver.find_element_by_class_name(<span class="string">&#x27;p_redirect_l&#x27;</span>)</span><br><span class="line">        next_page.click()</span><br><span class="line">        <span class="keyword">if</span> page_count &gt;= <span class="number">200</span>: <span class="comment"># 目前无法通过该服务器获取到 200 页以后的评论</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        get_short_comment()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        get_short_comment()</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        driver.quit()</span><br><span class="line">        print(<span class="built_in">len</span>(comment_list))</span><br><span class="line">        <span class="comment"># data = json.dumps(comment_list, ensure_ascii=False, indent=8)</span></span><br><span class="line">        <span class="comment"># print(data)</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./short_comments_test1_song.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            json.dump(comment_list, f, ensure_ascii=<span class="literal">False</span>, indent=<span class="number">8</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果类似下图：</p><p><img data-src="/posts/9789a339/11.png" alt="11" style="zoom:50%;"></p><p>输出的文件类似下图（如果是回复别人的，没有记录谁回复谁）：</p><p><img data-src="/posts/9789a339/11_1.png" alt="11_1" style="zoom:50%;"></p><h3 id="改进">改进</h3><p>根据<a href="#分析">上一节</a>的分析，结合 Chrome 开发者工具抓取网络包分析，其实每一个的评论都在以下链接里面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://i.xiami.com/commentlist/turnpage/id/object_id/page/页码?type=4</span><br></pre></td></tr></table></figure><p>其中 <code>object_id</code> 从源码的这里能够找到，替换上述链接相应位置即可（页码也要替换成要看的页面）：</p><p><img data-src="/posts/9789a339/12.png" alt="12" style="zoom:50%;"></p><p>通过这个链接可以获取到评论所在的静态页面，这样使用 <code>requests</code> 模块就可以了。因为 <code>Selenium</code> 会调用浏览器进行渲染，速度实在太慢，还是尽可能用 <code>requests</code> 模块吧，除非在极端特殊的情况（例如反爬措施非常严格）下。</p><p>另外就是由于时间比较仓促，害怕我写脚本写太慢，还没拿到数据就不能访问了，我没有把谁回复谁的信息记录下来，如果有时间了再增加吧。</p><h2 id="后记">后记</h2><p>明明在 2 月 5 号零点之后，旧版网站 emumo.xiami.com 已经进不去了（歌单也打不开了），手机也不能再发评论了，但是那一天我不断看到歌单里面有零零星星的新评论，而且说就是用的这个旧版网站。可是我就是进不去啊， 直到发现 Chrome 显示的错误是关于 DNS 解析相关的，再后来我居然偶尔还能打开页面，我才意识到应该只是 DNS 的问题（可能 DNS 服务器中的表项被删）。我试图找能访问的服务器 IP 地址也没找到。</p><p>我好不容易找到了要爬取短评论的页面，但是专辑里面的乐评还是看不到。</p><p>后来有了一位大佬在微信公众号上发了一篇<a href="https://mp.weixin.qq.com/s/wHaYXgOyjGkGAaFm-LcNeQ">文章</a>，说明了如何访问旧版服务器 emumo.xiami.com 的方法以及现在如何备份数据，还提供了 GitHub 大佬开发的<a href="https://github.com/xiami2021/backup">一键备份软件</a>（可以将自己的收藏歌单、音乐等等通过 JSON 字符串的形式备份，还可以下载音频）。我一看需要改 hosts 文件就证明真的只是 DNS 的问题，现在并没有真的停服，只是访问服务器的入口没有了而已。但是估计最晚到 3 月 5 号就真的停服了。高手在民间，大佬就是大佬。好人一生平安。没准那些在 2 月 5 号下午能发评论的少数人也是程序员呢。</p><p>修改了 hosts 文件之后的我很开心，终于能看到乐评了。于是趁着这个时间赶紧再备份一些乐评还有一些静态页面。同时下载安装这个软件导出了 JSON 字符串还有部分音频。</p><p>然而当我爬取短评的时候，又发现了不开心的事情：我只能从旧版网页中爬取最多 200 页的评论，因为从获取评论的链接获取 200 页之后的评论，返回的都是第 200 页的评论。我试图用手机截图来保存评论结果还没翻到一半就闪退了，每次都这样。哭了，我真的很努力地在及时止损了。</p><p>到了 2 月 7 号中午， emumo.xiami.com 已经 502 了，到了下午直接就 404 了，当天 i.xiami.com 也已经不能访问。本来我上面的爬虫由于时间关系没有记录谁回复谁的情况，想修改一下，结果就不能访问了。跟 5 号 emumo.xiami.com 不能访问的原因一样，但是再加 hosts 又有什么用，反正 emumo.xiami.com 已经 404 就表明服务器的这些静态网页文件早就被删除了，或者是强制返回 404 吧。可恶，我还以为阿里应该不会也不想再管这里了，对于 hosts 漏洞估计也会睁一只眼闭一只眼吧，没想到这么快就堵上了，可能是不堵上也是持续消耗他们的服务器资源吧。现在估计技术多厉害的民间大佬也都没法发评论了。但是值得注意的是，这个备份软件的 GitHub 仓库更新了，如果添加了 h5api.m.xiami.com 的 hosts ，这个备份软件的备份 JSON 字符串的功能还能用！虽然用它来下载音频也不行了。另外，我的手机还是可以继续看评论。于是我就把目光放在了这个备份软件的<a href="https://github.com/xiami2021/visualization/blob/main/backup.html">源码</a>上，发现了这样的字符串：</p><p><img data-src="/posts/9789a339/13.png" alt="13" style="zoom:50%;"></p><p>看起来像是 API 的样子，感觉像是找到突破口了？于是我先在百度上查了一下，没查到。还是回 GitHub 上查吧，但是没想到居然真的查到了一些代码，于是我下载了一份 Python 源码，因为它把这个 API 给封装了，并且发现它就是向 h5api.m.xiami.com 发起 GET 请求的。我尝试自己去发请求，但是这个 GET 请求携带的参数需要一个 token ，这个 token 是需要调用 <code>mtop.alimusic.music.songservice.getsongdetail</code> 这个 API 来获取的，但是这个 API 估计是失效了。很遗憾，感觉发现了这个 API 也是然并卵的样子。但是我又发现备份软件的源码是向 <code>http://localhost:8765</code> 发起请求的，但是监听 <code>localhost:8765</code> 的守护进程对应的源码（这是我认为最重要的代码）没有开源。根据备份软件的源码来看它应该是接收备份客户端的请求，然后将这个请求转发到虾米服务器的，简单地说就是一个代理服务器。于是我经过千辛万苦地搜索，终于搜索到了获取评论对应 API <code>mtop.alimusic.social.commentservice.getcommentlist</code> ，打开备份软件，然后按照格式发起了请求：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">req = requests.get(<span class="string">&#x27;http://localhost:8765/api/callAPI&#x27;</span>, params=&#123;</span><br><span class="line">        <span class="string">&#x27;action&#x27;</span>: json.dumps(&#123;</span><br><span class="line">            <span class="string">&#x27;method&#x27;</span>: <span class="string">&#x27;mtop.alimusic.social.commentservice.getcommentlist&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;needToken&#x27;</span>: <span class="literal">False</span>,</span><br><span class="line">            <span class="string">&#x27;args&#x27;</span>: &#123;</span><br><span class="line">                <span class="string">&#x27;objectId&#x27;</span>: <span class="string">&#x27;1774208889&#x27;</span>, <span class="comment"># 歌曲、专辑、歌手、歌单的数字id，mv的id也可</span></span><br><span class="line">                <span class="string">&#x27;objectType&#x27;</span>: <span class="string">&#x27;song&#x27;</span>, <span class="comment"># 类别，可以是song、album、artist、collect、mv</span></span><br><span class="line">                <span class="string">&#x27;pagingVO&#x27;</span>: &#123;</span><br><span class="line">                    <span class="string">&#x27;page&#x27;</span>: <span class="number">1</span>, <span class="comment"># 第几页</span></span><br><span class="line">                    <span class="string">&#x27;pageSize&#x27;</span>: <span class="number">3000</span> <span class="comment"># 一页的容量，尽量不要太大，否则会请求失败</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>结果真的成功了！总算拿到了所有的评论数据，失而复得的感觉简直不要太好！而且获得的信息比旧版网页全很多，还能看到谁回复谁：</p><p><img data-src="/posts/9789a339/14.png" alt="14" style="zoom:50%;"></p><p>但是如何获取其他歌曲、专辑、歌手、歌单的数字id或者mv的id？</p><p>首先尝试一下搜索：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">req = requests.get(<span class="string">&#x27;http://localhost:8765/api/callAPI&#x27;</span>, params=&#123;</span><br><span class="line">        <span class="string">&#x27;action&#x27;</span>: json.dumps(&#123;</span><br><span class="line">            <span class="string">&#x27;method&#x27;</span>: <span class="string">&#x27;mtop.alimusic.search.searchservice.searchsongs&#x27;</span>, <span class="comment"># 不知道是哪里错了还是什么原因，拿不到结果，估计也快失效了</span></span><br><span class="line">            <span class="comment"># &#x27;method&#x27;: &#x27;mtop.alimusic.search.searchservice.searchartists&#x27;, # 已失效</span></span><br><span class="line">            <span class="comment"># &#x27;method&#x27;: &#x27;mtop.alimusic.search.searchservice.searchalbums&#x27;, # 已失效</span></span><br><span class="line">            <span class="string">&#x27;needToken&#x27;</span>: <span class="literal">False</span>,</span><br><span class="line">            <span class="string">&#x27;args&#x27;</span>: &#123;</span><br><span class="line">                <span class="string">&#x27;key&#x27;</span>: <span class="string">&#x27;balabala.....&#x27;</span>,  <span class="comment"># 注意此处的关键词以+号分隔</span></span><br><span class="line">                <span class="string">&#x27;pagingVO&#x27;</span>: &#123;</span><br><span class="line">                    <span class="string">&#x27;page&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">                    <span class="string">&#x27;pageSize&#x27;</span>: <span class="number">10</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如果搜索不行了，那看来只能从自己收藏的内容或者创建的歌单找吧：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取用户收藏内容</span></span><br><span class="line"><span class="comment"># type为：收藏歌曲（1）、专辑（2）、歌手（3）、mv（4）、歌单（5）</span></span><br><span class="line"><span class="comment"># 此API大概在2月8号的时候已经失效</span></span><br><span class="line">req = requests.get(<span class="string">&#x27;http://localhost:8765/api/callAPI&#x27;</span>, params=&#123;</span><br><span class="line">        <span class="string">&#x27;action&#x27;</span>: json.dumps(&#123;</span><br><span class="line">            <span class="string">&#x27;method&#x27;</span>: <span class="string">&#x27;mtop.alimusic.fav.favoriteservice.getfavorites&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;needToken&#x27;</span>: <span class="literal">False</span>,</span><br><span class="line">            <span class="string">&#x27;args&#x27;</span>: &#123;</span><br><span class="line">                <span class="string">&#x27;userId&#x27;</span>: <span class="string">&#x27;********&#x27;</span>, <span class="comment"># 用户的数字id</span></span><br><span class="line">                <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;pagingVO&#x27;</span>: &#123;</span><br><span class="line">                    <span class="string">&#x27;page&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">                    <span class="string">&#x27;pageSize&#x27;</span>: <span class="number">100</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 获取用户创建歌单</span></span><br><span class="line">req = requests.get(<span class="string">&#x27;http://localhost:8765/api/callAPI&#x27;</span>, params=&#123;</span><br><span class="line">        <span class="string">&#x27;action&#x27;</span>: json.dumps(&#123;</span><br><span class="line">            <span class="string">&#x27;method&#x27;</span>: <span class="string">&#x27;mtop.alimusic.music.list.collectservice.getcollectbyuser&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;needToken&#x27;</span>: <span class="literal">False</span>,</span><br><span class="line">            <span class="string">&#x27;args&#x27;</span>: &#123;</span><br><span class="line">                <span class="string">&#x27;userId&#x27;</span>: <span class="string">&#x27;********&#x27;</span>, <span class="comment"># 用户的数字id</span></span><br><span class="line">                <span class="string">&#x27;pagingVO&#x27;</span>: &#123;</span><br><span class="line">                    <span class="string">&#x27;page&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">                    <span class="string">&#x27;pageSize&#x27;</span>: <span class="number">100</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>居然可以返回，然后从里面找到对应的id即可，注意歌曲、专辑、歌手、歌单一定要是数字id！当然，如果已经通过备份软件导出 JSON 字符串了（可以先将其格式化以方便查看），也可以找到对应的id（除了 mv 以外）。</p><p>还有如果获取了歌单的id，通过获取歌单详情和获取歌单所有歌曲，里面也能看到一些歌曲、专辑、歌手的id：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取歌单详情（只能看到部分歌曲）</span></span><br><span class="line">req = requests.get(<span class="string">&#x27;http://localhost:8765/api/callAPI&#x27;</span>, params=&#123;</span><br><span class="line">        <span class="string">&#x27;action&#x27;</span>: json.dumps(&#123;</span><br><span class="line">            <span class="string">&#x27;method&#x27;</span>: <span class="string">&#x27;mtop.alimusic.music.list.collectservice.getcollectdetail&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;needToken&#x27;</span>: <span class="literal">False</span>,</span><br><span class="line">            <span class="string">&#x27;args&#x27;</span>: &#123;</span><br><span class="line">                <span class="string">&#x27;listId&#x27;</span>: <span class="string">&#x27;********&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;isFullTags&#x27;</span>: <span class="literal">False</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 获取歌单所有歌曲（大概也是在2月8号的时候已经失效）</span></span><br><span class="line">req = requests.get(<span class="string">&#x27;http://localhost:8765/api/callAPI&#x27;</span>, params=&#123;</span><br><span class="line">        <span class="string">&#x27;action&#x27;</span>: json.dumps(&#123;</span><br><span class="line">            <span class="string">&#x27;method&#x27;</span>: <span class="string">&#x27;mtop.alimusic.music.list.collectservice.getcollectsongs&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;needToken&#x27;</span>: <span class="literal">False</span>,</span><br><span class="line">            <span class="string">&#x27;args&#x27;</span>: &#123;</span><br><span class="line">                <span class="string">&#x27;listId&#x27;</span>: <span class="string">&#x27;********&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;pagingVO&#x27;</span>: &#123;</span><br><span class="line">                    <span class="string">&#x27;page&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">                    <span class="string">&#x27;pageSize&#x27;</span>: <span class="number">200</span> <span class="comment"># 这里的最大值只能是200</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>还有通过专辑获取歌曲id、通过歌手获取歌曲或者专辑id：（均已失效）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">req = requests.get(<span class="string">&#x27;http://localhost:8765/api/callAPI&#x27;</span>, params=&#123;</span><br><span class="line">        <span class="string">&#x27;action&#x27;</span>: json.dumps(&#123;</span><br><span class="line">            <span class="string">&#x27;method&#x27;</span>: <span class="string">&#x27;mtop.alimusic.music.albumservice.getalbumdetail&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;needToken&#x27;</span>: <span class="literal">False</span>,</span><br><span class="line">            <span class="string">&#x27;args&#x27;</span>: &#123;</span><br><span class="line">                <span class="string">&#x27;albumId&#x27;</span>: <span class="string">&#x27;********&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line">req = requests.get(<span class="string">&#x27;http://localhost:8765/api/callAPI&#x27;</span>, params=&#123;</span><br><span class="line">        <span class="string">&#x27;action&#x27;</span>: json.dumps(&#123;</span><br><span class="line">            <span class="string">&#x27;method&#x27;</span>: <span class="string">&#x27;mtop.alimusic.music.songservice.getalbumsongs&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;needToken&#x27;</span>: <span class="literal">False</span>,</span><br><span class="line">            <span class="string">&#x27;args&#x27;</span>: &#123;</span><br><span class="line">                <span class="string">&#x27;albumId&#x27;</span>: <span class="string">&#x27;********&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;pagingVO&#x27;</span>: &#123;</span><br><span class="line">                    <span class="string">&#x27;page&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">                    <span class="string">&#x27;pageSize&#x27;</span>: <span class="number">200</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line">req = requests.get(<span class="string">&#x27;http://localhost:8765/api/callAPI&#x27;</span>, params=&#123;</span><br><span class="line">        <span class="string">&#x27;action&#x27;</span>: json.dumps(&#123;</span><br><span class="line">            <span class="string">&#x27;method&#x27;</span>: <span class="string">&#x27;mtop.alimusic.music.artistservice.getartistdetail&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;needToken&#x27;</span>: <span class="literal">False</span>,</span><br><span class="line">            <span class="string">&#x27;args&#x27;</span>: &#123;</span><br><span class="line">                <span class="string">&#x27;artistId&#x27;</span>: <span class="string">&#x27;********&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line">req = requests.get(<span class="string">&#x27;http://localhost:8765/api/callAPI&#x27;</span>, params=&#123;</span><br><span class="line">        <span class="string">&#x27;action&#x27;</span>: json.dumps(&#123;</span><br><span class="line">            <span class="string">&#x27;method&#x27;</span>: <span class="string">&#x27;mtop.alimusic.music.songservice.getartistsongs&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;needToken&#x27;</span>: <span class="literal">False</span>,</span><br><span class="line">            <span class="string">&#x27;args&#x27;</span>: &#123;</span><br><span class="line">                <span class="string">&#x27;artistId&#x27;</span>: <span class="string">&#x27;********&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;pagingVO&#x27;</span>: &#123;</span><br><span class="line">                    <span class="string">&#x27;page&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">                    <span class="string">&#x27;pageSize&#x27;</span>: <span class="number">200</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line">req = requests.get(<span class="string">&#x27;http://localhost:8765/api/callAPI&#x27;</span>, params=&#123;</span><br><span class="line">        <span class="string">&#x27;action&#x27;</span>: json.dumps(&#123;</span><br><span class="line">            <span class="string">&#x27;method&#x27;</span>: <span class="string">&#x27;mtop.alimusic.music.albumservice.getartistalbums&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;needToken&#x27;</span>: <span class="literal">False</span>,</span><br><span class="line">            <span class="string">&#x27;args&#x27;</span>: &#123;</span><br><span class="line">                <span class="string">&#x27;artistId&#x27;</span>: <span class="string">&#x27;********&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;pagingVO&#x27;</span>: &#123;</span><br><span class="line">                    <span class="string">&#x27;page&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">                    <span class="string">&#x27;pageSize&#x27;</span>: <span class="number">200</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>已经 2 月 9 号了，距离 2 月 5 号才过了 4 天，服务器入口接连被关，API 接口也在以肉眼可见的速度（以小时计）失效。我上述列出的还没失效的 API 也许过几个小时也失效了。由于备份软件主要依赖的 API 也相继失效，如果从来没有用它备份过的，现在已经没法开始新的备份了，这个备份软件基本上也算是废掉了。</p><p><img data-src="/posts/9789a339/15.png" alt="15" style="zoom:50%;"></p><p>这件事情就算是结束了吧。真的再见了。毕竟人要跟上时代的脚步。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> 虾米音乐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【备忘】Miniconda安装与使用</title>
      <link href="posts/715f63dd/"/>
      <url>posts/715f63dd/</url>
      
        <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>Miniconda 是 Anaconda 的轻量级版本，不包含很多的科学计算包，只有 Python 、conda 以及相关依赖。考虑到想省空间和不需要很多科学计算包的需求，就选择安装了 Miniconda，其他包有需要了再去单独下载。</p><a id="more"></a><h2 id="下载和安装步骤">下载和安装步骤</h2><ol type="1"><li><p>由于官网下载很慢，所以进入清华大学开源镜像站去<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/">下载</a> 安装包，选择与当前操作系统匹配的最新版本即可。</p></li><li><p>双击 <code>.exe</code> 或者 <code>.pkg</code> 安装包执行安装步骤（略）</p></li><li><p>以 Linux 系统为例，安装包是 <code>.sh</code> 文件，则在终端中定位到该文件所在的文件夹，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash ./&lt;installer&gt;.sh</span><br></pre></td></tr></table></figure><p>我下载的是 Miniconda3，如果是给单个用户安装，默认安装路径 <code>&lt;install-dir&gt;</code> 为 <code>$HOME/miniconda3/</code></p><p>终端输出忘记截图了，但是最后一步会问是否需要执行 <code>conda init</code> 要选择 yes</p><p>如果不选择 yes 但之后想要执行的话，则需要执行 <code>&lt;install-dir&gt;/bin/conda init</code></p></li></ol><h2 id="一些命令">一些命令</h2><h3 id="取消默认激活-base-环境">取消默认激活 base 环境</h3><p>安装完且首次执行 <code>conda init</code> 之后，打开终端都会默认激活 base 环境（即在命令提示符左边能看到 <code>(base)</code>），如果不想每次打开终端都要自动激活 base 环境，可以执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --<span class="built_in">set</span> auto_activate_base <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>这样下次打开终端就不会再自动激活 base 环境了。</p><h3 id="切换-python-版本">切换 Python 版本</h3><p>如果需要其他版本的 Python 环境，例如 Python 3.7，则先新建一个环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n py37 python=3.7</span><br></pre></td></tr></table></figure><p>这样 conda 就会自动下载在 Python 3.7 中版本最新（例如，3.7.9）的 Python 环境。</p><p>上述命令指定的版本可以细化为 3.7.0，3.7.1 等等。</p><p>下载完成之后，激活该环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate py37</span><br></pre></td></tr></table></figure><p>查看 Python 版本号：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python --version</span><br></pre></td></tr></table></figure><p><img data-src="/posts/715f63dd/image-20210204175611627.png" alt="image-20210204175611627" style="zoom:50%;"></p><p>这可以证明目前已经切换到对应的 Python 版本。另外也可以使用这个环境的 pip 去下载包了。</p><p>如果现在不需要使用这个 Python 环境了，可以取消激活：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda deactivate</span><br></pre></td></tr></table></figure><p>如果想查看所有可用的 Python 环境，可以列出所有可用环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda info --envs</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> conda </tag>
            
            <tag> Miniconda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git常用命令整理（持续更新）</title>
      <link href="posts/97940cff/"/>
      <url>posts/97940cff/</url>
      
        <content type="html"><![CDATA[<h2 id="基本操作命令">基本操作命令</h2><h3 id="git-add">Git add</h3><p>将新文件（或者对某个文件的修改、删除）加入到暂存区中。暂存区保存准备（尚未）提交到版本库的文件或对文件的修改。</p><a id="more"></a><h4 id="格式">格式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;file1&gt; &lt;file2&gt; ......</span><br></pre></td></tr></table></figure><p>其中的 <code>&lt;file1&gt;</code> 、<code>&lt;file2&gt;</code> 也可以是目录。也可以包含通配符。</p><h4 id="将当前目录中所有文件加入暂存区">将当前目录中所有文件加入暂存区</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><h3 id="git-branch">Git branch</h3><h4 id="查看所有分支">查看所有分支</h4><p>查看所有本地分支名称：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><p>查看所有本地分支名称和该分支的最新提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -v</span><br></pre></td></tr></table></figure><p>查看所有本地分支和远程分支的名称：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure><h4 id="创建新分支">创建新分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h4 id="删除分支">删除分支</h4><p>普通删除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><p>强制删除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h4 id="更改分支名称">更改分支名称</h4><p>更改当前分支名称：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><p>或（强制）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -M &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><p>更改指定分支名称：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m &lt;old-branch&gt; &lt;new-branch&gt;</span><br></pre></td></tr></table></figure><p>或（强制）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -M &lt;old-branch&gt; &lt;new-branch&gt;</span><br></pre></td></tr></table></figure><h3 id="git-clone">Git clone</h3><p>克隆一个远程仓库。</p><h4 id="克隆远程仓库默认分支">克隆远程仓库默认分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;repo-url&gt;</span><br></pre></td></tr></table></figure><h4 id="克隆远程仓库默认分支到指定路径">克隆远程仓库默认分支到指定路径</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;repo-url&gt; &lt;path&gt;</span><br></pre></td></tr></table></figure><h4 id="克隆远程仓库指定分支或tag">克隆远程仓库指定分支（或tag）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b &lt;repo-url&gt; &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h3 id="git-checkout">Git checkout</h3><h4 id="切换到某个分支">切换到某个分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h4 id="创建并切换到新分支">创建并切换到新分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h4 id="创建分支并关联已有的远程分支">创建分支并关联已有的远程分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;local-branch&gt; &lt;remote-repo&gt;/&lt;remote-branch&gt;</span><br></pre></td></tr></table></figure><h4 id="丢弃某个文件的更改">丢弃某个文件的更改</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- &lt;file-path&gt;</span><br></pre></td></tr></table></figure><h4 id="创建没有任何提交的空分支">创建没有任何提交的空分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout --orphan &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><blockquote><p>注意执行了此命令之后不要再切换到旧的分支，否则要想再切回去就得再重新创建一次</p><p>通过此种方式创建分支并不会删除已有文件</p></blockquote><h3 id="git-commit">Git commit</h3><h3 id="git-config">Git config</h3><p>解决Mac终端git中文文件名乱码（出现转义字符）问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.quotepath <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="git-fetch">Git fetch</h3><h3 id="git-init">Git init</h3><p>为该目录创建新的版本库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><h3 id="git-log">Git log</h3><p>查看该本地仓库当前分支的所有提交记录。</p><h4 id="基本格式">基本格式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><h4 id="单行输出">单行输出</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --pretty=oneline</span><br></pre></td></tr></table></figure><h4 id="输出所有提交记录及对应更改">输出所有提交记录及对应更改</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> -p</span><br></pre></td></tr></table></figure><h3 id="git-merge">Git merge</h3><h3 id="git-pull">Git pull</h3><h3 id="git-push">Git push</h3><h3 id="git-rebase">Git rebase</h3><h3 id="git-reflog">Git reflog</h3><p>查看在该本地仓库中执行命令的记录。</p><h3 id="git-remote">Git remote</h3><h4 id="关联新的远程仓库">关联新的远程仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add &lt;repo-name&gt; &lt;repo-url&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;repo-name&gt;</code>：远程仓库名称</p><p><code>&lt;repo-url&gt;</code>：远程仓库对应的URL</p><h4 id="查看所有远程仓库名称和链接">查看所有远程仓库名称和链接</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><h4 id="修改远程仓库url">修改远程仓库URL</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url &lt;repo-name&gt; &lt;repo-url&gt;</span><br></pre></td></tr></table></figure><h3 id="git-reset">Git reset</h3><h4 id="回退版本">回退版本</h4><p>soft模式：工作区的文件不变，将新提交的更改移动到暂存区，最后回到 <code>&lt;commit-id&gt;</code> 指定的提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft &lt;commit-id&gt;</span><br></pre></td></tr></table></figure><p>mix模式（默认）：工作区的文件不变，但是撤销新提交的更改（不移动到暂存区），最后回到 <code>&lt;commit-id&gt;</code> 指定的提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --mixed &lt;commit-id&gt;</span><br></pre></td></tr></table></figure><p>hard模式：撤销当前版本的更改（不移动到暂存区），最后回到 <code>&lt;commit-id&gt;</code> 指定的提交，将工作区的文件回复到 <code>&lt;commit-id&gt;</code> 指定的提交的状态上：（由于会变更工作目录的文件，所以<strong>慎用</strong>！！！）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard &lt;commit-id&gt;</span><br></pre></td></tr></table></figure><h3 id="git-revert">Git revert</h3><h3 id="git-rm">Git rm</h3><p>删除版本库中的文件。如果要删除整个目录需要加上 <code>-r</code> 选项。</p><h4 id="删除版本库中的文件同时从工作区中删除">删除版本库中的文件，同时从工作区中删除</h4><p>删除版本库（当前版本）中的某个文件（该文件一定要在当前版本中），同时将其从工作区中删除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm &lt;file1&gt; &lt;file2&gt; ......</span><br></pre></td></tr></table></figure><p>删除记录会添加到暂存区中，等待下一次提交。</p><p>此种情况跟直接使用 <code>rm</code> 命令删除的区别是：</p><ul><li>前者会将删除记录会添加到暂存区中（需先执行 <code>git reset HEAD &lt;file&gt;</code>来撤销暂存区的修改，再 <code>git checkout -- &lt;file&gt;</code> 即可恢复工作区的文件），后者不会（需要 <code>git add</code> ，只需执行 <code>git checkout -- &lt;file&gt;</code> 即可恢复工作区的文件）。</li><li>前者只能删除在版本库中或者只在暂存区中的文件。注意：如果该文件只是在暂存区中，不在版本库中，则需要加上 <code>-f</code> 选项删除。</li></ul><h4 id="删除版本库中的文件不从工作区中删除">删除版本库中的文件，不从工作区中删除</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached &lt;file1&gt; &lt;file2&gt; ......</span><br></pre></td></tr></table></figure><ul><li>如果该文件在版本库中，那就仅将文件从版本库（当前版本）中（或暂存区中）删除，不删除工作区的文件。删除记录会添加到暂存区中，等待下一次提交。</li><li>如果该文件只是在暂存区中，不在版本库中，则直接将其从暂存区中删除。</li></ul><p>换言之，就是取消版本库对该文件的跟踪。</p><h2 id="帮助命令">帮助命令</h2><p>'git help -a' and 'git help -g' list available subcommands and some</p><p>concept guides. See 'git help <command>' or 'git help <concept>'</concept></p><p>to read about a specific subcommand or concept.</p><p>See 'git help git' for an overview of the system.</p><h2 id="组合使用场景">组合使用场景</h2>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何解决GitHub不能上传大小超过100MB文件的问题</title>
      <link href="posts/b56b0da2/"/>
      <url>posts/b56b0da2/</url>
      
        <content type="html"><![CDATA[<h2 id="背景">背景</h2><p>使用 <code>git push</code> 将本地仓库分支推送到 GitHub 远程仓库的对应分支的时候，可能会出现以下问题：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">remote: error: File XXX is 102.79 MB; thie exceeds GitHub&#x27;s file size limit of 100.00 MB</span></span><br></pre></td></tr></table></figure><p>这表明 GitHub 默认不允许上传大小超过 100 MB 文件，但还是想上传应该如何解决？</p><a id="more"></a><h2 id="解决方案">解决方案</h2><p>此时就需要使用 Git LFS 了。Git LFS （Large File Storage） 是 GitHub 开发的 Git 扩展，用于 Git 传大型文件的。下载安装步骤自行百度。</p><p>如果要推送的分支仅仅是最新的提交包含了大文件（否则就没有下面的步骤这么简单了），可以通过以下步骤来重新提交：</p><ol type="1"><li><p>首先取消该大文件的版本控制：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached XXX</span><br></pre></td></tr></table></figure><p>如果是文件夹则是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached -r XXX</span><br></pre></td></tr></table></figure></li><li><p>将该大文件放入 LFS 中，此时会生成或修改 <code>.gitattributes</code> 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git lfs track XXX</span><br></pre></td></tr></table></figure></li><li><p>将该大文件和 <code>.gitattributes</code> 文件一并加入到暂存区中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .gitattributes XXX</span><br></pre></td></tr></table></figure></li><li><p>重新提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><p>之后再用刚才使用的 <code>git push</code> 命令重新推送分支即可。</p></li></ol><p>注意，Git LFS 有一个大坑，就是它可能并不是免费并且无限使用的。使用了 LFS 的文件会单独存放在 GitHub 的远程 LFS 存储服务器中，普通用户只能免费使用 1.5 GB LFS 存储空间（对于该用户的所有仓库而言），如果超出了这个限制需要每个月交至少 5 美元（对应50 GB）来扩大个人 LFS 容量。而且不同的代码托管平台有不同的收费标准。所以非必要情况下还是少用 LFS 或者不要上传过大的文件了。</p><figure><img data-src="/posts/b56b0da2/image-20210131124802085.png" alt><figcaption>image-20210131124802085</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> GitHub </tag>
            
            <tag> Git LFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】270. 最接近的二叉搜索树值</title>
      <link href="posts/2940454a/"/>
      <url>posts/2940454a/</url>
      
        <content type="html"><![CDATA[<p>题目链接：https://leetcode-cn.com/problems/closest-binary-search-tree-value/</p><p>这道题这么中规中矩我第一次也没写出来……</p><p>这是个会员题，所以就直接把题干贴在下面吧。</p><a id="more"></a><h2 id="题目原文">题目原文</h2><p>给定一个不为空的二叉搜索树和一个目标值 <code>target</code>，请在该二叉搜索树中找到最接近目标值 <code>target</code> 的数值。</p><p>注意：</p><ul><li>给定的目标值 <code>target</code> 是一个浮点数</li><li>题目保证在该二叉搜索树中只会存在一个最接近目标值的数</li></ul><p>示例：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [<span class="number">4,2,5,1</span>,<span class="number">3</span>]，目标值 target = <span class="number">3.714286</span></span><br><span class="line"></span><br><span class="line">    <span class="number">4</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">5</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">1</span>   <span class="number">3</span></span><br><span class="line"></span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></table></figure><h2 id="解法">解法</h2><h3 id="二叉搜索树节点的查找">二叉搜索树节点的查找</h3><p>可以根据二叉搜索树的性质（对于一个二叉搜索树，根节点左子树的所有节点的值总比根节点的值小，根节点右子树的所有节点的值总比根节点的值大）进行查找操作。</p><p>递归：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> closest;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findClose</span><span class="params">(TreeNode* root, <span class="keyword">double</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">            <span class="keyword">return</span> closest;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(target - root-&gt;val) &lt; <span class="built_in">fabs</span>(target - closest))</span><br><span class="line">            closest = root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; root-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> findClose(root-&gt;left, target);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> findClose(root-&gt;right, target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">closestValue</span><span class="params">(TreeNode* root, <span class="keyword">double</span> target)</span> </span>&#123;</span><br><span class="line">        closest = root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> findClose(root, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>非递归：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">closestValue</span><span class="params">(TreeNode* root, <span class="keyword">double</span> target)</span> </span>&#123;</span><br><span class="line">        TreeNode* curr = root;</span><br><span class="line">        <span class="keyword">int</span> closest = root-&gt;val;</span><br><span class="line">        <span class="keyword">while</span> (curr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(target - curr-&gt;val) &lt; <span class="built_in">fabs</span>(target - closest))</span><br><span class="line">                closest = curr-&gt;val;</span><br><span class="line">            <span class="keyword">if</span> (target &lt; curr-&gt;val)</span><br><span class="line">                curr = curr-&gt;left;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                curr = curr-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> closest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(H)\)</span></p><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p><h3 id="使用中序遍历">使用中序遍历</h3><p>对该二叉搜索树进行中序遍历得到递增有序序列（因为对于一个二叉搜索树，根节点左子树的所有节点的值总比根节点的值小，根节点右子树的所有节点的值总比根节点的值大），再对该序列进行查找。此方案不是最优方案。</p><p>设函数 <code>inorder()</code> 为中序遍历的函数，递归和非递归的形式分别如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left)</span><br><span class="line">    inorder(root-&gt;left, arr);</span><br><span class="line">    arr.push_back(root-&gt;val);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right)</span><br><span class="line">    inorder(root-&gt;right, arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; s;</span><br><span class="line">    TreeNode* curr = root;</span><br><span class="line">    <span class="keyword">while</span> (!s.empty() || curr)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">while</span> (curr)</span><br><span class="line">    &#123;</span><br><span class="line">    s.push_back(curr);</span><br><span class="line">    curr = curr-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    curr = s.back();</span><br><span class="line">    s.pop_back();</span><br><span class="line">    arr.push_back(curr-&gt;val);</span><br><span class="line">    curr = curr-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模版如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">closestValue</span><span class="params">(TreeNode* root, <span class="keyword">double</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        inorder(root, nums);</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (target &gt; nums[size - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> nums[size - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = size - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (target == nums[mid])</span><br><span class="line">                <span class="keyword">return</span> target;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">fabs</span>(target - nums[l]) &lt; <span class="built_in">fabs</span>(target - nums[r]) ? nums[l] : nums[r];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(n)\)</span></p><p>空间复杂度：<span class="math inline">\(O(n)\)</span></p><p>这里的二分查找也可以换成线性查找，最终总的时间复杂度级别也是相同的。</p><p>非递归版本也可以在遍历的过程中进行比较，节省存储中序序列的空间：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">closestValue</span><span class="params">(TreeNode* root, <span class="keyword">double</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        TreeNode* curr = root;</span><br><span class="line">        <span class="keyword">int</span> closest = root-&gt;val;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty() || curr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (curr)</span><br><span class="line">            &#123;</span><br><span class="line">                s.push_back(curr);</span><br><span class="line">                curr = curr-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = s.back();</span><br><span class="line">            s.pop_back();</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(target - curr-&gt;val) &lt; <span class="built_in">fabs</span>(target - closest))</span><br><span class="line">                closest = curr-&gt;val;</span><br><span class="line">            curr = curr-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> closest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(n)\)</span></p><p>空间复杂度：<span class="math inline">\(O(H)\)</span></p><p>参考官方题解，根据题意，最接近的值肯定夹在中序序列两个相邻元素之间，如果最接近的元素所在节点的深度远小于树的高度，据此可以在找到了最接近的值以后立即停止遍历：</p><p>其中 <code>pred</code> 表示中序序列中上一个元素的值，初始值一定要设成一个比较特殊的值（这是一个坑），否则当 <code>target</code> 小于中序序列最小值的时候返回的就是 <code>pred</code> 了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">closestValue</span><span class="params">(TreeNode* root, <span class="keyword">double</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        TreeNode* curr = root;</span><br><span class="line">        <span class="keyword">double</span> pred = INT64_MIN;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty() || curr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (curr)</span><br><span class="line">            &#123;</span><br><span class="line">                s.push_back(curr);</span><br><span class="line">                curr = curr-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = s.back();</span><br><span class="line">            s.pop_back();</span><br><span class="line">            <span class="comment">// 特判，表明 target 比中序序列的第一个值还小</span></span><br><span class="line">            <span class="keyword">if</span> (pred == INT64_MIN &amp;&amp; target &lt; curr-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> curr-&gt;val;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pred &lt;= target &amp;&amp; target &lt; curr-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">fabs</span>(target - pred) &lt; <span class="built_in">fabs</span>(target - curr-&gt;val) ? pred : curr-&gt;val;</span><br><span class="line">            pred = curr-&gt;val;</span><br><span class="line">            curr = curr-&gt;right;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> pred;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：平均情况下 <span class="math inline">\(O(k)\)</span>（在左子树），最坏的情况下是 <span class="math inline">\(O(H+k)\)</span>（在右子树），其中 <span class="math inline">\(k\)</span> 是最接近元素节点深度</p><p>空间复杂度：<span class="math inline">\(O(H)\)</span></p>]]></content>
      
      
      <categories>
          
          <category> 刷题 - LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个惨痛的经验教训</title>
      <link href="posts/90587fa3/"/>
      <url>posts/90587fa3/</url>
      
        <content type="html"><![CDATA[<p>这是因为一次“下手不够快”而错失良机的经验教训，特此记录，好给自己长个记性。</p><a id="more"></a><p>大概一周到两周前，导师给我发了一个“腾讯犀牛鸟精英工程人才培养计划”的链接，说如果我有兴趣就在实验室里面找两个人一起参加。我一看，这个项目一旦入选了会有很多福利：get访问腾讯的机会（相当于去实习了）、给自己的简历增加一笔有竞争力的工程项目经历……出于社交恐惧症、拖延症和总是不想打扰别人的原因，我问人的进度就一直很慢很慢。挨个问了实验室的几个大四和研一的同学，他们都拒绝了我，理由都是“觉得自己太菜了/这个项目申请要求太高了”“觉得没时间做”。看到1月28号才截止报名，我就慢慢地把这件事情放过去了。</p><p>结果这个活动在5天前，被发到了学院官网上，我们辅导员还在我们班群里面宣传这个活动。</p><p>直到今天我好不容易在实验室里面找到了想一起参加、也可以带我飞的大佬，然后下午商量了一下我们怎么准备这个活动。晚上跟导师说了想参加的意向之后，才知道在我们之前已经有2个队伍向学院申报了，学院的推荐名额已经满了，再报就只能3个队伍一起pk选出top 2了。</p><p>行吧，参加不了就参加不了了。导师给了我先下手为强的机会，却被我白白浪费掉了，失去了一次为自己简历镀金的机会。早知道应该直接在实验室大群里问，这样多快，不在群里直接问是出于可能有超过组队人数的人找我（现在看来是我想多了）。以后路还长着，这样的好机会多着呢。况且这两个队还不一定能入选呢。只是，我失去了一次被大佬带飞的机会，下个年度想参加这个必须得自己带飞别人了（恐怕我还没有这个机会）；为了3年以后能进大厂工作，以后能混口饭吃，我真的应该多抽点时间学学那些常用的技术栈了，自己给自己找工程项目做吧，<strong>为了能超过别人，一定要每天、每天、每天都花时间！！！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验教训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】242. 有效的字母异位词</title>
      <link href="posts/ee084660/"/>
      <url>posts/ee084660/</url>
      
        <content type="html"><![CDATA[<p>题目链接：https://leetcode-cn.com/problems/valid-anagram/</p><a id="more"></a><h2 id="排序">排序</h2><p>首先比较两个字符串的长度是否相等，不相等肯定不是有效的字母异位词（两个字符串出现的字符和字符对应的频数要一致）。如果长度相等，则用相同的方式对两个字符串进行排序，如果排序后的结果相等则为有效的字母异位词。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        sort(s.begin(), s.end());</span><br><span class="line">        sort(t.begin(), t.end());</span><br><span class="line">        <span class="keyword">return</span> s == t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(n\log n)\)</span></p><p>空间复杂度：<span class="math inline">\(O(1)\)</span>（忽略对排序算法底层的分析）</p><p><span class="math inline">\(n\)</span> 为两字符串长度相等时，<code>s</code> 或 <code>t</code> 字符串的长度</p><h2 id="哈希表">哈希表</h2><h3 id="假设字符串只包含小写字母">假设字符串只包含小写字母</h3><p>根据题意，可以假设字符串只包含小写英文字母。这样，定义整型数组 <code>m</code> 作为哈希表（长度为26，每个元素的初始值0）。 先遍历字符串 <code>s</code> ，统计字符串 <code>s</code> 字母出现频数（出现了就+1），再遍历统计字符串 <code>t</code> 字母出现频数（出现了就-1）。最后遍历整个数组 <code>m</code> ，如果有出现了不等于0的元素，则说明字符串 <code>s</code> 和 <code>t</code> 一定有其中一个多了字符或者少了字符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">            m[s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++)</span><br><span class="line">            m[t[i] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (m[i] != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也可以首先比较两个字符串的长度是否相等。如果字符串长度不相等肯定就不是字母异位词。然后统计字符串 <code>s</code> 字母出现频数（出现了就+1），再遍历统计字符串 <code>t</code> 字母出现频数（出现了就-1）。如果数组中记录有负值就不是有效的字母异位词（这是本方法的精髓，在作此判断的时候两字符串长度必定相等，如果不是有效的字母异位词哈希表中肯定会有负值记录：如果 <code>t</code> 中出现某字符的次数少于 <code>s</code> 中出现该字符的次数，那么 <code>t</code> 中必定有出现次数多于 <code>s</code> 中出现次数的字符或者 <code>s</code> 中未出现的字符，导致出现负值记录）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> m[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">            m[s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            m[t[i] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="keyword">if</span> (m[t[i] - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(n)\)</span></p><p>空间复杂度：<span class="math inline">\(O(1)\)</span>（这里哈希表的容量只有26，对应26个小写字母，容量不随字符串长度而变化，因此是常数）</p><h3 id="忽略字符串只包含小写字母的假设">忽略字符串只包含小写字母的假设</h3><p>假设字符串还包括除了小写英文字母之外的其他字符，就只能利用上节提到的第2个方法了。而且不能直接定义数组了。</p><p>首先还是比较两个字符串的长度是否相等。然后遍历字符串 <code>s</code> ，将 <code>s</code> 出现的字符及其频数加入到哈希表中。然后遍历字符串 <code>t</code> ，如果哈希表有对应字符的频数记录，则要将其减1；如果没有则往哈希表中插入该字符，频数记录为-1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length()) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">            m[s[i]]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            m[t[i]]--;</span><br><span class="line">            <span class="keyword">if</span> (m[t[i]] &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(n)\)</span></p><p>空间复杂度：<span class="math inline">\(O(n)\)</span>（字符串 <code>s</code> 或 <code>t</code> 没有重复字符）</p>]]></content>
      
      
      <categories>
          
          <category> 刷题 - LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】两个数组的交集</title>
      <link href="posts/3db81c36/"/>
      <url>posts/3db81c36/</url>
      
        <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/" class="uri">https://leetcode-cn.com/problems/intersection-of-two-arrays/</a>、<a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/" class="uri">https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/</a></p><a id="more"></a><h2 id="两个数组的交集">349 两个数组的交集</h2><h3 id="我的垃圾代码">我的垃圾代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">intersection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m1, m2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.size(); i++)</span><br><span class="line">            m1[nums1[i]]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums2.size(); i++)</span><br><span class="line">            m2[nums2[i]]++;</span><br><span class="line">        <span class="keyword">if</span> (m1.size() &lt; m2.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator i = m1.begin(); i != m1.end(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i-&gt;second &gt;= <span class="number">1</span> &amp;&amp; m2.find(i-&gt;first) != m2.end() &amp;&amp; m2[i-&gt;first] &gt;= <span class="number">1</span>)</span><br><span class="line">                    result.push_back(i-&gt;first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator i = m2.begin(); i != m2.end(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i-&gt;second &gt;= <span class="number">1</span> &amp;&amp; m1.find(i-&gt;first) != m1.end() &amp;&amp; m1[i-&gt;first] &gt;= <span class="number">1</span>)</span><br><span class="line">                    result.push_back(i-&gt;first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="两个集合">两个集合</h3><p>为了达到题干中需要将结果去重的要求，准备两个集合 <code>s1</code> 、<code>s2</code>。首先将 <code>nums1</code> 中的元素加入到集合 <code>s1</code> 中，再将 <code>nums2</code> 和 <code>nums1</code> 共有的元素加入到集合 <code>s2</code> 中。<code>s2</code> 即为要求的交集。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">intersection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s1, s2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.size(); i++)</span><br><span class="line">            s1.insert(nums1[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums2.size(); i++)</span><br><span class="line">            <span class="keyword">if</span> (s1.find(nums2[i]) != s1.end())</span><br><span class="line">                s2.insert(nums2[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator i = s2.begin(); i != s2.end(); i++)</span><br><span class="line">            result.push_back(*i);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(m+n)\)</span></p><p>空间复杂度：<span class="math inline">\(O(m+n)\)</span>（需要额外的集合空间来存储去重后的结果，不超过 <span class="math inline">\(O(m+n)\)</span>）</p><p><span class="math inline">\(m\)</span>、<span class="math inline">\(n\)</span> 分别为 <code>nums1</code>、 <code>nums2</code> 的长度</p><h3 id="双指针">双指针</h3><p>首先将 <code>nums1</code> 、 <code>nums2</code> 排序。为了达到题干去重的要求，需要一个集合 <code>s</code> 存放结果。设置两个指针 <code>i</code> 、 <code>j</code> 分别指向 <code>nums1</code> 、 <code>nums2</code> 的起始位置，遍历两个数组：如果两个指针指向的元素值相等，就将该值加入到集合 <code>s</code> 中，然后 <code>i</code> 、 <code>j</code> 分别加一；如果不相等，哪个指针指向的元素小，哪个指针就加一。只要一个指针到达数组的末尾就停止遍历。<code>s</code> 即为要求的交集。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">intersection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        sort(nums1.begin(), nums1.end());</span><br><span class="line">        sort(nums2.begin(), nums2.end());</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums1.size() &amp;&amp; j &lt; nums2.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i] == nums2[j])</span><br><span class="line">            &#123;</span><br><span class="line">                s.insert(nums1[i]);</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &lt; nums2[j])</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator i1 = s.begin(); i1 != s.end(); i1++)</span><br><span class="line">            result.push_back(*i1);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(m\log m+n\log n)\)</span> （排序占用主要的时间）</p><p>空间复杂度：<span class="math inline">\(O(m+n)\)</span>（需要额外的集合空间来存储去重后的结果，不超过 <span class="math inline">\(O(m+n)\)</span>）</p><h4 id="二刷补充不用额外set集合的方法">（二刷补充）不用额外set集合的方法</h4><p>如果两个指针指向的元素值相等，只需要判断该值是否等于结果的最后一个元素，相等就加入到结果中，然后 <code>i</code> 、 <code>j</code> 分别加一</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">intersection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        sort(nums1.begin(), nums1.end());</span><br><span class="line">        sort(nums2.begin(), nums2.end());</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums1.size() &amp;&amp; j &lt; nums2.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i] == nums2[j]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!result.size() || result[result.size() - <span class="number">1</span>] != nums1[i])</span><br><span class="line">                    result.push_back(nums1[i]);</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &lt; nums2[j])</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(m\log m+n\log n)\)</span> （排序占用主要的时间）</p><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p><h3 id="二分查找">二分查找</h3><p>有点牵强，其实就是遍历其中一个数组，对另一个数组先排序再使用二分查找元素，如果对应的元素找到了就放入集合中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">intersection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        sort(nums2.begin(), nums2.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> target = binarySearch(nums2, nums1[i]);</span><br><span class="line">            <span class="keyword">if</span> (target &gt;= <span class="number">0</span>)</span><br><span class="line">                s.insert(nums1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator i1 = s.begin(); i1 != s.end(); i1++)</span><br><span class="line">            result.push_back(*i1);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(m\log m + n\log n)\)</span>（需要对其中一个数组排序，遍历另一个数组时，需要对每个元素进行二分查找，二分查找时间复杂度为 <span class="math inline">\(O(\log n)\)</span>（此时 <span class="math inline">\(n\)</span> 为数组长度））</p><p>空间复杂度：<span class="math inline">\(O(m+n)\)</span>（需要额外的集合空间来存储去重后的结果，不超过 <span class="math inline">\(O(m+n)\)</span>）</p><p>原来不想思考这个方法的，但是题目居然给了这个标签……</p><h2 id="两个数组的交集2">350 两个数组的交集2</h2><p>这一题比上一题多了一个要求就是输出结果中每个元素出现的次数应与元素在两个数组中出现次数的<strong>最小值</strong>一致。</p><h3 id="双指针-1">双指针</h3><p>和上题一样，只是不需要用集合去重而已：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">intersect</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        sort(nums1.begin(), nums1.end());</span><br><span class="line">        sort(nums2.begin(), nums2.end());</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums1.size() &amp;&amp; j &lt; nums2.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i] == nums2[j])</span><br><span class="line">            &#123;</span><br><span class="line">                result.push_back(nums1[i]);</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &lt; nums2[j])</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(m\log m+n\log n)\)</span></p><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p><h3 id="哈希表">哈希表</h3><p>用一个哈希表，遍历其中一个数组，在哈希表中记录各个元素出现的次数。为了达到题目要求“出现次数为两个数组中出现次数最小值”的要求，在遍历第二个数组的时候，如果哈希表中存在这个元素的记录，就将该元素插入到结果中（注意，为了达到题目要求“出现次数为两个数组中出现次数最小值”，每次都需要将哈希表中对应的记录减1，减到0就不再往结果插入该元素）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">intersect</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1.size() &gt; nums2.size())</span><br><span class="line">            <span class="keyword">return</span> intersect(nums2, nums1);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.size(); i++)</span><br><span class="line">            m[nums1[i]]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums2.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m.find(nums2[i]) != m.end())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> count = m[nums2[i]];</span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    result.push_back(nums2[i]);</span><br><span class="line">                    m[nums2[i]]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(m+n)\)</span>（需要遍历两个数组，一次是往哈希表中插入，一次是查询哈希表，哈希表查询时间复杂度为<span class="math inline">\(O(1)\)</span>）</p><p>空间复杂度：<span class="math inline">\(O(min(m,n))\)</span></p><p>之前还写了一个用两个哈希表的算法（然后比较元素出现的次数，取最小），果真是太菜了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">intersect</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m1, m2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.size(); i++)</span><br><span class="line">            m1[nums1[i]]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums2.size(); i++)</span><br><span class="line">            m2[nums2[i]]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator i = m2.begin(); i != m2.end(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i-&gt;second &gt;= <span class="number">1</span> &amp;&amp; m1.find(i-&gt;first) != m1.end() &amp;&amp; m1[i-&gt;first] &gt;= <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> minCount = min(i-&gt;second, m1[i-&gt;first]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; minCount; j++)</span><br><span class="line">                    result.push_back(i-&gt;first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="三个问题">三个问题</h3><ul><li>如果给定的数组已经排好序呢？你将如何优化你的算法？<ul><li>应使用双指针法（去掉前面的排序步骤），此时时间复杂度为 <span class="math inline">\(O(m+n)\)</span></li></ul></li><li>如果 <code>nums1</code> 的大小比 <code>nums2</code> 小很多，哪种方法更优？（注意这里的大小是指数组长度，也没说是否已经排序）<ul><li>哈希表法</li><li>假设 <span class="math inline">\(m &lt;&lt; n\)</span>，那么使用哈希表法时间复杂度接近 <span class="math inline">\(O(n)\)</span>，空间复杂度接近 <span class="math inline">\(O(1)\)</span>；而使用双指针法时间复杂度接近 <span class="math inline">\(O(n\log n)\)</span></li></ul></li><li>如果 <code>nums2</code> 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？<ul><li>在内存有限的情况下应使用双指针法（空间复杂度 <span class="math inline">\(O(1)\)</span>），排序算法需要用外部排序（例如：归并排序）</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】383. 赎金信</title>
      <link href="posts/d4af32e4/"/>
      <url>posts/d4af32e4/</url>
      
        <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/ransom-note/" class="uri">https://leetcode-cn.com/problems/ransom-note/</a></p><a id="more"></a><p>这道题关键在于题意理解，返回 <code>true</code> 的条件即 <code>ransom</code> 字符串中出现的该字符数量不能大于 <code>magazine</code> 字符串中出现的该字符的数量。（起初看到给的示例还以为是判断 <code>ransom</code> 是不是 <code>magazine</code>的子串，但是看到了括号里面的题目说明才觉得可能是想错了）</p><p>所以就用了两个哈希表来统计两个字符串出现字符的数量再分别对比：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canConstruct</span><span class="params">(<span class="built_in">string</span> ransomNote, <span class="built_in">string</span> magazine)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m1, m2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; magazine.length(); i++)</span><br><span class="line">            m1[magazine[i]]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ransomNote.length(); i++)</span><br><span class="line">            m2[ransomNote[i]]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator i = m2.begin(); i != m2.end(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m1.find(i-&gt;first) == m1.end() || m1[i-&gt;first] &lt; i-&gt;second)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>更省空间的方法（我怎么就没有想到呢，我好菜）：</p><p>其实就是类似<a href="https://leetcode-cn.com/problems/valid-anagram/">242题</a>的方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canConstruct</span><span class="params">(<span class="built_in">string</span> ransomNote, <span class="built_in">string</span> magazine)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; magazine.length(); i++)</span><br><span class="line">            m[magazine[i]]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ransomNote.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            m[ransomNote[i]]--;</span><br><span class="line">            <span class="keyword">if</span> (m[ransomNote[i]] &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然，二刷很快就A了。</p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】125. 验证回文串 &amp; 345. 反转字符串中的元音字母</title>
      <link href="posts/c52b8313/"/>
      <url>posts/c52b8313/</url>
      
        <content type="html"><![CDATA[<p>这次依然是两道简单题，嗯，又水了一天……</p><a id="more"></a><h2 id="验证回文串">125. 验证回文串</h2><p>题目链接：https://leetcode-cn.com/problems/valid-palindrome/</p><p>一看到这道题就知道又是熟悉的判断回文串的算法，只是这里的回文串需要忽略除了字母和数字以外的其他字符，也不区分大小写。</p><p>可以先对字符串进行预处理，然后判断回文串可以使用一对对撞指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = s.length();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> s1;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i]) || <span class="built_in">isalpha</span>(s[i]))</span><br><span class="line">                s1.push_back(<span class="built_in">tolower</span>(s[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        size = s1.length();</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        j = size - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; i &lt; size &amp;&amp; j &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1[i] != s1[j])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间、空间复杂度均为 <span class="math inline">\(O(n)\)</span>，<span class="math inline">\(n\)</span> 为字符串 <span class="math inline">\(s\)</span> 的长度。</p><p>事实上并不需要做预处理，只需要在判断回文串时手动忽略掉无关字符即可：（可以使空间复杂度降至 <span class="math inline">\(O(1)\)</span>）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = s.length(), i = <span class="number">0</span>, j = size - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; i &lt; size &amp;&amp; j &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isalnum</span>(s[i]))</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">isalnum</span>(s[j]))</span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">tolower</span>(s[i]) != <span class="built_in">tolower</span>(s[j]))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="反转字符串中的元音字母">345. 反转字符串中的元音字母</h2><p>题目链接：https://leetcode-cn.com/problems/reverse-vowels-of-a-string/</p><p>和上一题一样，这次的无关字符是非元音字母（即a、e、i、o、u以外的字母），反转字符串和判断回文串不同的是前者要交换当前两字符位置，后者判断当前两字符是否相等（否则不是回文串）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isVowel</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        c = <span class="built_in">tolower</span>(c);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;a&#x27;</span> || c == <span class="string">&#x27;e&#x27;</span> || c == <span class="string">&#x27;i&#x27;</span> || c == <span class="string">&#x27;o&#x27;</span> || c == <span class="string">&#x27;u&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseVowels</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = s.length(), i = <span class="number">0</span>, j = size - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; i &lt; size &amp;&amp; j &gt;= <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isVowel(s[i]))</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!isVowel(s[j]))</span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                swap(s[i++], s[j--]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为 <span class="math inline">\(O(n)\)</span>（<span class="math inline">\(n\)</span> 为字符串 <span class="math inline">\(s\)</span> 的长度），空间复杂度为 <span class="math inline">\(O(1)\)</span>。</p><h2 id="额外收获">额外收获</h2><p>这次从题解里面 get 了一个判断字符是字母或数字的库函数 <code>isalnum()</code> （头文件 <code>cctype</code>），顺便复习了回文串判断和字符串反转的算法（虽然算法从大一以来就记得烂熟，但是没有想到可以使用两个对撞指针解决，还可以无视无关字符）</p>]]></content>
      
      
      <categories>
          
          <category> 刷题 - LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】696. 计数二进制子串</title>
      <link href="posts/465fd6ee/"/>
      <url>posts/465fd6ee/</url>
      
        <content type="html"><![CDATA[<p>题目链接：https://leetcode-cn.com/problems/count-binary-substrings/</p><a id="more"></a><h2 id="v1.0">v1.0</h2><p>起初认为这个题的描述类似于括号匹配问题的变种，于是就维护了两个栈（<code>v0</code>、<code>v1</code>），用来存储未被右边字符匹配的字符的位置，<code>v0</code>、<code>v1</code>一个存0的位置，一个存1的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countBinarySubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = s.length(), count = <span class="number">0</span>, prev = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1, v0;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果前一段连续的1有未被匹配的字符</span></span><br><span class="line">                <span class="keyword">if</span> (v1.size())</span><br><span class="line">                &#123;</span><br><span class="line">                    v1.pop_back();</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果前一段连续的1之前还有0未被匹配，则这些0永远不会被匹配，因此需要将栈清空</span></span><br><span class="line">                <span class="keyword">if</span> (prev != <span class="number">0</span>)</span><br><span class="line">                    v0.clear();</span><br><span class="line">                v0.push_back(i); <span class="comment">// 当前字符未被右边字符匹配，因此需要入栈</span></span><br><span class="line">                prev = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 同理</span></span><br><span class="line">                <span class="keyword">if</span> (v0.size())</span><br><span class="line">                &#123;</span><br><span class="line">                    v0.pop_back();</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (prev != <span class="number">1</span>)</span><br><span class="line">                    v1.clear();</span><br><span class="line">                v1.push_back(i);</span><br><span class="line">                prev = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>变量 <code>prev</code> 用于在遍历 <code>s</code> 的时候记录 <code>i - 1</code> 位置的字符。之前没有注意到有的0或1肯定不会被匹配的情况，就没有做是否需要将栈清空的判断，因此就失败了。</p><h2 id="v2.0-v3.0">v2.0 &amp; v3.0</h2><p>参考了官方题解的做法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countBinarySubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = s.length(), first = <span class="number">0</span>, end = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || i == size || s[i] != s[i - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">                    nums.push_back(end - first);</span><br><span class="line">                first = end = i;</span><br><span class="line">            &#125;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += min(nums[i], nums[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 <code>v2.0</code> 中，需要先遍历一次字符串 <code>s</code> 将连续0或1的个数记录到 <code>nums</code> 数组中，然后再遍历 <code>nums</code> 数组来计算符合条件的子串个数。然而可以发现，在第二次循环中，计算符合条件的子串个数时也只用到了上一个连续0或1的个数。因此，完全可以不用 <code>nums</code> 数组，只需要遍历一次字符串 <code>s</code> ，使用一个变量 <code>count</code> 记录上一个连续0或1的个数即可（<code>v3.0</code>）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countBinarySubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = s.length(), first = <span class="number">0</span>, end = <span class="number">0</span>, sum = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || i == size || s[i] != s[i - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                sum += min(count, end - first);</span><br><span class="line">                count = end - first;</span><br><span class="line">                first = end = i;</span><br><span class="line">            &#125;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 - LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【刷题记录】LeetCode 1：两数之和</title>
      <link href="posts/502147dd/"/>
      <url>posts/502147dd/</url>
      
        <content type="html"><![CDATA[<p>本菜鸡已经很久没有正经地刷过算法题了。今天先拿LeetCode的第1道最简单的题热身一下。</p><p>这不能算是题解，只能算是刷题心得吧。</p><a id="more"></a><h2 id="题目原文">题目原文</h2><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p>示例:</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = <span class="comment">[2, 7, 11, 15]</span>, target = 9</span><br><span class="line"></span><br><span class="line">因为 nums<span class="comment">[0]</span> + nums<span class="comment">[1]</span> = 2 + 7 = 9</span><br><span class="line">所以返回 <span class="comment">[0, 1]</span></span><br></pre></td></tr></table></figure><h2 id="解法">解法</h2><p>最容易想到的办法就是暴力求解，也是本渣唯一能想到的办法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.size(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target)</span><br><span class="line">                &#123;</span><br><span class="line">                    result.push_back(i);</span><br><span class="line">                    result.push_back(j);</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看了题解之后才知道可以用哈希表来做，哈希表可以让查找的时间复杂度从<span class="math inline">\(O(n)\)</span>降到大约为<span class="math inline">\(O(1)\)</span>（可能会有碰撞，这会提高时间复杂度）的量级。对应于C++的数据结构就是<code>unordered_map</code>。由于<code>nums</code>的下标都要插入到哈希表中，因此空间复杂度从<span class="math inline">\(O(1)\)</span>变为了<span class="math inline">\(O(n)\)</span>，也就是空间换时间。</p><p>根据提示，我能想到的方式就是先遍历一遍数组<code>nums</code>，然后把数组<code>nums</code>的元素先加入到哈希表中；然后再遍历一遍<code>nums</code>，以<code>target-nums[i]</code>为键查找哈希表：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(nums[i], i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator j = m.find(target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (j != m.end() &amp;&amp; j-&gt;second != i)</span><br><span class="line">            &#123;</span><br><span class="line">                result.push_back(i);</span><br><span class="line">                result.push_back(j-&gt;second);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我没想到还有一个效率更高的方法就是在遍历<code>nums</code>的过程中就查找哈希表，然后查找完之后将<code>nums</code>当前的元素插入到哈希表中国呢这样就只需要遍历一次<code>nums</code>数组了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator j = m.find(target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (j != m.end() &amp;&amp; j-&gt;second != i)</span><br><span class="line">            &#123;</span><br><span class="line">                result.push_back(j-&gt;second);</span><br><span class="line">                result.push_back(i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(nums[i], i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于哈希表内的值为数值在<code>nums</code>中对应的下标，因此要查找的哈希表中的下标值一定比当前的下标要小，为了保证顺序，插入到结果数组的顺序需要颠倒一下。</p><p>使用了哈希表之后，程序运行时间确实显著地下降了：</p><p><img data-src="/posts/502147dd/Snipaste_2020-07-15_22-53-01.png" style="zoom:50%;"></p><p>看来还是要多学习。</p><h2 id="重复值的情况">重复值的情况</h2><p>题解中有一个评论的问题很耐人寻味：就是<code>nums</code>为<code>[2, 2, 3, 4, 5]</code>的情形（<code>nums</code>里面有重复的元素）。</p><p>事实上哈希表的做法是会过滤掉重复的<code>nums</code>值的，即由于键<code>nums[0]</code>对应的值已经存在，<code>nums[1]</code>会被过滤掉，从而下标1并不在哈希表中。</p><p>最特殊的情况就是当<code>target</code>为4的情况，两次遍历<code>nums</code>输出的结果为<code>[1, 0]</code>，一次遍历<code>nums</code>输出的结果为<code>[0, 1]</code>。因此在不care结果顺序的情况下，这两种方法都是可行的（顺序不影响判题）。</p><p>还有，如果<code>target</code>在<code>nums</code>中含有多个解的时候，哈希表的做法只会出现第一组解（即一旦找到结果就返回），而我原来写的暴力解法可以包含多个解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.size(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target)</span><br><span class="line">                &#123;</span><br><span class="line">                    result.push_back(i);</span><br><span class="line">                    result.push_back(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是如果在<code>if</code>分支中加上了<code>return result;</code>之后，结果就和使用哈希表的结果一致了。</p><p>因此从题意上看这道题并不是一道严谨的题：因为题目中并未交代<code>nums</code>中不能包含重复值以及结果只有出现的第一组解，但是这两点却被默认了。所以我认为这两点应该在题目中交代一下。不过这毕竟是最简单的一道题，我觉得也不用过于钻牛角尖。就当作是热身以及复习哈希表的性质及对应数据结构的用法即可。</p><p>同时我也学习到的一点是C++的<code>map</code>有两种插入方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>.insert(&#123;key, value&#125;);</span><br><span class="line"><span class="built_in">map</span>[kay] = value;</span><br></pre></td></tr></table></figure><p>对于同一个<code>key</code>不同的<code>value</code>，前者是忽略后插入的值（这个和Java的<code>Map</code>的<code>put()</code>方法一致），后者是后插入的值覆盖前面插入的值。</p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020暑假flags</title>
      <link href="posts/840c464e/"/>
      <url>posts/840c464e/</url>
      
        <content type="html"><![CDATA[<p>可能是大学以来最长而且事最多的暑假已经过了一周多了，已经回归到了只要不上网课没作业就睡觉的状态了……这样可不行，别再睡了好吗……瞧瞧比自己优秀的人都还在努力呢。</p><a id="more"></a><h2 id="一定要做的事">一定要做的事</h2><ul class="task-list"><li><input type="checkbox" disabled>目前最大的事情就是要尽可能努力拿到本校保研资格，今年由于疫情所有大佬内卷太严重了……而且也取消机试了，自己也没什么加分，所以线上面试就是重中之重了……<ul class="task-list"><li><input type="checkbox" disabled>好好准备英文自我介绍！</li><li><input type="checkbox" disabled>好好练英语口语！</li><li><input type="checkbox" disabled>多准备几个面试可能会问到的问题</li><li><input type="checkbox" disabled>做点科研准备工作，尽可能提前适应研究生生活<del>，也是为了在最终面试时有话说</del></li></ul></li><li><input type="checkbox" disabled>减肥……在这个以瘦为美的社会，稍微胖点都没有生存空间，别人都是用异样的眼光看自己<ul class="task-list"><li><input type="checkbox" disabled checked>少吃零食以及其他垃圾食品</li><li><input type="checkbox" disabled>硬着头皮也得把训练营的课程学完（0/28）</li></ul></li><li><input type="checkbox" disabled>熟悉新的Mac电脑<ul class="task-list"><li><input type="checkbox" disabled checked>博客站点迁移</li><li><input type="checkbox" disabled>把常用软件和虚拟机装好</li></ul></li><li><input type="checkbox" disabled>整理三年来所有学习资料和代码，把自己的学习笔记放在博客上</li><li><input type="checkbox" disabled>刷leetcode的题目，虽然没有机试了……</li></ul><h2 id="想想就行了">想想就行了</h2><p>我觉得我肯定没有精力准备，那想想就行了吧……</p><ul class="task-list"><li><input type="checkbox" disabled>把自己看过的所有美食都做一遍</li><li><input type="checkbox" disabled>关注考研或工作的动态（也不指望自己能同时准备了……）</li><li><input type="checkbox" disabled>准备给自己的博客换个主题，最近看到butterfly主题挺漂亮的，准备抽时间安排上，但这也不是现在要考虑的事情……</li></ul>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flags </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何将hexo博客站点迁移到其他电脑上</title>
      <link href="posts/e7168358/"/>
      <url>posts/e7168358/</url>
      
        <content type="html"><![CDATA[<p>我们原先在自己的旧电脑上建立了自己的博客站点，但是换了新电脑怎么办呢？总不能重新建立一个新站点吧，这样多麻烦啊……</p><p>这个问题其实一开始搭建博客的时候就想到了，但是嫌麻烦就没有学习这个问题该如何解决。直到现在真换了电脑才开始付诸实施，结果发现坑还是挺多的……</p><a id="more"></a><h2 id="在新电脑上安装必要软件">在新电脑上安装必要软件</h2><ul><li>git</li><li>Node.js</li><li>Hexo</li></ul><p>可以参考网上的教程安装git和Node.js。在安装了Node.js的情况下，安装Hexo可以通过如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><h2 id="备份必要的文件">备份必要的文件</h2><p>假设旧电脑的博客目录为<code>blog/hexo/</code>。那么最简单的方式是直接将以下文件拷贝到新电脑的对应目录中（最少应拷贝以下文件）：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_config.yml</span><br><span class="line"><span class="keyword">package</span>.json</span><br><span class="line">scaffolds/</span><br><span class="line"><span class="keyword">source</span>/</span><br><span class="line">themes/</span><br></pre></td></tr></table></figure><p>如果会用git的话可以将旧电脑的<code>blog/hexo/</code>目录作为本地仓库，并将本地仓库的内容<code>push</code>到自己的远程私有仓库中，这样在新电脑中就可以通过以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> 自己的博客站点对应的远程私有仓库地址</span><br></pre></td></tr></table></figure><p>快速将博客站点的文件拷贝到新电脑上。</p><p>需要注意如果旧电脑的<code>blog/hexo</code>目录没有<code>.gitignore</code>文件的话需要手动添加一下，内容如下：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.DS_Store</span></span><br><span class="line">Thumbs<span class="number">.</span><span class="built_in">db</span></span><br><span class="line"><span class="built_in">db</span><span class="number">.</span>json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line"><span class="meta">public</span>/</span><br><span class="line"><span class="meta">.deploy</span>*/</span><br></pre></td></tr></table></figure><h2 id="一些踩坑记录">一些踩坑记录</h2><p>不需要拷贝<code>node_modules/</code>目录以及<code>package-lock.json</code>的原因是可以通过</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo --save</span><br></pre></td></tr></table></figure><p>来下载<code>package.json</code>中指定的依赖包到新创建的<code>node_modules/</code>目录中，并自动创建<code>package-lock.json</code>。</p><p>注意，如果原先选择的markdown渲染器是<code>hexo-renderer-pandoc</code>，需要先安装Pandoc（或者安装会提供Pandoc的软件，例如Anaconda），安装Pandoc可以参考<a href="https://pandoc.org/installing.html">该链接</a>提供的方法。否则会出现如下图所示的错误：</p><p><img data-src="/posts/e7168358/Snipaste_2020-07-06_23-21-28.png" style="zoom:50%;"></p><p>另外，在使用命令<code>hexo g</code>生成静态博客文件之后，使用命令<code>hexo s</code>在本地查看博客页面的效果，显示的页面居然是空白的，然后看到终端中的如下提示：</p><p><img data-src="/posts/e7168358/Snipaste_2020-07-07_03-26-00.png" style="zoom:50%;"></p><p>由于我最初是将博客站点文件备份到GitHub私有仓库中的，然后通过<code>git clone</code>将这个远程库给克隆下来，从而下载了博客站点文件。由于我最初在下载自定义主题的时候也是使用<code>git clone</code>将主题文件下载到<code>blog/hexo/themes/</code>中的（实际上是克隆了远程库），因此<code>blog/hexo/</code>就嵌套了别的仓库，这就涉及到了git的子模块（<code>submodule</code>），而之前我也并没有将旧电脑中的这些自定义主题文件（<code>blog/hexo/themes/*/</code>）加入到子模块中，导致这些主题文件并没有<code>push</code>到自己的私有仓库中，<code>git clone</code>下来的目录<code>blog/hexo/themes/*/</code>是空白的，导致显示的页面也是空白的。因此我就只能重新从旧电脑中拷贝一份主题文件了，最终问题解决（当然在下次<code>push</code>整个博客站点之前也可以先删掉目录<code>blog/hexo/themes/*/</code>下的<code>.git/</code>文件夹，让子仓库不再被git管理）。所以说如果git用得不熟练的话还是拷贝文件的老办法最靠谱。</p><p>所以说以后还是要深入学习git的使用……</p><p>好不容易可以查看网页效果了，想部署一下网站，又出现了下面的问题（绝望.jpg）：</p><p><img data-src="/posts/e7168358/Snipaste_2020-07-08_00-22-03.png" style="zoom:50%;"></p><p>差点都绝望到想重新搭建网站了，结果一查才发现Hexo低版本和Node.js v14+的版本不兼容。我的Hexo版本为v3.9.0，而我的Node.js版本为v14.5.0。不知道切换Hexo版本为最新版本又会有什么坑，因此我选择了直接覆盖安装Node.js的v12.18.2版本，问题成功解决。所幸这个问题有人通过Google解决了，以后我也要学着多用Google……</p><h2 id="references">References</h2><ul><li><a href="https://blog.csdn.net/lvonve/article/details/79587321">换了电脑如何使用hexo继续写博客</a></li><li><a href="https://blog.csdn.net/wxl1555/article/details/79293159">hexo系列问题之我们换了电脑怎么办</a></li><li><a href="https://evestorm.github.io/posts/430/">node14+版本下hexo部署失败 | EVE</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我回来了</title>
      <link href="posts/a5aedc5a/"/>
      <url>posts/a5aedc5a/</url>
      
        <content type="html"><![CDATA[<p>鸽了差不多一年，我总算想起了自己去年搭建过的博客，还是自己写保研简历的时候想起来的，自己是一个相当没有执行力的人了。这一年并没有更新博客的动力，一个原因是自己真的写不出什么技术文；另一个原因是学业繁忙，大三这一年的课程虽然看起来还没有大二的多但是真的快把我压死了，尤其是组队作业……</p><p>这次的主要工作是将上一台电脑中Windows系统中的博客站点迁移到新的Mac上。</p><p>既然回来了，以后我就尽量多写博客<del>，毕竟简历上就摆着这个博客，不更新怎么行呢</del>。只是不强迫自己一定要更新技术文了。</p><p>另外今天是高考的日子，祝所有学弟学妹们都能好好发挥，考上一所好大学，选到一个好专业<del>，去过比准备高考辛苦得多的大学生活</del>。</p><a id="more"></a><h2 id="为什么这么早就换电脑">为什么这么早就换电脑</h2><p>我之前用的那台电脑其实也是MacBook pro，只是配置低而已。然后由于不适应Mac OS，所以就通过Boot Camp装了Windows 10双系统，然后把大部分硬盘空间分给了这个Windows系统，之后基本上用的也是这个Windows系统。</p><p>起因是今年5月初，劳动节的时候。为了在PA实验中跑出仙剑，我这两三天都在肝这个PA3，电脑这两三天都处于满负荷状态。结果好不容易在NEMU中跑出仙剑了，电脑屏幕底部又出现了几条黑色的条纹，重启也有，我最初还天真的以为是这个仙剑把电脑屏幕烧坏了。结果查了百度才知道这是Macbook的通病，就是用了两年左右时间（而且是刚过保没多久）就可能会出现类似的问题，属于品控问题。而且是这个不一定只会出现在屏幕底部，有可能也会出现在顶部，连续用的时间越久这个问题就会越严重，最终导致整个屏幕都会花掉，还会出现残影，如果合上盖子静置一段时间就没有这个问题了（或者没这么严重了），但是再用一段时间又会出现。而导致这个问题的原因是苹果把散热的部分集中在了屏幕转轴处（而且还连着排线，排线又连着屏幕），而转轴部分总是热的可能就会把排线烧了。当时的第一反应就是Macbook又贵质量又差，下一次绝对不再买Macbook。</p><p>然而过几天，MacBook pro上新了，不仅同样硬盘大小的价格相比往年的款减了，而且键盘也终于不再用那个蝶式键盘了，又考虑到其实使用MacBook的体验真的挺不错的（即使是用Windows系统），如果换了Windows的电脑我反而还会觉得体验变差了很多。最后就是真香，又换了今年的新款MacBook pro，只是买了配置更高的，并且决定以后不再装Windows双系统，好好体验这个Mac OS。</p><p>其实要是不出这个问题的话，应该到本科毕业才会换电脑。</p><p>至于上次这个问题解决得怎么样了，我选择了让电脑休息两天，自己好好放劳动节的假，然后花了一百多块买了一个散热器，准备在之后的一个多月靠散热器来给电脑续命（毕竟在新的电脑上重新配环境真的非常麻烦，还浪费大量写作业的时间）。最终的结果是起初散热器的效果特别好，电脑不再过热了，一个月以来不再出现这个问题了。后来这个散热器的效果越来越差，最后连风都吹不出来了（质量真差），电脑又开始出现这个问题了，只是在6月上半个月一直都重度使用，我发现我这个黑色条纹一直都从屏幕底部出现，它也不怎么往上涨，就是屏幕底部会越来越花、越来越黑，直到底部黑到完全看不见，在关机的时候还会看到任务栏的残影。当然由于考虑到底部是黑色的任务栏，这个问题对我写作业并没有很大的影响，毕竟我写代码、写文章都只是看屏幕上面，不怎么关注底部的任务栏，只是看起来真的不爽和心烦而已。</p><h2 id="在mac上装windows双系统的实际体验如何">在Mac上装Windows双系统的实际体验如何</h2><p>至于为什么要装Windows双系统，是看到我们学院的学长学姐在群里说他们年级用Mac的同学都会装一个Windows双系统，结果我就真信了。最后我们年级那些用Mac的都老老实实地用Mac OS，偶尔确实要用Windows系统再用虚拟机来解决，我发现我被骗了。</p><p>之后装上了双系统后，看到知乎上有人说，由于苹果对Windows的兼容性很差，如果装了双系统不出几个月就会完全崩掉，看得我非常害怕，然后其他贴子就说在Mac上装Windows双系统的体验怎么怎么不好。</p><p>但是我实际用的时候并没有觉得实际体验有多差，而且并没有那些人说得那么差。也没有出现用几个月就崩掉的现象，至今我的Windows还和我的旧MacBook和谐共存中。只是在Windows里面MacBook的很多手势都不能用了；而且稍微用一下电脑就会严重发热，还会发出风扇转的响声。另外，MacBook pro的屏幕分辨率较高，使用Windows的显示效果当然也非常好，但是高分屏带来的缺点就是很多Windows的软件并没有对高分屏做优化，软件的显示要么就是模糊，要么就是字非常小，这也给我的实际使用带来了很大麻烦。除了这些之外还真的没有什么非常差的体验。而且MacBook的触摸板对比其他笔记本电脑来说，在Windows中依然很方便，并没有装额外的鼠标的必要，在这一点MacBook真的完胜其他电脑（甚至鼠标的灵活程度比在Mac OS中还要好）。由于MacBook的硬盘也是SSD，因此Windows直接在MacBook上运行（不是在虚拟机上）的速度感觉上还是挺快的，即使我的硬盘真的很小，差不多已经塞满了Windows的硬盘空间，但是也并不卡。</p><p>因此，在Mac上装Windows双系统的实际体验总体来说也并不逊色于普通的Windows电脑，但是由于Windows会让MacBook持续过热，这样会严重降低MacBook的使用寿命。也就是说我这个电脑用了不到三年就淘汰了（而且先坏的不是双系统而是硬件），而MacBook一般都可以用个5～6年。当然我不知道在iMac上会怎么样，因为我其实看到很多iMac用户都会装一个Windows系统。</p><h2 id="体验mac-os的感觉">体验Mac OS的感觉</h2><p>Mac OS给我的感觉就是界面很漂亮，也很清爽，不用被Windows系统的广告所烦恼。而且很多软件安装之后都要申请权限，这也让Mac OS在感觉上比Windows更加安全。而且由于Mac OS是类unix系统，终端的命令和linux的命令大部分也是一致的。因此Mac OS整体使用的感觉就是不仅有Windows的GUI界面，还有如此强大的终端命令，真的不愧是开发神器。</p><p>但是申请权限的巨坑就是就是连屏幕共享都要申请权限！！！这是我从来都没有想到的，毕竟在Windows上直接点屏幕共享的按键就能直接屏幕共享。而且申请完权限之后还要重启软件才可以使用这个权限！Mac端的飞书软件真的巨坑，屏幕共享的权限申请不是在第一次开启应用的时候就申请，而是在第一次进行屏幕共享的时候才申请，而且申请的弹框我一直找不到（结果是被其他窗口给遮挡住了）。这就导致我整整花了两三天时间准备的校内保研接收面试（由于疫情原因就在线上面试）的PPT由于屏幕共享不出来，就不能在面试的老师们面前展示（老师们甚至怀疑我没做），最终只能在我面试刚一结束就把PPT发给老师，并且详细解释原因，好在老师也理解我的感受（要不然我真的比窦娥还冤了），也让我通过了面试，无论分数怎样，但是能通过面试我也非常知足了。我面试完才找到这个弹框，真的巨坑！而且这个坑并不会有其他人会提前考虑到并且告知（这个怪不了其他人，因为大多数人用的还是Windows系统，并不知道这个），只要自己考虑不到这个问题就会遇到这个坑！所以在进行任何线上面试的时候，要使用屏幕共享功能的话还是尽可能用Windows吧，或者是在测试设备的时候一定要先测试能不能正常进行屏幕共享，要不然屏幕共享权限分分钟把你坑死，尤其是设置的时候还会占用自己的面试时间，还会让自己乱了阵脚，严重降低面试官对自己的印象！</p><p>还有一个，就是Mac OS的文件管理器是Finder（访达），Windows的expolrer在某些方面真的完爆Finder！首先定位文件夹不方便，一是自己不方便知道当前文件夹在哪里（路径栏默认隐藏），home目录也不方便找到，二是前往某个文件夹不方便（不像Windows的expolrer，直接点击路径栏就可以复制路径或者前往任意路径）；其次是设置显示隐藏文件不方便（Windows直接在文件夹设置里面就可以进行设置，在Mac OS要想一直显示隐藏文件需要使用命令才能在任何时候都能显示隐藏文件）；然后就是几乎每个文件夹下都有的<code>.DS_Store</code>这个隐藏文件存储文件夹自定义属性，尤其是在git版本管理中真的烦不胜烦，需要手动设置才能不生成这个文件！</p><p>其他还在慢慢适应中。</p><h2 id="如何将博客站点迁移到其他电脑上">如何将博客站点迁移到其他电脑上</h2><p>具体见：<a href="https://lovebettygirl.github.io/posts/e7168358/">如何将 hexo 博客站点迁移到其他电脑上</a></p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMware Workstation安装Windows 1.0全过程</title>
      <link href="posts/d30c5c5d/"/>
      <url>posts/d30c5c5d/</url>
      
        <content type="html"><![CDATA[<p id="div-border-left-red">注意，是Windows 1.0，不是Windows 10！<br>是Windows 1.0，不是Windows 10！<br>是Windows 1.0，不是Windows 10！</p><p>微软在1985年推出了第一个Windows操作系统版本Windows 1.0，距今已有30多年的历史。如今，一般的电脑已经无法安装Windows 1.0，也很难找到Windows 1.0的安装软盘（当时只能用软盘进行安装）和能安装Windows 1.0的设备。但是可以在虚拟机中体验Windows 1.0的安装过程。</p><a id="more"></a><p>早期版本的Windows系统是基于MS-DOS的，不自带引导，需要在MS-DOS的环境中启动Windows安装程序。而Windows 1.0基于MS-DOS 2.0，所以要在较低版本的MS-DOS环境中安装才能正常进入系统，高版本的MS-DOS会不支持Windows 1.0从而会出现花屏的现象甚至无法进入系统。亲测MS-DOS 6.22和7.1版本是不行的。这里提供的3.3版本是一个非常流行的MS-DOS版本，也是可以正常运行Windows 1.0的。</p><p>本安装过程步骤较多，请保持耐心。</p><p>第一次写教程，不仅是写给自己以备忘，也是分享给其他有缘看到的人，如有表述不妥之处请见谅！</p><h2 id="准备工作">准备工作</h2><ul><li><p>自行下载安装VMware Workstation，这里以VMware Workstation 14 Pro为例</p></li><li><p>MS-DOS 3.3软盘镜像：</p><p>链接：https://pan.baidu.com/s/1bP5Jc7UQeCPb8z6sUfzPBA ，提取码：4ngo</p></li><li><p>Windows 1.0安装镜像，这里给出<code>1.04</code>版本的：</p><p>链接：https://pan.baidu.com/s/1kX06Csau1dWWQHB8dcC-Hg ，提取码：5cxl</p></li></ul><h2 id="创建新的虚拟机">创建新的虚拟机</h2><ol type="1"><li><p>打开VMware Workstation，从这里点击“创建新的虚拟机”</p><p><img data-src="/posts/d30c5c5d/1.PNG"></p><p>当然也可以从上面的菜单栏点击“文件”菜单，选择“新建虚拟机”</p></li><li><p>选择“典型”，然后进入下一步</p><p><img data-src="/posts/d30c5c5d/2.PNG" width="60%" height="60%"></p></li><li><p>选择“稍后安装操作系统”，然后进入下一步</p><p><img data-src="/posts/d30c5c5d/3.PNG" width="60%" height="60%"></p></li><li><p>在“客户机操作系统”中选择“其他”，版本在下拉菜单中选择“MS-DOS”，然后进入下一步</p><p><img data-src="/posts/d30c5c5d/4.PNG" width="60%" height="60%"></p></li><li><p>虚拟机名称可以随便起（但不能为空），虚拟机文件的位置自行选择（不建议选择C盘的位置），然后进入下一步</p><p>下图仅为示例，不一定要和这里一样</p><p><img data-src="/posts/d30c5c5d/5.PNG" width="60%" height="60%"></p></li><li><p>虚拟机的最大磁盘大小，这里的建议大小虽然是2GB，但是1GB甚至0.5GB就足够了</p><p>将虚拟磁盘存储为单个文件还是多个文件根据个人喜好还有电脑自身的情况，单个文件可以提高虚拟机的性能（加快磁盘读写速度）；多个文件方便虚拟机文件的移动，但是会影响虚拟机的性能，如果宿主磁盘空间不够或者是FAT32文件格式（最大单文件大小仅为4GB，但是现在的磁盘一般都是NTFS格式的）的建议选择多个文件。</p><p><img data-src="/posts/d30c5c5d/6.PNG" width="60%" height="60%"></p></li><li><p>点击“自定义硬件”，打开硬件对话框</p><p><img data-src="/posts/d30c5c5d/7.PNG" width="60%" height="60%"></p></li><li><p>点击“添加”，并添加一个软盘驱动器</p><p><img data-src="/posts/d30c5c5d/8.PNG" width="80%" height="80%"></p><p><img data-src="/posts/d30c5c5d/9.PNG" width="60%" height="60%"></p></li><li><p>选择刚刚新增的软盘驱动器，在右边的“连接”处选择“使用软盘映像文件”，选择下载的MS-DOS软盘镜像路径的Dick 1，关闭对话框</p><p><img data-src="/posts/d30c5c5d/10.PNG" width="80%" height="80%"></p></li><li><p>关闭“新建虚拟机向导”对话框，至此，虚拟机创建完成</p><p><img data-src="/posts/d30c5c5d/11.PNG" width="60%" height="60%"></p></li></ol><h2 id="ms-dos的配置">MS-DOS的配置</h2><ol type="1"><li><p>开启刚刚新建的Windows 1.0虚拟机</p><p><img data-src="/posts/d30c5c5d/12.PNG"></p></li><li><p>每次开机进入DOS后都会先让输入日期和时间，然后按<code>Enter</code>键。默认是取宿主系统时间，所以可以不用输入，直接按<code>Enter</code>键取默认即可。下文不再赘述，按照同样方法。</p><p><img data-src="/posts/d30c5c5d/13.PNG" width="60%" height="60%"></p><p><img data-src="/posts/d30c5c5d/14.PNG" width="60%" height="60%"></p></li><li><p>在6.22和7.1等MS-DOS版本中，首先进入DOS都会自动进入安装程序，在安装程序中会引导你对硬盘进行分区并格式化。</p><p>但是较低版本的MS-DOS没有安装程序，<strong>必须手动输入命令做硬盘分区和格式化的操作</strong>，这样在以后安装Windows的时候可以直接安装到磁盘上。否则安装程序会让你再准备一个软驱，放入一个空软盘，在这个空的软盘上安装Windows，极不方便。</p><p>在命令行中输入<code>fdisk</code>来创建新的硬盘分区。</p><p><img data-src="/posts/d30c5c5d/15.PNG" width="60%" height="60%"></p></li><li><p>在<code>fdisk</code>主界面中，可以先选择4再按<code>Enter</code>键来查看当前硬盘分区的情况，可以发现此时硬盘是没有任何分区的</p><p><img data-src="/posts/d30c5c5d/16.PNG" width="60%" height="60%"></p><p>按<code>ESC</code>回到<code>fdisk</code>主界面</p><p><img data-src="/posts/d30c5c5d/17.PNG" width="60%" height="60%"></p></li><li><p>在<code>fdisk</code>主界面中，选择1再按下<code>Enter</code>键来进行硬盘分区</p><p><img data-src="/posts/d30c5c5d/18.PNG" width="60%" height="60%"></p></li><li><p>选择1再按<code>Enter</code></p><p><img data-src="/posts/d30c5c5d/19.PNG" width="60%" height="60%"></p></li><li><p>选择Y</p><p><img data-src="/posts/d30c5c5d/20.PNG" width="60%" height="60%"></p></li><li><p>点击任何键重启虚拟机</p><p><img data-src="/posts/d30c5c5d/21.PNG" width="60%" height="60%"></p></li><li><p>由于A和B两个分区是留给软驱的，硬盘的分区默认是从C开始的，所以刚刚创建的分区是C。（可以在命令行中输入fdisk再选择4查看分区情况来确认，此过程省略）</p><p>在命令行中输入<code>format C:</code>来对刚刚创建的硬盘分区进行格式化</p><p><img data-src="/posts/d30c5c5d/22.PNG" width="60%" height="60%"></p><p>选择Y</p><p><img data-src="/posts/d30c5c5d/23.PNG" width="60%" height="60%"></p><p>格式化完成</p><p><img data-src="/posts/d30c5c5d/24.PNG" width="60%" height="60%"></p></li></ol><h2 id="安装windows-1.0">安装Windows 1.0</h2><ol type="1"><li><p>此时，在右下角选择软盘驱动器，再点击“设置”打开硬件对话框</p><p><img data-src="/posts/d30c5c5d/25.PNG" width="60%" height="60%"></p><p>把软盘映像文件改为下载Windows 1.0的路径的Disk 1，再点击“确定”</p><p><img data-src="/posts/d30c5c5d/26.PNG" width="80%" height="80%"></p></li><li><p>在命令行中输入<code>setup</code>以启动安装程序</p><p><img data-src="/posts/d30c5c5d/27.PNG" width="60%" height="60%"></p></li><li><p>选择C</p><p><img data-src="/posts/d30c5c5d/28.PNG" width="60%" height="60%"></p></li><li><p>按<code>Enter</code>键创建Windows安装目录（根目录，默认为<code>C:\windows</code>）</p><p><img data-src="/posts/d30c5c5d/29.PNG" width="60%" height="60%"></p></li><li><p>选择C</p><p><img data-src="/posts/d30c5c5d/30.PNG" width="60%" height="60%"></p></li><li><p>选择1设置键盘，按<code>Enter</code></p><p><img data-src="/posts/d30c5c5d/31.PNG" width="60%" height="60%"></p></li><li><p>鼠标选择2，按<code>Enter</code></p><p><img data-src="/posts/d30c5c5d/32.PNG" width="60%" height="60%"></p></li><li><p>为了确保比较好的彩色显示效果，图形适配器选择6，按<code>Enter</code></p><p><img data-src="/posts/d30c5c5d/33.PNG" width="60%" height="60%"></p></li><li><p>每次看到这个界面就说明要换软盘映像文件了，这里说要换Build disk。按照本节第1步的方法，换成Windows 1.0软盘映像文件路径中的Build disk，Build disk是<code>D2_Build.img</code></p><p>这个界面换成什么盘就按照这一步的方法换成对应的软盘映像文件，以后看到这个界面的处理方式不再赘述。</p><p><img data-src="/posts/d30c5c5d/34.PNG" width="60%" height="60%"></p></li><li><p>换成<code>D3_Utility.img</code>之后，到这个界面了，选择N，不设置打印机</p><p><img data-src="/posts/d30c5c5d/36.PNG" width="60%" height="60%"></p></li><li><p>进行到这里，安装程序就结束了，但是没有出现命令行。需要按照本节的第一步的方法，把软盘映像文件换成MS-DOS软盘镜像路径的Dick 1，之后已经直接定位到<code>C:\windows</code>，直接输入<code>win</code>即可进入Windows</p><p>此后软盘映像文件就不要动了，否则下次启动不能进入DOS。</p><p><img data-src="/posts/d30c5c5d/40.PNG" width="60%" height="60%"></p><p><img data-src="/posts/d30c5c5d/43.PNG" width="60%" height="60%"></p></li><li><p>如果蓝色的开机画面一闪而过然后看到以下主界面，就说明已经正常进入Windows了。</p><p>大功告成！</p><p><img data-src="/posts/d30c5c5d/44.PNG" width="60%" height="60%"></p><p>如果在蓝色的开机画面听到很多嘀嘀声并且有蓝色花屏的现象，那就是这个MS-DOS版本太高不支持Windows 1.0了。得换用低版本的MS-DOS。</p><p>如果能正常进入到主界面，但是显示效果不是这样的，那就是本节第8步选错了。得重新安装Windows。</p></li><li><p>下一次启动虚拟机，是定位到A盘的。此时需要先在命令行输入<code>C:</code>以定位到C盘，再输入<code>cd windows</code>以定位到Windows根目录，最后再输入<code>win</code>才能进入Windows。如下图所示：</p><p>因为Windows 1.0以及其他的一些早期版本的Windows操作系统严格意义上只能算是个运行在DOS上的Shell程序。</p><p><img data-src="/posts/d30c5c5d/48.PNG" width="60%" height="60%"></p></li></ol><p id="div-border-left-red">退出Windows之后会回到命令行模式，由于此版本的DOS没有类似<code>shutdown</code>的关机命令，故直接选择关闭客户机（虚拟机&gt;电源&gt;关闭客户机）即可。</p><h2 id="windows-1.0的一些操作">Windows 1.0的一些操作</h2><p>Windows 1.0虽然支持鼠标，但是没有鼠标程序也是不支持鼠标的。以下是一些基本的键盘操作。</p><ol type="1"><li><p>按方向键选择一个文件或子文件夹，按<code>Enter</code>打开一个文件（或执行一个<code>.exe</code>文件、或进入子目录）；按<code>Backspace</code>回到上一级目录</p><p><img data-src="/posts/d30c5c5d/1111.PNG" width="60%" height="60%"></p></li><li><p>按<code>Alt+Space</code>打开左上角菜单，用上下方向键选择功能，按<code>Enter</code>键执行功能；在主界面中，选择Close退出Windows，在其他窗口则是关闭窗口</p><p><img data-src="/posts/d30c5c5d/2222.PNG" width="60%" height="60%"></p></li><li><p>在如图所示的菜单项中按<code>Alt+菜单项首字母</code>打开一个二级菜单，同样用上下方向键选择功能，按<code>Enter</code>键执行功能</p><p>例如在下图中，打开<code>File</code>菜单按下<code>Alt+F</code>即可</p><p><img data-src="/posts/d30c5c5d/6666.PNG" width="60%" height="60%"></p></li><li><p>在如图所示对话框中，按<code>Tab</code>键选择控件，再按下<code>Space</code>键确定。如果直接按下<code>Enter</code>键则是对默认控件选择确定。</p><p>例如在下图中，按<code>Tab</code>键在<code>Yes</code>、<code>No</code>和<code>Cancel</code>之间切换，直接按<code>Enter</code>键默认选择<code>Yes</code>（加粗）</p><p><img data-src="/posts/d30c5c5d/4444.PNG" width="60%" height="60%"></p></li><li><p>在画图程序中（<code>paint.exe</code>），方向键控制鼠标光标，按下<code>Space</code>键即可对画布进行更改。</p><p>按下<code>Tab</code>键选择下图的工具</p><p><img data-src="/posts/d30c5c5d/3333.PNG" width="60%" height="60%"></p></li><li><p>在黑白棋游戏中（<code>reversi.exe</code>），方向键控制鼠标光标，按下<code>Space</code>或<code>Enter</code>键放棋子。</p><p><img data-src="/posts/d30c5c5d/5555.PNG" width="60%" height="60%"></p></li></ol><h2 id="references">References</h2><ul><li><a href="https://jingyan.baidu.com/article/0964eca241b5998285f536b8.html">VMware workstation虚拟机安装Windows1.0教程</a></li><li><a href="https://zhidao.baidu.com/question/1388650208766454460.html">虚拟机安装windows1.0蓝屏</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 虚拟机安装 </category>
          
          <category> Windows系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VMware </tag>
            
            <tag> Windows </tag>
            
            <tag> MS-DOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客</title>
      <link href="posts/ff05b5bf/"/>
      <url>posts/ff05b5bf/</url>
      
        <content type="html"><![CDATA[<p>辛苦了整整一周，我的博客总算从零搭建好了。以下记述我搭建博客的过程。</p><a id="more"></a><h2 id="为什么写博客">为什么写博客</h2><p>由于我比较习惯有问题就百度，在此过程中从大佬们在CSDN和博客园写的博客中受益良多。更有甚者，有些大佬自己制作了非常漂亮的博客，让我非常羡慕。从这时起我就想像他们一样拥有一个这么漂亮的博客来把自己的想法记录下来。</p><p>于是就在大二暑假闲来无事的时候，就参考了各路大佬的教程搭建了一个博客。用以记录在努力提升自己的过程中（并不限于学习）踩过的坑、课程笔记、随想等等。由于本人没有什么技术，所以技术文会很少，即使是有也是参考了大佬的然后自己作个汇总，方便自己看。以后也会相应地少用一些精力在社交软件上，淡出微信朋友圈。</p><h2 id="关于博客中选用的主题">关于博客中选用的主题</h2><p>使用Hexo + GitHub Pages搭建。主题根据NexT v7.3.0进行了修改。</p><p>跟着教程搭建好初始的博客框架之后的第一步就是去<a href="https://hexo.io/themes/">Hexo的官方主题库</a>去寻找合适的主题。最初看中了一些别人做好的主题，但是我又觉得直接用别人做的主题毫无特色，总得改一改才行，但是由于自己不怎么会前端，一些个人开发的主题又没有相应的修改教程，让我无从下手。</p><p>最终决定使用NexT主题，选用Mist样式，并对其进行定（mó）制（gǎi），因为用的人比较多，且在GitHub上有很多人在维护，官方文档和教程也相对比较齐全，可以自己好好折腾一番，让自己使用的主题有一点点自己的特色，可以看起来跟别人的不一样。于是我又搜索了很多关于NexT主题自定义的教程，期间也踩了不少坑，总算是在原来的主题的基础上加了一些功能，并且把UI改成了暗黑风格。</p><p>起初用的NexT主题版本是v5.1.4的（下称旧主题），已经修改了大部分之后我才知道这个版本并不是最新版本，而是属于原来的GitHub仓库的最新的版本，在6以后的版本就迁移到了别的仓库。由于我跟着教程做的部分修改无论如何都不起作用，仔细看了才得知我参考的大部分教程都是基于v6.0+版本的（很少有7的），我用的版本已经是很旧的版本了。于是我就下了狠心结束对旧主题的修改，把我做的修改慢慢迁移到新版本上（我克隆这个主题库的时候就已经是v7.3.0版本了，下称新主题）。迁移的工作用了一天多的时间。在迁移的过程中我才发现<code>source/css</code>文件夹中没有<code>_custom</code>文件夹，我就把我这里旧版本的<code>_custom</code>文件夹拷贝了过来。后来又发现只要是我加入到的<code>custom</code>文件（无论在哪个文件夹，是什么格式）中的修改都不起作用。然后就推测这个版本是不是已经不支持<code>custom</code>文件了。原先我也清楚custom文件是方便自定义样式用的，只要在这里加入相应css就可以覆盖原来定义的css。然而这个版本似乎是不支持（我觉得是，但是没有证据，但是也许可以做一些设置？）？这不就是意味着我参考的很多与NexT主题样式修改的许多教程都已经不起作用了吗？隐约感觉到自己又在无意间踩了一个巨大的坑（原来弄了一个旧版本我就已经觉得自己踩坑了），因为这意味着很多修改需要不会前端的我自己探索了，心情如下图（图片来自网络）：</p><p><img data-src="/posts/ff05b5bf/ryhynyt.jpg"></p><p>后来只好研究一下主题文件夹下的配置文件<code>_config.yml</code>，发现可以开启很多新功能，有些在教程中的功能在这里就可以直接开启（把属性值修改为<code>true</code>，有些功能需要下载相应的依赖包），不需要很多繁杂的流程。拜<a href="https://blog.csdn.net/weixin_40837922/article/details/88047241">此教程</a>所赐我又找到了修改主题样式定义的通用方法（在旧版本也适用）：在浏览器中打开审查元素（按F12可以打开），然后选中想要修改样式的地方，在<code>source/css</code>文件夹中找到对应的css并修改之（在Styles一栏可以参考应该在哪或者怎么修改样式）。虽然说这个过程要比直接在<code>source/css/_custom/custom.styl</code>中直接添加修改要麻烦很多，有时候甚至要找很久才能找到修改后真正起作用的位置，但是在找到更好的办法之前就先这样了。</p><p>此外，根据<a href="https://blog.csdn.net/qq_30242609/article/details/54799019">这里</a>，也可以知道<code>source/css/_variables/base.styl</code>中定义了一些在其他<code>.styl</code>文件中使用的变量，修改这些变量值可以修改主题的一部分配色以及其他参数。推测维护人员是不想让我们随随便便就把原来这么好看的样式改掉吧。（其实我觉得原来的主题并不丑，也挺漂亮的，至少很简洁，就是不修改会觉得毫无特色）</p><p>在折腾的过程中还遇到了很多新问题。部分会在后续博客中详细说明。</p><p>就这样，踩了不少坑，克服了不少困难，才把主题修改成了现在的样子。可能缺点就是要素过多，不够简洁吧。</p><p><strong>之后可能会根据情况对主题做进一步的修改。</strong></p><h2 id="暂时不考虑的选项">暂时不考虑的选项</h2><p>由于初期我只想先实验一段时间，写给自己。并且顺便熟悉GitHub的用法。所以暂时先不做推广，等到时机成熟了再做推广。</p><p>在时机成熟之前不考虑如下选项：</p><ul><li>在人群中推广</li><li>买一个单独的域名</li><li>让搜索引擎收录自己的文章</li><li>增加评论系统</li><li>增加打赏功能</li><li>增加访问量以及阅读量统计</li><li>在GitHub上发布自己对主题的修改（别人模仿无所谓，主要是怕侵权）</li><li>......</li></ul><h2 id="references">References</h2><p>在博客搭建的时候参考了大量文章，故在这里一一列出（没有顺序，可能有遗漏）：</p><ul><li><a href="https://blog.csdn.net/weixin_44441012/article/details/86685251">30分钟教你从0到1搭建自己的个人独立博客(GithubPages和Hexo搭建教程)</a></li><li><a href="https://blog.csdn.net/qq_30878303/article/details/79461060">一小时快速搭建个人博客</a></li><li><a href="https://www.cnblogs.com/zhcncn/p/4097881.html">Hexo搭建Github静态博客</a></li><li><a href="https://www.jianshu.com/p/2da702603db0">fatal: unable to auto-detect email address (got 'name@bogon.(none)')的解决方法</a></li><li><a href="http://theme-next.iissnan.com/getting-started.html">iissnan的NexT主题文档</a></li><li><a href="http://shenzekun.cn/hexo的next主题个性化配置教程.html">hexo的next主题个性化教程:打造炫酷网站</a></li><li><a href="https://www.jianshu.com/p/1ff2fcbdd155">Hexo博客第三方主题next进阶教程</a></li><li><a href="https://blog.csdn.net/u010937230/article/details/77925643">Hexo next主题搭建静态博客埋坑记录</a></li><li><a href="https://blog.csdn.net/panchao888888/article/details/80666352">Hexo博客NexT主题终极配置</a></li><li><a href="https://blog.csdn.net/qq_22844483/article/details/70157310">hexo博客框架--nexT主题进阶设定</a></li><li><a href="https://blog.csdn.net/weixin_40837922/article/details/88047241">给hexo主题添加背景及更改字体颜色（next的Mist主题）</a></li><li><a href="https://www.jianshu.com/p/2a8d399f1266">修改 hexo-theme-next 主题的样式（统一网站颜色）</a></li><li><a href="http://www.mdslq.cn/archives/40609c5b.html">Hexo博客Next主题个性设置集锦</a></li><li><a href="http://xyua.top/Hexo/hexo_next_blog.html">Hexo | NexT打造一个炫酷博客</a></li><li><a href="https://www.jianshu.com/p/ad0d867a8cb6">Hexo_NexT主题-个性化配置记录</a></li><li><a href="https://www.jianshu.com/p/c8de95fae5f5">Hexo-Next-Mist主题头部顶栏背景图片设置</a></li><li><a href="https://www.jianshu.com/p/efbeddc5eb19?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation">Hexo+Next个人博客主题优化</a></li><li><a href="https://blog.csdn.net/u011054333/article/details/82718910">在Hexo博客上添加可爱的Live 2D模型</a></li><li><a href="https://www.cnblogs.com/liziczh/p/9318656.html">Hexo | （二）Next主题个性化设置</a></li><li><a href="https://blog.csdn.net/weixin_39345384/article/details/80785373">Hexo框架下用NexT(v7.0+)主题美化博客</a></li><li><a href="https://blog.csdn.net/weixin_39345384/article/details/80544660">NexT v6.0+ 背景动画Canvas_nest设置无效的解决方案</a></li><li><a href="https://www.jianshu.com/p/3a01cc514ce7?utm_source=oschina-app">Hexo和Next主题的相关设置（持续更新）</a></li><li><a href="https://blog.csdn.net/wugenqiang/article/details/88376089">使用 Github 空间搭建 Hexo 技术博客——Hexo NexT主题内网站运行时间的设置（十）</a></li><li><a href="http://wangwlj.com/2018/01/09/blog_pin_post/">Hexo博客彻底解决置顶问题</a></li><li><a href="https://juejin.im/post/5c45a503f265da616b10fe4e">[EasyHexo 专栏] #2 - 魔改 Next 不完全教程</a></li><li><a href="https://www.xiaocoder.com/2018/07/15/hexo-blog-optimizing-guide/">使用Hexo搭建博客之优化篇</a></li><li><a href="https://segmentfault.com/q/1010000008383047">hexo 404页面不能正确跳转</a></li><li><a href="https://blog.csdn.net/blue_zy/article/details/79058763">Hexo更换next主题和优化</a></li><li><a href="https://www.jianshu.com/p/e17711e44e00">Hexo使用攻略-添加分类及标签</a></li><li><a href="https://www.jianshu.com/p/f138032e7539">Hexo next 主题配置右侧栏的分类和标签打开的是空白</a></li><li><a href="https://www.jianshu.com/p/8d28027fec76">hexo+github上传图片到博客</a></li><li><a href="https://blog.csdn.net/mudooo/article/details/94567001">hexo 文章插入图片</a></li><li><a href="https://io-oi.me/tech/hexo-next-optimization.html">打造个性超赞博客 Hexo + NexT + GitHub Pages 的超深度优化</a></li><li><a href="https://yangbingdong.com/2017/build-blog-hexo-advanced/">基于Hexo搭建个人博客——进阶篇(从入门到入土)</a></li><li><a href="https://www.qcmoke.site/blog/hexo_next.html">hexo博客框架环境搭建，并使用next主题打造精美的个人博客网站</a></li><li><a href="https://theme-next.org/docs/theme-settings/">NexT官方文档</a></li><li><a href="http://www.mykernel.cn/my-hexo-next-1.html">hexo支持的样式（持续更新ing.....）</a></li><li><a href="https://blog.csdn.net/yanzi1225627/article/details/77761488">hexo链接持久化终极解决之道</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> NexT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试添加图片</title>
      <link href="posts/f9fd185d/"/>
      <url>posts/f9fd185d/</url>
      
        <content type="html"><![CDATA[<figure><img data-src="/posts/f9fd185d/12645342_DSC08965_thumb.jpg" alt><figcaption>1</figcaption></figure><figure><img data-src="/posts/f9fd185d/tigfchftfuthgmg.jpg" alt><figcaption>2</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
