<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LoveBettygirl</title>
  
  <subtitle>Stay hungry, stay foolish.</subtitle>
  <link href="https://lovebettygirl.github.io/atom.xml" rel="self"/>
  
  <link href="https://lovebettygirl.github.io/"/>
  <updated>2023-01-08T17:00:07.749Z</updated>
  <id>https://lovebettygirl.github.io/</id>
  
  <author>
    <name>LoveBettygirl</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>迟来的2022年度总结</title>
    <link href="https://lovebettygirl.github.io/posts/aa2d44a7/"/>
    <id>https://lovebettygirl.github.io/posts/aa2d44a7/</id>
    <published>2023-01-08T10:04:24.000Z</published>
    <updated>2023-01-08T17:00:07.749Z</updated>
    
    <content type="html"><![CDATA[<p>2022年虽然也是碌碌无为的一年，什么都做的不好，但是也取得了一些超预期的成绩。在最近的关头写个总结。</p><a id="more"></a><h2 id="月-2月">1月-2月</h2><p>这会奥密克戎病毒刚刚在我国被发现，天津算是最早沦陷的一波，而且沦陷的正好是我们区。由于害怕导师不同意提前溜（实际上导师同意了），自己也害怕违反政策/法律从而不太果断，错过了逃亡的时间窗口，经历了从逃亡失败到被迫留在宿舍每天做核酸的经历。</p><p>1月是过的非常难受的，实验室不给去，只能在宿舍呆着，并且经常有大半夜去做核酸的时候，严重打乱作息，并且当时的情况是大概率春节回不了家的。由于已下定决心转开发，不会深耕于科研，此时我准备开啃《C++ Primer》，和宿舍嘈杂的环境真的格格不入，但是我也没得其他选择，宿舍楼的自习室冷得跟冰窖一样，没人愿意去的。真的，没人理解我的孤独……</p><p>后来，我偷偷去到了学院楼的自习室学习，这个自习室是一个研究生上课的教室，也是本科班的一个自习室。由于当时大部分本科生都回家了，我就能去这个自习室学习了，这个自习室非常暖和，给当时的我很大的心理慰藉。我可以在这安心地啃《C++ Primer》，以及刷一点LeetCode。</p><p>到了1月底，我们区社会面清零（发明了一个新词），学校用了大巴车送我们去机场，准备回家了，当时还经历了好不容易在规定时间内做了48小时内间隔24小时的2次核酸，却又飞机起飞前一天航班被取消的离谱事情。本以为真的不能回家了，幸亏当天上午又做了一次核酸，这样在后一天上午再做一次核酸就能赶上另一趟飞机了（也就是原来的飞机是晚上7点起飞的，重新定的另一趟飞机是早上7点的）。如果没有这次核酸，可能真就回不了家了。</p><p>本来以为春节在家过年够呛，还好家这边不用隔离，跟社区报备一下就没事了，这就顺利在家过年了。</p><h2 id="月-4月">3月-4月</h2><p>返校推迟了2周到3月，这会没啥理由不回学校的，只能回去了。为了尽早达到毕业要求，我答应和师兄一起参加一个智能运维的比赛，这个比赛饼画的还是很好的，比赛的成果可以用来发论文。说实话，本来实验室主要是做网络的，不是做这个方向的，导师让师兄拉人做这个比赛，就是为了让大家了解微服务？（我上哪学微服务不行呢，非要在这学？）其实我也不咋想参加这个（多耽误自己学习时间啊），看在这东西有个微服务的背景，要是真做出来了也能在简历上吹一吹，也为了尽早达到毕业要求，就答应了。</p><p>这段时间就是看并总结了几篇日志异常分析的论文，跑了一下他们开源的代码。但是由于实验室真的没人做过这个方向，并且参加这个比赛的人，也都是有备而来（做这个方向的，就准备在这个数据集上出成果）。最后大家各自的方向跑出来的结果都很差，就都弃赛了。</p><p>虽然这段时间被迫让出了一点时间在不喜欢但是不得不做的科研上，但是我顺便也啃完了《C++ Primer》大部分章节、《Effective C++》、《深度探索C++对象模型》主要章节。也保持几乎每天都刷LeetCode。虽然啃《C++ Primer》是一个很漫长且枯燥的过程，但是这本书真的让我入门了使用C++11进行编程，让我摒弃了以前C++的旧标准给我带来的坏习惯。</p><h2 id="月-6月">5月-6月</h2><p>在比赛上白白浪费了很多时间却未取得成果之后，又看到其他朋友可以在校外自由地出去实习，干自己想干的事情，我却不停地被换方向，毕业成问题，找工作/去实习也就更成了问题，身边没人能理解我的孤独和无助。我就破防了起来，又重新开始了精神内耗。5月份这段时间，真的已经到了几乎天天晚上都在哭的地步：没有人身自由、不能干自己想干的事情、科研也无法走向正轨、未来一片灰暗……这个月也找导师摊牌，问能否给我安排一个真正靠谱的方向，也失败了。于是我决定，不能依靠导师给我靠谱方向，我要自己救自己。</p><p>虽然前途一片灰暗，但是5月我干了2件大事，拯救了自己：</p><ul><li>跟实验室师兄交流，也考虑到跟着导师原来的组继续做，可能花费更多时间也出不了成果，出不了成果也影响毕业，影响之后找工作。遂决定跟大老板提出跟着同屋的博士师兄一起做这两个师兄的方向（AI安全，涉及到一些深度学习的东西，会比网络好搞一些）。博士师兄很好，也欣然接纳我跟他一起做了，他需要我征得我导师和大老板的同意。好在大老板对于换方向比较开明，我找她商量了，表明了想尽快达到毕业要求的诉求之后就同意了。也跟之前一起打比赛的博士师兄说了这个事，虽然我的「出逃」可能会给他的科研带来很大人力上的麻烦（这是实验室的新方向，由于设备原因必须线下做，手头除了我没其他人能做，原来要跟他一起做的同学无法返校），但是他也理解我以后也不会从事科研，也就不为难我了，说我做跟新师兄做的方向的确会更好毕业，对我找工作也更有帮助，于是同意了我跟着新师兄做。当然，我导师也同意了。</li><li>5月底学校组织自愿的集中返乡（也就是提前放假），我鼓足勇气跟大老板说我要这会回家，跟她周旋了很久，她人还不错，最后也同意我回家了。拥有了3个月的超长暑假，这大大超出了我的预期（因为按照预期，实验室的暑假是不超过一个月的）。</li></ul><p>5月才开始匆匆忙忙搞自己的项目，自己参考了一些GitHub开源项目，以及其他视频/文字等网络资料。完成了一个webserver，自己加了点C++11特性和其他功能。还有一个C++的玩具RPC框架，借鉴了Java方向的玩具RPC框架，加了一些新功能。回家之后我all in到做项目中，写完这两个项目之后，完成了简历，就开投日常实习了。</p><h2 id="月">7月</h2><p>6月底我搞好了简历，也让大佬review了我的简历，提出了一些建议并修改。就在实习僧上开投了一些公司，投了十几家（有不太想去的，也有想去的），只有momenta约面了。当时我由于没注册过boss的账号，那会boss不给注册了，只好去实习僧上投。实习僧也是据朋友反映不好用，投简历之后很少得到反馈。当时也在怀疑是我学历还是经历都太差了吗，一个面试机会都不想给。</p><p>对，6月底，我只收到了momenta的面试，我本来是想做业务后端的，就投了他们的go后端岗位，hr给我转到了C++后端开发岗（高精地图的，不太感兴趣）。当时抱着练习的心态接受了面试，居然意外发现面试很简单，hr似乎也有一种很着急要我的样子，2面完很快就oc了。但是由于当时大部分互联网公司还没投，我更想去互联网公司，就忍痛拒绝了oc，继续开投互联网公司。</p><p>7月份boss开放了注册，我得到了消息就赶紧注册了一波。我询问了不少公司的hr能不能接受我的简历，比如滴滴、网易、小红书、b站、百度。滴滴当时在招秋储实习生，以我不是应届为由拒绝；小红书和网易均以我不是Java技术栈为由拒绝。</p><p>我这个人很倔强，也怪我之前没调研好后端日常实习的现状（岗位相对较少，大多有语言限制），当时7月份在招的岗位也非常少（暑期实习生都入职了，还没人离职，并且快秋招了，各个公司基本上处于最不缺人的状态），我能看到的C++能投的后端岗位当时都没在招（可恶，居然8-11月又开始招了）。其实如果我只想找C++开发岗，不考虑方向的话，在当时机会很少的前提之下，应该也能收到不少面试机会的。但是我就是倔强，我就非要以C++的技术栈去找业务后端岗位（愿意转到go/Java），所以碰壁也是在所难免。不仅仅是Java岗位不愿意收我简历，go岗位也宁愿要Java转的也不要C++转的。我在官网也投了网易，简历挂（不是Java技术栈）；投了美团也没消息（岗位在半个月前发布，应该招到人了）；我当时看没啥面试机会，连保底的天津360都投了，也不给我面试机会……当时朋友也在劝我不要白费精力了，7月份的时机很差，他们在字节的组也不收实习简历了，基本上很难找到实习的。但是我不理会他的话，反正我就想着一定要上岸（不上岸我就只能明年投暑期实习了），不试试怎么知道真找不到实习呢，我不信邪。</p><p>后来，我看我投后端基本上没收到面试机会。就放宽了自己的意向：感兴趣的C++开发岗也行，包括鸡架（其实我挺能接受鸡架的，只是觉得自己没做过啥相关lab，怕面试被暴打）。之后经过不断的海投，在可能感兴趣的公司上搜遍了所有可能在招的岗位，每个hr都私信问能不能收我简历，我的面试逐渐多了起来：</p><ul><li>当时给百度投了好几份简历（包括后端和貌似感兴趣的C++开发岗），貌似感兴趣的C++开发岗约面，总体也比较简单，大部分都是常见八股+easy算法题，并且面完3面收到oc</li><li>b站投了几个简历，一个分布式存储的岗约面了，但是它要求懂leveldb，我不懂就一面挂了</li><li>小米投了个自动驾驶后端岗，技术栈Python，一面挂（过了我应该也不太想去，居然是主Python，尴尬）</li></ul><p>我当时可想去字节后端了，觉得先面完其他面试，练够了再最后投。由于字节hc缩减，当时列表内很多在字节后端的组都不想收我简历，我当时还很尴尬，很早就把简历给到了一个做分布式存储的朋友手里，结果后来才知道他在字节（尴尬），但是好不容易有个字节的组收我简历，也想着我投这个岗没准还能进呢（是我想多了，鸡架基本上岗少要求高），就接受了面试（后悔的一批，早知道拒面自己投后端了），流程走的很长：字节一面面的比较早，是小leader，也是校友，虽然校友在问问题上也丝毫不放水，挖的很深，我还没积攒太多面试经验，但是可能是因为当时太想去字节了，算是超常发挥了，绝大部分问题（90%以上）我都顺利接招，回答上了，算法题常见mid，10min内写出；隔了2天收到二面，二面面试官的职级比较高，应该是大leader，看我没存储经历就主要问八股了，大部分八股我还是回答上了（70%，按照今年的要求不容易通过面试，往年可以），但是跟存储相关的问题，因为我没有相关经历，就回答的很尴尬，算法题也是常见mid题，写出来了。本以为我算法题写出来了，这是我离字节最近的一次，最后因为我没有存储相关经历+组内没实习hc，4天后挂了。</p><p>虽然字节挂了，但是我当时的表现也得到了内推人的认可（他看了我表现也没想到我会挂），把帖子发到了牛客上也得到了牛客官方大佬，还有这个组实习生的认可（说按我这难度面试他肯定进不去），也得到了给我看简历的大佬的认可，也算虽败犹荣了。</p><p>当时字节二面完，等了好久，我觉得看不到希望，觉得可能会挂。就有幸找上了列表内的朋友找到了滴滴的一个组内直推（其实我也挺想去滴滴的，毕竟有go技术栈就有收我的可能，但是当时问这么多hr都不收我简历就放弃了），leader说接受转语言，于是得到了这个宝贵的面试机会：一面放了点水，是组内其他员工面试，问最熟悉的八股和easy算法；二面是mentor来面，这感觉才是一个正常的面试该有的样子，八股部分抠我简历上的专业技能问问题（我第一次知道专业技能这块还有这么多能挖的点），然后让我手撕快排，最后出了个场景题没答到点子上（其实本来是让我现写的），mentor说了答案。当时觉得这2面面的有点凉，觉得应该是没了，百度面完3面一天了也没消息，很绝望，还想着再投个什么公司呢。</p><p>到了20号，我在这天按顺序分别收到了滴滴oc、百度oc、字节感谢信。由于在面试反问环节得知对百度那个岗的工作内容不够喜欢（是爬虫策略开发，算法工程化的），我比较想去业务后端，oc阶段也发现给的不如滴滴多，就无脑接了滴滴offer。为期一个月的找实习过程算是正式收官了，当时我还以为我2周内就能结束呢，然后7月上旬赶紧去，凑够2个月线下实习就开学，结果是我太天真了，就剩一个月给我线下了……我甚至都有点不好意思接这个offer。然后我就赶紧休息了2-3天，租了房立马打包去北京了。虽然刚到北京后字节开始有实习的hc了，我也被后端的组捞起来面试，但是想着再面字节，我这实习经历连一个月都凑不到就得回校，就算了吧。</p><p>总体来说，这一个月找实习的经历虽然初期屡次碰壁，也不被朋友看好，但是最后结果还算是可以的，用1个自动驾驶oc换来2个互联网oc。感觉除了字节这个的遗憾，还有一个遗憾就是，没再早点准备项目，早一个月投简历时间就刚刚好了……这次暑假的机会虽然抓住了但是属实抓的有点烂。幸亏我在21年也投过一次字节，在面试前我高强度准备过八股，再加上我收到的面试机会不太多，所以我捡起八股的速度还是挺快的。经过这段时间的洗礼，我也总算体会到了，寻找实习/招聘实习是一个「供需匹配」的过程，而不是一厢情愿的把自己变强，求着对方收你，对方就一定能收你。很感谢滴滴能给我一个转go的机会。不知道该怎么感谢给我机会的朋友，看看有没有机会去北京请他吃饭，实在不行发个红包吧。</p><h2 id="月-1">8月</h2><p>7月底入职的时候，去滴滴大厦拿了工牌就去我的工区，mentor在1楼接我上楼（我就说怎么这么脸熟，像是二面那个面试官），当时还有个负责我们组业务的qa一起送我上楼，跟我是老乡。上楼后带我见了leader还有我的一面面试官（组内另一个同事），以及组内其他同事。</p><p>8月在北京的时候真的是这一年我过的最快乐的一个月。实习虽然难免会碰到不开心的事情，但是真的比在学校快乐多了。这个月除了实习，还在北京见了一些之前认识的大佬网友一起吃饭，也认识了一些在百度工作的大佬一起吃饭，也带我进了百度科技园参观，一起玩狼人杀。这段旅程把我oc的两家公司全都看了一遍，也很值得了。</p><p>由于我是C++面试，mentor正好独立负责组内唯一的C++项目，leader就让这个mentor带我了。8月份的2周我就慢慢看那个C++的拼车模块，这个模块其实接口挺少的，也是一个相比纯crud而言很有意思的模块。本来很快就能看完，当时还给我分了个依赖集成的杂活，所以我就在我来的第4周串讲我看的C++模块了。好在当时文档准备的比较详细，还被leader认可了，说我是来过的实习生当中准备的最充分的。之后我的串讲文档成了大组内其他实习生串讲的模板。</p><p>是我太天真了，当时还想着1个月就干出点活，好让我1个月也能写点简历……我来这边第4周才开始做第一个需求（是go的），居然就因为实验室的科研要回学校了。觉得没做啥事，不好意思离职，只好无奈跟leader说自己因为实验室要暂时回学校远程。好在leader也同意了，我就先回校了，需求正常做，才来一个月真的也挺舍不得这里的。</p><h2 id="月-10月">9月-10月</h2><p>跟了新师兄后，科研走上了正轨，要回校跟着师兄做科研，准备冲10月份的ccf b，开始了暂时远程实习且不知道什么时候结束的生活。9月份其实还行，科研和实习都能兼顾住。10月就很难受了，离论文ddl越来越近，10月份差不多2-3周的生活是：周一到周五白天实习，晚上+半夜做实验；周末all in做实验。到了最后是白天也越来越多时间做实验，导致这段时间实习没兼顾好，这段时间也给了leader和mentor不太好的印象，说我效率太低了。</p><p>哎，这段时间的生活实在是太阴间了，简直不堪回首。每天一大早要起来强制做核酸（天津要求的），10月份几乎每天都是早上5、6点才睡觉，睡到8点去外面做个核酸就继续做会实验到10点，然后开始忙实习。对，每天只睡2小时。</p><p>经过了2个月的匆忙实验，我也有了自己挂名的第一篇论文（虽然可能中的概率不是很大，但是没中也没关系，有这些工作就有写毕业论文的素材，再投下个会就是了），感谢师兄带我！</p><p>9月份在实习上做的工作是一个go的小需求，接口增加几个字段，在redis中保存，借此熟悉组内的导航相关业务；然后C++项目有2个杂活：增加一个Apollo灰度开关，借此熟悉Apollo（很多公司都会有自己的Apollo，二次开发的，算是配类似zk和nacos的配置中心）；增加C++项目的Redis密码访问功能（同时保留不用密码访问的方式），熟悉项目读取配置的相关逻辑，这个活虽然简单，但是也碰上了一个关于brpc的坑，我直接以RPC调用的形式来执行 <code>AUTH</code> 命令了，当时mentor提醒我这样不行，查了brpc源码才知道TCP连接是在 <code>CallMethod</code> 函数里面才建立的。</p><p>10月份的一个工作比较大，也比较杂，属于吃力不讨好的类型（但是做完了才知道这个活其实挺锻炼的，也值得往简历上写，因为毕竟也算是项目的大改动，也有点自己设计的东西在里面）：</p><ul><li>梳理C++项目中的错误类型，细化错误码的定义，先定义一个文档</li><li>根据定义的文档，对C++项目进行错误码改造。由于项目的历史遗留原因，导致进行这样的改造需要改掉项目中大部分函数的返回值类型，返回值类型改了，里面的一些业务代码也得改了，从而适配这样的返回值类型。得确保这样的改动不能影响到业务逻辑和线上服务。这个要改的地方特别多，也很容易出错，导致这个地方用了1个月（其实要是加班的话，2周搞完其实也行，但是这段时间真的没法加班）</li></ul><p>这段时间，由于涉世未深，我由于过于热情，被社会教育了。没办法，中国就是信奉「成王败寇」，你取得结果的过程再怎么艰难，是一年取得的还是一个月取得的无所谓，别人只关心你结果。感谢父母、室友、网友对我的安慰，也学会了很多社交技能，帮助我走出这件事给我心态上的不良影响，助我之后不再犯错。</p><h2 id="月-12月">11月-12月</h2><p>10月份的阴间作息给我状态带来的影响真的很大，这也导致到了12月我的状态都没完全恢复。所以这段时间主要还是all in实习。</p><p>当然，由于疫情封校原因和北京健康宝弹窗的原因，我9月份离开了北京就没法回来了。我也在想办法怎么先离校再回到北京线下。由于之后北京疫情越来越严重，工区也开始全员线上办公了。12月初疫情进校园，把大家都遣返回家了，于是寒假又提前开始了。本来12月回家之后，我就想去北京，结果万万想不到突然放开，北京大部分人都感染了，leader就说我年后再来吧。</p><p>等了很久，12月份终于开始有了一个属于我自己的，和网约车一起做的，正规流程的大需求（对，你没有看错，这种大需求应该是来3-4个月就开始做的，我是第5个月，可能是因为远程实习本来在分配活就容易被边缘化）。总算是在实习期间体验了需求对接、开发、联调、提测、qa测试、上线的全流程。这段实习算是没有遗憾了。</p><p>比较幸运的是，虽然留在了家里，家人也都感染了，但是12月我一直无症状，是一个天选打工人。</p><h2 id="总结">总结</h2><p>这一年跟往年一样是个碌碌无为的一年，也没啥学习和工作之外的娱乐生活，无非就是干了一些事情把我从无尽的苦海中拯救出来，虽谈不上逆天改命，但是也得到了很多意想不到的收获：</p><ul><li>在实习上，以技术栈不占优势的情况下拿到了互联网公司的后端日常实习offer，整体符合自己的预期，但是知道结果后的初期也心存遗憾和不甘。本以为自己只能有1-2个月的实习，但是也由于疫情原因意外收获了半年的实习。真的很感谢leader和mentor在面子上不嫌弃我线上了这么久，给我一个增加经历的机会。实习也在C++和go上反复横跳，技术栈总体还是适合我的。这也让我明白了，一切都是最好的安排，并不是自己最想要的东西就是最好的。</li><li>在师兄的carry下，终于有了一个属于自己的科研工作，虽然论文大概率中不了，但是给我毕业和找工作增加了筹码。</li></ul><p>这一年也有很多遗憾，比如疫情给我创造了更长的假期，我虽然利用上了，但是利用的不够好，如果能利用好了，我也许还会遇见更好的自己吧。由于因为个人条件所限，我也长期陷入精神内耗之中，想到之前一个朋友安慰我的话：我要做的就是随时准备好等待机会的到来，我当时也没在意，觉得好机会应该不会轮上我吧。但是一次次好机会真的到来了，我都没抓好。</p><p>由于基础很差+身边没有类似环境，转开发对我来说是一个漫长且孤独的过程。希望新的一年不要再因为个人条件所限继续精神内耗，不要摆烂，秋招争取拿到满意的offer，今年内也争取顺利达到毕业要求。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;2022年虽然也是碌碌无为的一年，什么都做的不好，但是也取得了一些超预期的成绩。在最近的关头写个总结。&lt;/p&gt;</summary>
    
    
    
    <category term="杂谈" scheme="https://lovebettygirl.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="年度总结" scheme="https://lovebettygirl.github.io/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>一则迟来的碎碎念</title>
    <link href="https://lovebettygirl.github.io/posts/c5cc4bc3/"/>
    <id>https://lovebettygirl.github.io/posts/c5cc4bc3/</id>
    <published>2022-11-06T17:04:07.000Z</published>
    <updated>2022-11-06T18:12:43.176Z</updated>
    
    <content type="html"><![CDATA[<p>这件事发生在一个月之前。因为我太热心，帮助了一位牛客网友找到了实习，却没得到应有回报的事情（好歹有点表示吧，我发了这段文字才开始说请我吃饭？说什么都晚了，求生欲真的强的一批，我怕了）。我没有完全明示，只是想以一种更高级的手段抨击他罢了。</p><p>社会教我做人，这一天跟很多朋友聊天，也就「我如何处理众多来询问我项目或者找实习取经的牛客网友」给出了建议。很感谢父母、老社会人以及善于沟通交流的其他朋友们的建议。我受教了。今后做人不会再这么善良。害人之心不可有，防人之心不可无。不过再想想，我帮助过的大部分人中，还是有点感恩之心的，突然间又感到有点欣慰。不指望你「滴水之恩当涌泉相报」吧，好歹给点物质感谢的表示就行啊，哪怕只是个客套话。</p><p>我的过分善良成就了一位竞争对手，这篇小作文，也将激励我从11月开始，要为秋招不懈努力。又想到了高中班主任说过的一句话：「一分干掉一千人」。希望一年后我再回看这篇小作文，我兑现到了哪一步。希望今年的我，不会成为明年的笑话吧。</p><p>我的运气虽然一直很差，但是我不允许任何人，以及这个世界亵渎我的努力。<strong>化悲愤为动力，是我这么多年走到现在的秘诀</strong>。这段文字也会一直激励我前行。话说回来，我总是强调和相信「天道酬勤」，<strong>终究只是一厢情愿罢了</strong>。就像是我暑假面试疯狂舔面试官一样，一厢情愿觉得自己准备好了就会要你一样（不招人的组，你准备再好都会成为hr眼中用来刷kpi的工具人）。实际上这个国度就是这样，总是强调个人努力，但是丝毫比不过遇上了好运气和好机遇强，运气总是比努力重要的多，甚至决定了你的一生。我就是一个鲜活的例子。想到这个，眼泪止不住往下流。</p><p>准备如果真的秋招成功了，尘埃落定了，我再想办法<strong>收费并给予</strong>这样的帮助。准备也开个公众号，开知识星球噶韭菜，看着大家天天为了大厂打卡，然后再回答大家的问题，岂不美哉。哎，这事情明年这个时候，拿到满意offer了再考虑吧。</p><p>在朋友圈发这些东西之前，我也想过这种行为是不是显得我格局太小，心眼太小？跟一个无关紧要的人置气，而且就是我前进道路上，一颗无关紧要的绊脚石罢了，自己大概率也能踢开它。希望真的会成为自己努力的动力，而不是成为让我从此失去信心而沉沦的源头。</p><p>后来想了想，有些话是真的不吐不快的。</p><a id="more"></a><hr><p>你唾手可得的一切，终将会以其他形式还给你；我本应得到却未得到的一切，也终将以其他形式还给我。</p><p>我始终相信天道酬勤，越努力越幸运。我相信我的努力，终将会被时间所认可，只是它到来的晚一些罢了，即使也遭遇了一时的挫折和现实、环境的阻拦，让我被迫错失最好的机遇。</p><p>我通过这一年来的努力好不容易得到的这一切，你凭借超凡的运气和机遇，以及我一年内努力的力量在短时间内唾手可得。可能你在背后也得意，自己一个月内得到了别人努力一年才得到的东西；可能也在笑我这一年的努力不值得，甚至觉得我努力方向错了，不及遇上一个千载难逢的机遇，以及自己到处求助别人强。</p><p>我相信，你即使现在唾手可得了这一切，省去了其他靠努力、靠时间积累的漫长过程，之后终将都会全数归还给你。 你现在借助运气和机遇飘的多高，之后就会摔得越惨。毕竟风口上的猪都能飞起来。</p><p>我也是过于善良，喜欢帮助别人，尽可能让别人少走弯路。却没想过自己帮助别人取得了成功，甚至连一句小小的感谢都换不到（物质感谢就更无从可谈了），只觉得自己成功只有自己的功劳（是自己social，找对了人、打赢了信息战的功劳，而不是我自己帮了忙的功劳），只知道继续索取、榨干我的一切，甚至觉得我提供的帮助只是举手之劳，觉得没帮够，没让你实现最高的目标，还想要更大的自行车。</p><p>前段时间，我曾因此怀疑过人生的不公，也怀疑过自己努力的方向是不是真的错了，也试图想从过去的挫折和苦恼中走出来。我也在想，我从来都不是一个容易因为挫折而垂头丧气的人，毕竟如果是自己的问题就总结和反思，不是自己的问题则静待更好的机遇出现。</p><p>可能是，自己帮了别人忙，成就了别人，自己的努力做了别人的嫁衣，别人没怎么感谢，甚至觉得嫁衣还不够好看，成为了导火索吧。我想通了，从以后开始，我也不会这么善良了。太善良只会给自己徒增苦恼，好人没好报。我不该帮助不该帮助的人，也是我活该了。</p><p>总是期望自己帮忙了，也能得到别人对等的帮忙。其他人怎么会帮竞争对手呢？人都是自私的，巴不得多榨干别人一分，好在最后凭借别人的力量，踩在别人头上，超越自己的竞争对手罢了。</p><p>诚然，这确实是一个只看结果不看过程的世界，别人只会关注你最终取得了什么，不会关注你取得的背后付出了多少努力和汗水，还是只凭借运气和机遇，还有别人的帮助，没付出多少努力。我慢慢也在学着接受这样的不公，毕竟好运从未眷顾过我这种非洲人。</p><p>成功固然需要努力，运气和机遇也同样重要。但是，努力决定下限，运气和机遇决定上限。 我相信真正努力过的人，再坏的机遇和运气都不会影响他取得最后的成功；没努力过的人，只想借别人力量，只想借助运气和机遇腾飞，终将会失败。</p><p>不是不报，时候未到，还有一年，走着瞧。我相信上帝不会亏待真正努力过的人，并且让只凭借运气和机遇成功的人现出原形。是骡子还是马，在最终的考验中，拉出来遛一遛便知。</p><p>共勉。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这件事发生在一个月之前。因为我太热心，帮助了一位牛客网友找到了实习，却没得到应有回报的事情（好歹有点表示吧，我发了这段文字才开始说请我吃饭？说什么都晚了，求生欲真的强的一批，我怕了）。我没有完全明示，只是想以一种更高级的手段抨击他罢了。&lt;/p&gt;
&lt;p&gt;社会教我做人，这一天跟很多朋友聊天，也就「我如何处理众多来询问我项目或者找实习取经的牛客网友」给出了建议。很感谢父母、老社会人以及善于沟通交流的其他朋友们的建议。我受教了。今后做人不会再这么善良。害人之心不可有，防人之心不可无。不过再想想，我帮助过的大部分人中，还是有点感恩之心的，突然间又感到有点欣慰。不指望你「滴水之恩当涌泉相报」吧，好歹给点物质感谢的表示就行啊，哪怕只是个客套话。&lt;/p&gt;
&lt;p&gt;我的过分善良成就了一位竞争对手，这篇小作文，也将激励我从11月开始，要为秋招不懈努力。又想到了高中班主任说过的一句话：「一分干掉一千人」。希望一年后我再回看这篇小作文，我兑现到了哪一步。希望今年的我，不会成为明年的笑话吧。&lt;/p&gt;
&lt;p&gt;我的运气虽然一直很差，但是我不允许任何人，以及这个世界亵渎我的努力。&lt;strong&gt;化悲愤为动力，是我这么多年走到现在的秘诀&lt;/strong&gt;。这段文字也会一直激励我前行。话说回来，我总是强调和相信「天道酬勤」，&lt;strong&gt;终究只是一厢情愿罢了&lt;/strong&gt;。就像是我暑假面试疯狂舔面试官一样，一厢情愿觉得自己准备好了就会要你一样（不招人的组，你准备再好都会成为hr眼中用来刷kpi的工具人）。实际上这个国度就是这样，总是强调个人努力，但是丝毫比不过遇上了好运气和好机遇强，运气总是比努力重要的多，甚至决定了你的一生。我就是一个鲜活的例子。想到这个，眼泪止不住往下流。&lt;/p&gt;
&lt;p&gt;准备如果真的秋招成功了，尘埃落定了，我再想办法&lt;strong&gt;收费并给予&lt;/strong&gt;这样的帮助。准备也开个公众号，开知识星球噶韭菜，看着大家天天为了大厂打卡，然后再回答大家的问题，岂不美哉。哎，这事情明年这个时候，拿到满意offer了再考虑吧。&lt;/p&gt;
&lt;p&gt;在朋友圈发这些东西之前，我也想过这种行为是不是显得我格局太小，心眼太小？跟一个无关紧要的人置气，而且就是我前进道路上，一颗无关紧要的绊脚石罢了，自己大概率也能踢开它。希望真的会成为自己努力的动力，而不是成为让我从此失去信心而沉沦的源头。&lt;/p&gt;
&lt;p&gt;后来想了想，有些话是真的不吐不快的。&lt;/p&gt;</summary>
    
    
    
    <category term="杂谈" scheme="https://lovebettygirl.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="碎碎念" scheme="https://lovebettygirl.github.io/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    <category term="失败" scheme="https://lovebettygirl.github.io/tags/%E5%A4%B1%E8%B4%A5/"/>
    
    <category term="成功" scheme="https://lovebettygirl.github.io/tags/%E6%88%90%E5%8A%9F/"/>
    
    <category term="机遇" scheme="https://lovebettygirl.github.io/tags/%E6%9C%BA%E9%81%87/"/>
    
    <category term="运气" scheme="https://lovebettygirl.github.io/tags/%E8%BF%90%E6%B0%94/"/>
    
    <category term="努力" scheme="https://lovebettygirl.github.io/tags/%E5%8A%AA%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>安装CUDA的一些坑</title>
    <link href="https://lovebettygirl.github.io/posts/75df0b52/"/>
    <id>https://lovebettygirl.github.io/posts/75df0b52/</id>
    <published>2022-04-28T10:17:40.000Z</published>
    <updated>2022-04-28T12:14:48.580Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>一般来说，进行深度学习的任务时，为了训练的速度更快一些，一般会在GPU上进行训练。除了安装Tensorflow或Pytorch以外，还会安装CUDA和cuDNN（针对深度神经网络的加速库）来加速训练。</p><p>之前就听身边人说这东西很难安装，我当时还在想有啥东西能为难我这种配环境高手的。结果经过这一次痛苦的安装过程，自信心是真的受到了打击。</p><p>为了应对以后还有可能做同样事情的可能（当然，毕业了之后绝无可能），决定用这篇文章备忘一下。</p><a id="more"></a><h2 id="安装步骤">安装步骤</h2><h3 id="检查显卡驱动">检查显卡驱动</h3><p>首先得确认该机器是否有NVIDIA独立显卡。然后再检查是否安装了NVIDIA显卡驱动。</p><p>安装了之后在终端中输入 <code>nvidia-smi</code> 检查显卡驱动的安装情况。</p><p>其中，右上角的CUDA版本表示机器当前能安装的CUDA的最高版本：</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20220428184513462.png" alt="image-20220428184513462" style="zoom:50%;"></p><p>当然，由于Pytorch和Tensorflow目前不一定支持这个最高版本，所以一般不按照这个最高版本安装！</p><p>由于我用的机器已经有了显卡驱动，所以这一步的坑还没有踩，以后再说。</p><h3 id="下载并安装cuda和cudnn">下载并安装CUDA和cuDNN</h3><ol type="1"><li><p>在<a href="https://developer.nvidia.com/cuda-toolkit-archive">这里</a>找到想安装的CUDA版本，如果是Ubuntu，可以按照如下选择，按照如下方式安装（记住如果安装了显卡驱动，在安装的时候就不要勾选安装驱动了，否则会重复安装）：</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20220428185206312.png" alt="image-20220428185206312" style="zoom:50%;"></p></li><li><p>然后在<a href="https://developer.nvidia.com/rdp/cudnn-archive">这里</a>根据上一步选择的CUDA版本，下载对应版本的cuDNN。第一次下载需要注册。</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20220428185538492.png" alt="image-20220428185538492" style="zoom:50%;"></p></li></ol><p>下载了cuDNN之后，解压下载下来的压缩包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf &lt;压缩包&gt;</span><br></pre></td></tr></table></figure><p>将压缩包中对应的文件拷贝到CUDA安装路径的对应位置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo cp cuda/lib64/* /usr/<span class="built_in">local</span>/cuda-版本号/lib64/</span><br><span class="line">sudo cp cuda/include/* /usr/<span class="built_in">local</span>/cuda-版本号/include/ </span><br><span class="line">sudo chmod a+r /usr/<span class="built_in">local</span>/cuda-版本号/include/cudnn.h /usr/<span class="built_in">local</span>/cuda-版本号/lib64/libcudnn*</span><br></pre></td></tr></table></figure><p>在 <code>~/.bashrc</code> 中加入环境变量（这是用户变量，如果想加入系统变量，在Ubuntu应该编辑的是 <code>/etc/bash.bashrc</code>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/cuda-版本号/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/usr/<span class="built_in">local</span>/cuda-版本号/lib64:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure><p>让设置的环境变量立即生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"><span class="comment"># 如果编辑的是/etc/bash.bashrc：</span></span><br><span class="line"><span class="built_in">source</span> /etc/bash.bashrc</span><br></pre></td></tr></table></figure><h3 id="检查是否安装成功">检查是否安装成功</h3><p>在终端中输入命令：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvcc -V</span><br></pre></td></tr></table></figure><p>如果见到了类似如下的信息，说明已经安装了。（如果之前不知道是否安装了CUDA，如果没见到以下的信息，大概率就是没安装了）。</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20220428191021091.png" alt="image-20220428191021091" style="zoom:50%;"></p><p>但是仅凭上述信息无法判断是否安装成功，需要编译并运行CUDA提供的 <code>deviceQuery</code> 工具：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/cuda-版本号/samples/1_Utilities/deviceQuery</span><br><span class="line">sudo make</span><br><span class="line">./deviceQuery</span><br></pre></td></tr></table></figure><p>输出以下信息说明安装成功：</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20220428192129022.png" alt="image-20220428192129022" style="zoom:50%;"></p><h3 id="验证在pytorch中的可用性">验证在Pytorch中的可用性</h3><p>在 Python 终端中，按照如下输入如果能得到 <code>True</code> 说明Pytorch可以使用CUDA来训练了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> torch</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(torch.cuda.is_available())</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>如果想查看有几个GPU可以用，可以输入 <code>torch.cuda.device_count()</code> 来查看。</p><h2 id="如何选择cuda版本">如何选择CUDA版本</h2><p>上面的步骤乍一看很简单。但是这个东西最坑的地方在于，安装成功却不一定能正常使用。</p><p>如果跑程序的时候出现了类似以下的错误，大概率是因为安装的Pytorch版本和CUDA版本不兼容。</p><p>（按照支持的最高版本CUDA 11.4安装，使用项目作者推荐的Pytorch版本（1.4.0））</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20220428193311332.png" alt="image-20220428193311332" style="zoom:50%;"></p><p>（Pytorch升级到1.9.0，CUDA降级到11.1）</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20220428193425602.png" alt="image-20220428193425602" style="zoom:50%;"></p><p>那么解决的思路无非是两种：</p><ul><li><p>Pytorch版本较低，降低CUDA版本</p><ul><li><p>首先是像之前提的那样，不要使用上述提到的支持的最高版本安装</p></li><li><p>安装的CUDA版本不能太低，否则编译 <code>deviceQuery</code> 可能会出现如下错误。表示GPU过于新，不支持对应的架构（当然，太低的版本可能也不支持系统的gcc版本）：</p><p>最初降低到了1.4.0对应的10.1版本，10.1版本也是无法运行。编译 <code>deviceQuery</code> 出错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 降低到10.1版本出现的</span></span><br><span class="line">nvcc fatal: Unsupported gpu architecture <span class="string">&#x27;compute_30&#x27;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>升级Pytorch</p></li></ul><h3 id="下载cuda版本对应的pytorch版本">下载CUDA版本对应的Pytorch版本</h3><p>可以从<a href="https://pytorch.org/get-started/previous-versions/">这里</a>查询Pytorch各个版本支持的CUDA版本。</p><p>例如，从上述链接中查出了Pytorch 1.9.0版本支持CUDA的10.2和11.1版本。但是由于设备的GPU太新，按照10.x版本无法正常运行。所以选择CUDA 11.1版本。但还是有一个坑：</p><p>通过 <code>pip</code> 安装 Pytorch 1.9.0：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install torch==1.9.0</span><br></pre></td></tr></table></figure><p>在Python终端中，输入 <code>torch.version.cuda</code> 可以查看当前Pytorch版本支持的CUDA版本，输入 <code>torch.__version__</code> 查看当前Pytorch的版本。</p><p>输出如下：</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20220428200117828.png" alt="image-20220428200117828" style="zoom:50%;"></p><p>说明上述方法安装的Pytorch 1.9.0版本只支持CUDA 10.2，但是机器安装的是CUDA 11.1，两者之间还是不兼容。</p><p>因此需要安装支持CUDA 11.1的Pytorch1.9.0版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install torch==1.9.0+cu111 -f https://download.pytorch.org/whl/torch_stable.html</span><br></pre></td></tr></table></figure><p>这样输出就正常了，程序也能正常运行了：</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20220428200546030.png" alt="image-20220428200546030" style="zoom:50%;"></p><h2 id="多个cuda版本并存">多个CUDA版本并存</h2><p>由于第一次安装，当时安装的时候也没做好功课。结果面临要卸载之前安装好的CUDA的问题，很麻烦，而且也未必能卸载干净。</p><p>其实可以不用卸载，多个版本共存也是可以的，这样对于不同的Pytorch版本，也比较灵活。</p><p>只要修改好环境变量即可，不用的版本就注释掉：</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20220428201045821.png" alt="image-20220428201045821" style="zoom:50%;"></p><h2 id="后记">后记</h2><p>在无奈之下，我最终选择升级Pytorch，降级CUDA。不过侥幸的是，我运行的推荐使用Pytorch 1.4.0的代码也能正常运行。但是换了其他代码就不一定行了。因此在有些情况下，必须要使用低版本的Pytorch。至于怎么解决CUDA版本低带来的问题，到时候遇到了再说吧。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;一般来说，进行深度学习的任务时，为了训练的速度更快一些，一般会在GPU上进行训练。除了安装Tensorflow或Pytorch以外，还会安装CUDA和cuDNN（针对深度神经网络的加速库）来加速训练。&lt;/p&gt;
&lt;p&gt;之前就听身边人说这东西很难安装，我当时还在想有啥东西能为难我这种配环境高手的。结果经过这一次痛苦的安装过程，自信心是真的受到了打击。&lt;/p&gt;
&lt;p&gt;为了应对以后还有可能做同样事情的可能（当然，毕业了之后绝无可能），决定用这篇文章备忘一下。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://lovebettygirl.github.io/categories/Python/"/>
    
    
    <category term="Python" scheme="https://lovebettygirl.github.io/tags/Python/"/>
    
    <category term="Pytorch" scheme="https://lovebettygirl.github.io/tags/Pytorch/"/>
    
    <category term="CUDA" scheme="https://lovebettygirl.github.io/tags/CUDA/"/>
    
    <category term="深度学习" scheme="https://lovebettygirl.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>编写第一个WebAssembly模块</title>
    <link href="https://lovebettygirl.github.io/posts/a8e1e305/"/>
    <id>https://lovebettygirl.github.io/posts/a8e1e305/</id>
    <published>2022-01-29T12:45:38.000Z</published>
    <updated>2022-01-29T12:49:17.749Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境">环境</h2><ul><li>操作系统：Ubuntu 18.04 64位</li><li>Chrome版本：84.0.4147.89，64位</li><li>Python版本：3.7.10</li><li>Emscripten SDK版本：3.1.2</li></ul><a id="more"></a><h2 id="预备工作">预备工作</h2><p>查看系统是否支持 <code>wasm</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&#x27;wasm&#x27;</span> /etc/mime.types</span><br></pre></td></tr></table></figure><p>若上述结果未显示，需要在文件 <code>/etc/mine.types</code> 中加入对 <code>wasm</code> 的支持：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/mime.types</span><br></pre></td></tr></table></figure><p>在其中加入 <code>application/wasm    wasm</code> ，保存文件即可。</p><h2 id="下载并安装-emscripten-sdk">下载并安装 Emscripten SDK</h2><p>Emscripten 工具包是将 C/C++代码编译为 WebAssembly 字节码的最成熟工具包。</p><p>从 GitHub 中下载代码：<a href="https://github.com/emscripten-core/emsdk" class="uri">https://github.com/emscripten-core/emsdk</a> 到本地，假设路径为 <code>EMSDK_HOME</code>。</p><p>进入到该目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> EMSDK_HOME</span><br></pre></td></tr></table></figure><p>下载 SDK 的最新工具：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./emsdk install latest</span><br></pre></td></tr></table></figure><p>运行以下命令来激活最新的 SDK：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./emsdk activate latest</span><br></pre></td></tr></table></figure><p>查看用 SDK 安装的工具列表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./emsdk list</span><br></pre></td></tr></table></figure><p>之后若想访问 Emscripten SDK 中的工具，可以使用如下途径（选择其一即可）：</p><h3 id="将相关路径加入到环境变量中">将相关路径加入到环境变量中</h3><p>例如在我的系统中，用户变量可定义在 <code>~/.bashrc</code> 中，系统变量可定义在 <code>/etc/bash.bashrc</code> 中。</p><p>往上述文件中的任意一个添加下述3条路径到环境变量 <code>PATH</code> 中：</p><ul><li><code>EMSDK_HOME</code></li><li><code>EMSDK_HOME/node/版本号/bin</code></li><li><code>EMSDK_HOME/upstream/emscripten</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;EMSDK_HOME:EMSDK_HOME/node/版本号/bin:EMSDK_HOME/upstream/emscripten:<span class="variable">$PATH</span>&quot;</span></span><br></pre></td></tr></table></figure><h3 id="激活环境">激活环境</h3><p>可在终端中输入如下命令为当前命令行激活环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> <span class="string">&quot;EMSDK_HOME/emsdk_env.sh&quot;</span></span><br></pre></td></tr></table></figure><p>也可在 <code>~/.bashrc</code> 或 <code>/etc/bash.bashrc</code> 中写入上述命令，这样每次打开终端就可以激活环境。</p><h2 id="用-emscripten-编译-cc并使用-html-模板">用 Emscripten 编译 C/C++并使用 HTML 模板</h2><p>可以创建一个模块，同时生成HTML和JavaScript文件。适用于快速测试代码，而不必创建 HTML 和 JavaScript 代码的时候。</p><p>编写程序 <code>calculate_primes.c</code> ，输出3到100000内的所有素数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;emscripten.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsPrime</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="number">2</span>) &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (value &lt;= <span class="number">1</span> || value % <span class="number">2</span> == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; (i * i) &lt;= value; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value % i == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> end = <span class="number">100000</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Prime numbers between %d and %d:\n&quot;</span>, start, end);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (IsPrime(i)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译 <code>calculate_primes.c</code> 并生成 WebAssembly 模块、JavaScript plumbing 文件和一个 HTML 模板。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emcc calculate_primes.c -o html_template.html</span><br></pre></td></tr></table></figure><p>下图中红框中标出的文件是新生成的文件。</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20220129190418016.png" alt="image-20220129190418016" style="zoom:50%;"></p><p>使用 Python 在当前路径上本地 Web 服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m http.server 8080</span><br></pre></td></tr></table></figure><p>在浏览器中打开 <a href="http://localhost:8080/html_template.html" class="uri">http://localhost:8080/html_template.html</a>：</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20220129194043637.png" alt="image-20220129194043637" style="zoom:50%;"></p><p>在上图中的黑色框中显示标准输出流中输出的内容。</p><h2 id="只让-emscripten-生成-javascript-plumbing-代码">只让 Emscripten 生成 JavaScript plumbing 代码</h2><p>可以创建一个模块，只生成 JavaScript 文件，不生成HTML文件。HTML 文件需要自己编写。这提供了一种灵活性，可以创建一个新的自定义 HTML 页面，也可以将生成的 JavaScript 引用添加到现有网页。这也是用于产品代码的典型方法，也是最常用的方法。</p><p>编译 <code>calculate_primes.c</code> ，让 Emscripten 创建 WebAssembly 模块和 JavaScript 文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emcc calculate_primes.c -o js_plumbing.js</span><br></pre></td></tr></table></figure><p>下图中红框中标出的文件是新生成的文件。</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20220129194748235.png" alt="image-20220129194748235" style="zoom:50%;"></p><p>创建HTML页面 <code>js_plumbing.html</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        HTML page I created for my WebAssembly module.</span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js_plumbing.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 Python 在当前路径上本地 Web 服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m http.server 8080</span><br></pre></td></tr></table></figure><p>在浏览器中打开 <a href="http://localhost:8080/js_plumbing.html" class="uri">http://localhost:8080/js_plumbing.html</a>：</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20220129195342982.png" alt="image-20220129195342982" style="zoom:50%;"></p><p>在浏览器的开发者工具的控制台中显示标准输出流输出的内容。</p><h2 id="让-emscripten-只生成-webassembly-文件">让 Emscripten 只生成 WebAssembly 文件</h2><p>可以只创建一个模块。此时必须自己编写 HTML 文件并下载和实例化模块所需要的 JavaScript。这个方法不太常用。</p><p>编写文件 <code>side_module.c</code>，该模块作为副模块（可以理解为不包含 <code>main()</code> 函数的C/C++模块），只包含一个递增函数 <code>Increment()</code> 和一个递减函数 <code>Decrement()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Increment</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (value + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Decrement</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (value - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译 <code>side_module.c</code> 并生成 WebAssembly 模块作为副模块（只导出 <code>Increment()</code> 这一个函数）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emcc side_module.c -s SIDE_MODULE=2 -O1 -s EXPORTED_FUNCTIONS=[<span class="string">&#x27;_Increment&#x27;</span>] -o side_module.wasm</span><br></pre></td></tr></table></figure><p>编译 <code>side_module.c</code> 并生成 WebAssembly 模块作为副模块（导出两个或多个函数）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emcc side_module.c -s SIDE_MODULE=2 -O1 -s <span class="string">&quot;EXPORTED_FUNCTIONS=[&#x27;_Increment&#x27;,&#x27;_Decrement&#x27;]&quot;</span> -o side_module.wasm</span><br></pre></td></tr></table></figure><ul><li><code>-s SIDE_MODULE=2</code> 指明在生成的模块中不包含 C 标准库代码，也不生成 JavaScript plumbing 文件。</li><li><code>-O1</code>：编译器优化标记。如果没有指定优化标记，则 Emscripten 会使用默认的 <code>-O0</code>，这表示不执行任何优化。现在这个场景下，如果不进行任何优化，那么会在试图加载这个模块的时候引发链接错误。通过移除多余的导入，添加非 <code>-O0</code> 的优化标记会修正这个问题， 因此要使用下一级优化标志 <code>-O1</code>。</li><li><code>-s EXPORTED_FUNCTIONS</code> 指定导出函数供JavaScript代码使用。要导出的函数名前需要包含下划线字符。注意上述指定多个导出函数的语法，首先是需要用双引号包裹命令行数组 <code>EXPORTED_FUNCTIONS</code>，同时数组中不同元素之间以逗号分隔，不能有空格。</li></ul><p>新生成了 <code>side_module.wasm</code> ，如下图红框标示：</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20220129202815378.png" alt="image-20220129202815378" style="zoom:50%;"></p><p>编写 HTML 文件 <code>side_module.html</code> ，用于下载并实例化刚刚生成的 WebAssembly 模块 <code>side_module.wasm</code>，并调用指定的导出函数 <code>Increment()</code> 和 <code>Decrement()</code>，输出结果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        HTML page I created for my WebAssembly module.</span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> memory = <span class="keyword">new</span> WebAssembly.Memory(&#123;<span class="attr">initial</span>: <span class="number">256</span>, <span class="attr">maximum</span>: <span class="number">256</span>&#125;);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> importObject = &#123;</span></span><br><span class="line">                env: &#123;</span><br><span class="line"><span class="javascript">                    <span class="string">&#x27;__table_base&#x27;</span>: <span class="number">0</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="string">&#x27;memory&#x27;</span>: memory,</span></span><br><span class="line"><span class="javascript">                    <span class="string">&#x27;__memory_base&#x27;</span>: <span class="number">1024</span>,</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"><span class="javascript">            <span class="comment">// 判断浏览器是否支持WebAssembly</span></span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="keyword">function</span> <span class="title">isWebAssemblySupported</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">if</span> (<span class="keyword">typeof</span> WebAssembly === <span class="string">&quot;object&quot;</span>) &#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">const</span> <span class="built_in">module</span> = <span class="keyword">new</span> WebAssembly.Module(<span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0x00</span>, <span class="number">0x61</span>, <span class="number">0x73</span>, <span class="number">0x6D</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>]));</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">if</span> (<span class="built_in">module</span> <span class="keyword">instanceof</span> WebAssembly.Module) &#123;</span></span><br><span class="line"><span class="javascript">                            <span class="keyword">const</span> moduleInstance = <span class="keyword">new</span> WebAssembly.Instance(<span class="built_in">module</span>);</span></span><br><span class="line"><span class="javascript">                            <span class="keyword">return</span> (moduleInstance <span class="keyword">instanceof</span> WebAssembly.Instance);</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="javascript">                &#125; <span class="keyword">catch</span> (err) &#123;&#125;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (isWebAssemblySupported()) &#123;</span><br><span class="line"><span class="javascript">                <span class="comment">// 判断浏览器是否支持instantiateStreaming函数，优先使用该函数</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">// instantiateStreaming相对instantiate较新，一些浏览器可能不支持</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">// 优先使用instantiateStreaming函数，支持在模块下载的同时编译代码，从而带来性能提升</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span> (<span class="keyword">typeof</span> WebAssembly.instantiateStreaming === <span class="string">&quot;function&quot;</span>) &#123;</span></span><br><span class="line"><span class="javascript">                    WebAssembly.instantiateStreaming(fetch(<span class="string">&quot;side_module.wasm&quot;</span>), importObject).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">const</span> value1 = result.instance.exports.Increment(<span class="number">17</span>);</span></span><br><span class="line"><span class="javascript">                        <span class="built_in">console</span>.log(value1.toString());</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">const</span> value2 = result.instance.exports.Decrement(<span class="number">10</span>);</span></span><br><span class="line"><span class="javascript">                        <span class="built_in">console</span>.log(value2.toString());</span></span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="javascript">                <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">                    fetch(<span class="string">&quot;side_module.wasm&quot;</span>).then(<span class="function"><span class="params">response</span> =&gt;</span> </span></span><br><span class="line">                        response.arrayBuffer()</span><br><span class="line"><span class="javascript">                    ).then(<span class="function"><span class="params">bytes</span> =&gt;</span> </span></span><br><span class="line">                        WebAssembly.instantiate(bytes, importObject)</span><br><span class="line"><span class="javascript">                    ).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">const</span> value1 = result.instance.exports.Increment(<span class="number">17</span>);</span></span><br><span class="line"><span class="javascript">                        <span class="built_in">console</span>.log(value1.toString());</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">const</span> value2 = result.instance.exports.Decrement(<span class="number">10</span>);</span></span><br><span class="line"><span class="javascript">                        <span class="built_in">console</span>.log(value2.toString());</span></span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.err(<span class="string">&quot;WebAssembly is not supported&quot;</span>);</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 Python 在当前路径上本地 Web 服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m http.server 8080</span><br></pre></td></tr></table></figure><p>在浏览器中打开 <a href="http://localhost:8080/side_module.html" class="uri">http://localhost:8080/side_module.html</a>：</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20220129203019638.png" alt="image-20220129203019638" style="zoom:50%;"></p><p>可以看到在浏览器的开发者工具的控制台中输出了正确的结果。</p><h3 id="注意">注意</h3><p>按照《WebAssembly实战》这本书上的代码并不能完成，浏览器会报错：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Uncaught</span> (in promise) Linkerror: Webassembly Instantiation: <span class="meta">Import</span> <span class="number">#1</span> module<span class="symbol">=env</span> <span class="meta">function</span>=<span class="string">&quot;__table_base&quot;</span> error: <span class="meta">global</span> <span class="meta">import</span> must be anumber</span><br></pre></td></tr></table></figure><p>报错的原因可能是Emscripten SDK版本和浏览器版本不兼容。查询资料之后按照此<a href="https://stackoverflow.com/questions/55884021/uncaught-in-promise-linkerror-webassembly-instantiation-import-1-module-en">链接</a>修改成功。</p><h2 id="参考资料">参考资料</h2><ul><li>《WebAssembly实战》</li><li><a href="https://stackoverflow.com/questions/55884021/uncaught-in-promise-linkerror-webassembly-instantiation-import-1-module-en" class="uri">https://stackoverflow.com/questions/55884021/uncaught-in-promise-linkerror-webassembly-instantiation-import-1-module-en</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;环境&quot;&gt;环境&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;操作系统：Ubuntu 18.04 64位&lt;/li&gt;
&lt;li&gt;Chrome版本：84.0.4147.89，64位&lt;/li&gt;
&lt;li&gt;Python版本：3.7.10&lt;/li&gt;
&lt;li&gt;Emscripten SDK版本：3.1.2&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="WebAssembly" scheme="https://lovebettygirl.github.io/categories/WebAssembly/"/>
    
    
    <category term="C++" scheme="https://lovebettygirl.github.io/tags/C/"/>
    
    <category term="C" scheme="https://lovebettygirl.github.io/tags/C/"/>
    
    <category term="JavaScript" scheme="https://lovebettygirl.github.io/tags/JavaScript/"/>
    
    <category term="HTML" scheme="https://lovebettygirl.github.io/tags/HTML/"/>
    
    <category term="WebAssembly" scheme="https://lovebettygirl.github.io/tags/WebAssembly/"/>
    
  </entry>
  
  <entry>
    <title>《MySQL是怎样运行的》笔记：InnoDB数据页 &amp; 记录存储结构</title>
    <link href="https://lovebettygirl.github.io/posts/4a9603aa/"/>
    <id>https://lovebettygirl.github.io/posts/4a9603aa/</id>
    <published>2021-12-02T16:29:51.000Z</published>
    <updated>2021-12-02T16:38:44.436Z</updated>
    
    <content type="html"><![CDATA[<p>本文内容来自<a href="https://juejin.cn/book/6844733769996304392">掘金小册《MySQL是怎样运行的》</a>。纸质书早就买了，但是还是喜欢看电子版的。</p><h1 id="innodb数据页基本概念">InnoDB数据页基本概念</h1><p><code>InnoDB</code>是一个将表中的数据存储到磁盘上的存储引擎，所以即使关机后重启我们的数据还是存在的。而真正处理数据的过程是发生在内存中的，所以需要把磁盘中的数据加载到内存中，如果是处理写入或修改请求的话，还需要把内存中的内容刷新到磁盘上。<code>InnoDB</code>将数据划分为若干个<strong>页</strong>，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为 <strong><em>16</em></strong> KB。也就是在一般情况下，一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。</p><a id="more"></a><blockquote><p>为什么页的大小默认16kb？The default 16KB page size or larger is appropriate for a wide range of workloads, particularly for queries involving table scans and DML operations involving bulk updates</p></blockquote><p><code>InnoDB</code> 有多种不同类型的页。存放表中记录的页面称为数据页（官方称为索引（<code>INDEX</code>）页）。</p><h1 id="innodb行格式">InnoDB行格式</h1><p>我们平时是<strong>以记录为单位</strong>来向表中插入数据的，行格式是表中的每个记录（行）在磁盘上的存储格式。</p><p>InnoDB一共有4种行格式：<code>Compact</code>、<code>Redundant</code>、<code>Dynamic</code>、<code>Compressed</code>。其中 <code>Dynamic</code> 是InnoDB默认的行格式。</p><p>可以在创建或修改表的语句中指定行格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 (列的信息) ROW_FORMAT<span class="operator">=</span>行格式名称</span><br><span class="line">    </span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 ROW_FORMAT<span class="operator">=</span>行格式名称</span><br></pre></td></tr></table></figure><p>一条记录（行）包含两个基本部分：记录的额外信息、记录的真实数据。</p><h2 id="记录的额外信息">记录的额外信息</h2><p>存储这一行中每一列的额外信息：数据长度、是否为NULL。以及固定字节数的记录头信息，用于存储该行的其他信息。</p><p>常见的记录头信息：</p><table><colgroup><col style="width: 15%"><col style="width: 15%"><col style="width: 53%"><col style="width: 16%"></colgroup><thead><tr class="header"><th>名称</th><th>大小（单位：bit）</th><th>描述</th><th>备注</th></tr></thead><tbody><tr class="odd"><td><code>预留位1</code></td><td><code>1</code></td><td>没有使用</td><td></td></tr><tr class="even"><td><code>预留位2</code></td><td><code>1</code></td><td>没有使用</td><td></td></tr><tr class="odd"><td><code>delete_mask</code></td><td><code>1</code></td><td>标记该记录是否被删除，1为已被删除</td><td></td></tr><tr class="even"><td><code>min_rec_mask</code></td><td><code>1</code></td><td>B+树的每层非叶子节点中的最小记录都会标记为1</td><td></td></tr><tr class="odd"><td><code>n_owned</code></td><td><code>4</code></td><td>一个页面中的记录被分为若干个组，<code>n_owned</code> 表示当前记录所在分组拥有的记录数，只有该分组的最后一条记录 <code>n_owned</code> 的值才大于0。用于辅助在该页内根据主键查找对应记录。</td><td></td></tr><tr class="even"><td><code>heap_no</code></td><td><code>13</code></td><td>表示当前记录在记录堆的位置信息（当前记录在本页中存放的相对位置），自己插入的记录从2开始，0和1分别表示最小记录和最大记录</td><td></td></tr><tr class="odd"><td><code>record_type</code></td><td><code>3</code></td><td>表示当前记录的类型，<code>0</code>表示普通记录，<code>1</code>表示B+树非叶子节点记录，<code>2</code>表示最小记录，<code>3</code>表示最大记录；自己插入的记录的都是普通记录</td><td>Redundant行格式没有</td></tr><tr class="even"><td><code>n_field</code></td><td><code>10</code></td><td>表示记录中列的数量</td><td>Redundant行格式特有</td></tr><tr class="odd"><td><code>1byte_offs_flag</code></td><td><code>1</code></td><td>标记字段长度偏移列表中每个列对应的偏移量是使用1字节还是2字节表示的，1为1字节，0为2字节</td><td>Redundant行格式特有</td></tr><tr class="even"><td><code>next_record</code></td><td><code>16</code></td><td>表示下一条记录的相对位置，即表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。</td><td></td></tr></tbody></table><ul><li><p><code>next_record</code>：表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。从最小记录到最大记录，未被删除的每一条记录按照主键值从小到大顺序链接成一个<strong>单向链表</strong>，链表第一个节点是最小记录，链表最后一个节点是最大记录。</p><p>由下图可知：</p><ul><li>一条记录中的 <code>next_record</code> 值为：<code>当前行所有自定义列数据长度</code> + <code>下一行记录的额外信息长度</code> + <code>下一行所有隐藏列数据长度</code></li><li>最大记录前的记录的 <code>next_record</code> 值为：-（<code>当前行记录的额外信息长度</code> + <code>当前行之前所有数据行的长度</code> + <code>最大记录suprenum长度</code> ）</li><li>最大记录是最后一条记录， <code>next_record</code> 值为0</li></ul><p><img data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/8/16a95c10773d8cee~tplv-t2oaga2asx-watermark.image" alt="image_1c9qs1mn2t3j1nt344116nk15uf2p.png-119.7kB" style="zoom:67%;"></p><p><img data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/8/16a95c1084c440b4~tplv-t2oaga2asx-watermark.image" alt="image_1cot1r96210ph1jng1td41ouj85c13.png-120.5kB" style="zoom: 67%;"></p></li><li><p><code>delete_mask</code>：标记该记录是否被删除，1为已被删除。这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后把其他的记录在磁盘上重新排列需要性能消耗，所以只是打一个删除标记而已，所有被删除掉的记录都会根据 <code>next_record</code> 属性，按照主键从小到大的顺序链接成一个的<code>垃圾链表</code>，在这个链表中的记录占用的空间称为<code>可重用空间</code>，之后如果有新记录插入到表中的话，可能会重用这些空间，把这些被删除的记录占用的存储空间覆盖掉。避免空间的频繁分配和释放。</p><p>将 <code>delete_mask</code> 位设置为1和将被删除的记录加入到垃圾链表中其实是两个阶段，涉及到事务。</p><p><img data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/8/16a95c108ee1da43~tplv-t2oaga2asx-watermark.image" alt="image_1cul8slbp1om0p31b3u1be11gco9.png-119.6kB" style="zoom:67%;"></p></li><li><p><code>heap_no</code>：表示当前记录在本<code>页</code>中的相对位置，从图中可以看出来，自己插入的记录在本<code>页</code>中的位置从2开始依次往后递增，自己插入的第一条记录 <code>heap_no</code> 是2，第二条记录 <code>heap_no</code> 是3，以此类推。<code>heap_no</code> 为0和1的记录分别表示两条虚拟记录（自动创建的）：最小记录和最大记录。</p><ul><li>在页面前面的记录 <code>heap_no</code> 相对较小</li><li>在页面后面的记录 <code>heap_no</code> 相对较大</li><li>每申请一条记录的存储空间时，该记录比物理位置在它之前的那条记录的 <code>heap_no</code> 值大 1</li></ul></li></ul><h2 id="记录的真实数据">记录的真实数据</h2><p>存储这一行中每一列的真实数据。</p><h3 id="隐藏列">隐藏列</h3><p>除了自己定义的列以外，<code>MySQL</code>会为每个记录默认添加隐藏列，并且存放在自己定义的列前面：</p><table><thead><tr class="header"><th>列名</th><th>存储的真实列名</th><th>是否必须</th><th>占用空间</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><code>row_id</code></td><td><code>DB_ROW_ID</code></td><td>否</td><td><code>6</code>字节</td><td>行ID，唯一标识一条记录</td></tr><tr class="even"><td><code>transaction_id</code></td><td><code>DB_TRX_ID</code></td><td>是</td><td><code>6</code>字节</td><td>事务ID</td></tr><tr class="odd"><td><code>roll_pointer</code></td><td><code>DB_ROLL_PTR</code></td><td>是</td><td><code>7</code>字节</td><td>回滚指针</td></tr></tbody></table><p>其中 <code>row_id</code> 可有可无，在没有自定义主键以及<code>Unique</code>键的情况下才会添加该列。如果用户没有定义主键，则选取一个<code>Unique</code>键作为主键，如果表中连<code>Unique</code>键都没有定义的话，则<code>InnoDB</code>会为表默认添加一个 <code>row_id</code> 列作为主键。</p><figure><img data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/12/169710e973b70372~tplv-t2oaga2asx-watermark.image" alt><figcaption>image_1c9h256f9nke14311adhtu61ie2dn.png-92kB</figcaption></figure><h2 id="compact行格式">Compact行格式</h2><p><img data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/12/169710e8fafc21aa~tplv-t2oaga2asx-watermark.image" alt="image_1c9g4t114n0j1gkro2r1h8h1d1t16.png-42.4kB" style="zoom: 67%;"></p><h3 id="记录的额外信息-1">记录的额外信息</h3><ul><li><p><strong>变长字段长度列表</strong>：这一行中变长字段（列）的长度需要在这里记录，字段的长度按照该行中列的数据存放顺序<strong>逆序</strong>存放，单位是字节。不存放使用定长数据类型且字符集为定长的字段长度，该行中值为 <code>NULL</code> 的变长字段长度也不存放。如果表中所有的列都不是变长列的话，就没有这一部分。</p><ul><li>变长字段（列）：数据类型为<strong>变长数据类型</strong>的列，例如 <code>VARCHAR(M)</code> 、<code>VARBINARY(M)</code>、各种TEXT类型，各种BL0B类型，<code>M</code> 表示该列存储最多<code>M</code>个字符（注意是字符不是字节）；或者采用了变长字符集（例如 <code>gbk</code>、<code>utf8</code>）、数据类型为 <code>CHAR(M)</code> 的列（存储一个空字符串也会占用 <code>字符集对应的最少字节数 * M</code>，这样设计不容易产生碎片但比较占空间）</li><li>该列的长度占用的字节数：假设该列使用的字符集中表示一个字符最多需要使用的字节数为 <code>W</code>，如果该列允许存储的最大字节数（<code>M×W</code>）超过255字节并且真实存储的字节数（<code>L</code>）超过127字节，则使用2个字节，否则使用1个字节。</li></ul></li><li><p><strong>NULL值列表</strong>：统计该行中允许为 <code>NULL</code> 值的列的值是否为 <code>NULL</code>。每一列对应一个二进制位，二进制位按照该行中列的数据存放顺序逆序存放。该列如果为 <code>NULL</code> 则存1，不为 <code>NULL</code> 则存0。如果表中所有列都不允许存放 <code>NULL</code> 值，就没有这一部分。</p><ul><li>占用字节数：必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补<code>0</code>，不够则加一个字节，以此类推。</li></ul></li><li><p><strong>记录头信息</strong>：由固定的5个字节组成。</p></li></ul><blockquote><p>MySQL根据表结构来判断变长字段长度列表的哪个字节、NULL值列表的哪一位、记录的真实数据部分的哪个字节属于哪一列的。</p></blockquote><blockquote><p>变长字段长度列表、NULL值列表中的信息都是逆序存放，这样通过 <code>next_records</code> 向左读取就是记录头信息，向右读取就是真实数据，记录中位置靠前的字段和它们对应的字段长度信息在内存中的距离更近，可能会提高高速缓存的命中率。</p></blockquote><h3 id="记录的真实数据-1">记录的真实数据</h3><p>对于自己定义的列，只存储该行中非 <code>NULL</code> 列的数据。如果该行中该列为 <code>NULL</code>，只会存在NULL值列表中，在记录的真实数据处就不再冗余存储。</p><h2 id="redundant行格式">Redundant行格式</h2><p>早期，在 <code>MySQL5.0</code>之前使用的一种行格式。</p><p><img data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/12/169710e99a69ba3d~tplv-t2oaga2asx-watermark.image" alt="image_1c9h896lcuqi16081qub1v8c12jkft.png-36.2kB" style="zoom: 67%;"></p><h3 id="记录的额外信息-2">记录的额外信息</h3><ul><li><p><strong>字段长度偏移列表</strong>：存放一行中<strong>所有列</strong>的长度信息，按照该行中列的数据存放顺序<strong>逆序</strong>存放每个列的偏移量，即每个列中的值占用的空间在「记录的真实数据」处结束的位置。</p><ul><li>偏移量的含义：例如列1的偏移量为 <code>0x06</code> ，表示列1的数据长度6字节。列2的偏移量 <code>0x0c</code>，表示列2的数据长度为 <code>0x0c - 0x06 = 0x06</code>，即6个字节。</li><li>每个列的偏移量都占1字节或者都占2字节，取决于「记录的真实数据」部分所有数据的长度。<ul><li>当记录的真实数据占用的字节数不大于127（十六进制<code>0x7F</code>）时，每个列对应的偏移量占用1个字节，否则占用2字节。</li><li>「记录头信息」<code>1byte_offs_flag</code> 属性标识了偏移量占1字节还是2字节（1为1字节，0为2字节）</li></ul></li><li>该部分中每个字节的最高位代表该列的值是否为 <code>NULL</code>，如果该位为1，那么该列的值为 <code>NULL</code>，否则不为 <code>NULL</code>。如果该列是定长数据类型，需要在记录的真实数据中存储 <code>0x00</code> 字节占位（定长数据类型的最大长度是多少个字节，就用多少个字节）；如果该列是变长数据类型，不占用记录的真实数据中任何空间，对应的长度为0（即偏移量和上一列的偏移量相同）。<ul><li>注意，在<code>Redundant</code>行格式中，数据类型为 <code>CHAR(M)</code> 的列总是在记录的真实数据中占用对应的最大字节数（<code>M×W</code>），这样设计虽然占空间，但不会产生碎片。</li></ul></li></ul></li><li><p><strong>记录头信息</strong>：由固定的6个字节组成。</p><ul><li>与<code>Compact</code>行格式的记录头信息有两处不同：<ul><li><code>Redundant</code>行格式多了<code>n_field</code>和<code>1byte_offs_flag</code>这两个属性。</li><li><code>Redundant</code>行格式没有<code>record_type</code>这个属性。</li></ul></li></ul></li></ul><h3 id="记录的真实数据-2">记录的真实数据</h3><p>和 <code>Compact</code> 行格式类似，不同的是所有自定义的列都会存储，包括该行中 <code>NULL</code> 值且使用定长数据类型的列，都会按照该数据类型最大长度来使用 <code>0x00</code> 占位存储。</p><h2 id="行溢出">行溢出</h2><ul><li>一行中所有的定长数据类型和 <code>VARCHAR(M)</code> 类型的列（不包括隐藏列和记录头信息，但是包括列的长度、NULL值标识占用的空间）最多总共可以存<code>65535</code>个字节（字符数量因不同字符集而异），除了 <code>BLOB</code>或者<code>TEXT</code>类型的列没有上限。</li><li>MySQL中的一个页一般占16kb（16384字节），并规定一个数据页<strong>至少要存放两条记录</strong>，也就是说一行最多存到一页一半的大小就会发生溢出</li><li>如果行中的列（无论是什么数据类型）存放的数据太多，并且没有超过这个上限，可能会发生行溢出</li></ul><p><code>Compact</code> 和 <code>Redundant</code> 行格式如果某一列发生了行溢出，该列在真实数据处只存储前<code>768</code>个字节，其他字节存储到溢出页中，并在这<code>768</code>个字节后记录20字节的对应溢出页的<strong>地址</strong>和溢出页的数据的占用的<strong>长度</strong>（字节）。并且在前面只会记录在本页中的数据长度，溢出页的数据长度不会算进去。</p><blockquote><p>注意，并不是只要一列的数据超过 <code>768</code> 字节就溢出了并且把其余的那些字节放入溢出页中，一列的数据超过 <code>768</code> 字节也不一定溢出。除非是太多了，导致这一页没法存下这一行（甚至接近了一页一半的大小），才会溢出。</p></blockquote><blockquote><p>溢出页的数据类型为 <code>FIL_PAGE_TYPE_BLOB</code>，和数据页（索引页、<code>FIL_PAGE_INDEX</code>）类型不一样。</p></blockquote><figure><img data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/12/169710e9aab47ea5~tplv-t2oaga2asx-watermark.image" alt><figcaption>image_1d48e3imu1vcp5rsh8cg0b1o169.png-149kB</figcaption></figure><h2 id="dynamic和compressed行格式">Dynamic和Compressed行格式</h2><p>类似于<code>Compact</code>行格式，除了对行溢出数据处理有点不同：</p><ul><li><p><code>Compact</code> 和 <code>Redundant</code> 行格式如果某一列发生了行溢出，该列在真实数据处只存储前<code>768</code>个字节，其他字节存储到溢出页中，并在这<code>768</code>个字节后记录20字节的对应溢出页的<strong>地址</strong>和溢出页的数据的占用的<strong>长度</strong>（字节）。</p><p><img data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/12/169710e9a5d5637a~tplv-t2oaga2asx-watermark.image" alt="image_1conbskr7apj19ns1d194vs1buo1t.png-35.8kB" style="zoom:80%;"></p></li><li><p><code>Dynamic</code>和<code>Compressed</code>行格式中如果某一列发生了行溢出，是把该列所有的字节都存储到溢出页中，只在记录的真实数据处存储这20个字节。</p><p><img data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/12/169710e9b2c2b71e~tplv-t2oaga2asx-watermark.image" alt="image_1conbtnmr1sg1hao1nf41pi1eb72a.png-29.9kB" style="zoom:80%;"></p><ul><li>相对于 <code>Compact</code> 的优势是如果发生了行溢出，能至少腾出700多的字节，这样一行数据可以存储更多列或更多其他列的数据。</li></ul></li></ul><p><code>Compressed</code>行格式和<code>Dynamic</code>不同的一点是，<code>Compressed</code>行格式会采用压缩算法对页面（包括数据页、溢出页）进行压缩，以节省空间。</p><h1 id="innodb数据页结构">InnoDB数据页结构</h1><p>一个<code>InnoDB</code>数据页的存储空间总共分为7个部分。</p><p><img data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/17/16f13ee1e2dfac7c~tplv-t2oaga2asx-watermark.image" alt="img" style="zoom: 50%;"></p><table><thead><tr class="header"><th>名称</th><th>中文名</th><th>占用空间大小</th><th>简单描述</th></tr></thead><tbody><tr class="odd"><td><code>File Header</code></td><td>文件头部</td><td><code>38</code>字节</td><td>页的一些通用信息</td></tr><tr class="even"><td><code>Page Header</code></td><td>页面头部</td><td><code>56</code>字节</td><td>数据页专有的一些信息</td></tr><tr class="odd"><td><code>Infimum + Supremum</code></td><td>最小记录和最大记录</td><td><code>26</code>字节</td><td>两个虚拟的行记录</td></tr><tr class="even"><td><code>User Records</code></td><td>用户记录</td><td>不确定</td><td>实际存储的行记录内容</td></tr><tr class="odd"><td><code>Free Space</code></td><td>空闲空间</td><td>不确定</td><td>页中尚未使用的空间</td></tr><tr class="even"><td><code>Page Directory</code></td><td>页面目录</td><td>不确定</td><td>页中的某些记录的相对位置</td></tr><tr class="odd"><td><code>File Trailer</code></td><td>文件尾部</td><td><code>8</code>字节</td><td>校验页是否完整</td></tr></tbody></table><h2 id="user-recordsfree-space">User Records、Free Space</h2><p>自己插入的记录会按照指定的<code>行格式</code>存储到<code>User Records</code>部分。每插入一条记录，都会从<code>Free Space</code>部分申请一个记录大小的空间划分到<code>User Records</code>部分，当<code>Free Space</code>部分的空间全部被<code>User Records</code>部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了。</p><p>各条记录在<code>User Records</code>中存储的时候并没有空隙。</p><h2 id="infinum-suprenum">Infinum + Suprenum</h2><p>存放最小记录和最大记录，对应的 <code>heap_no</code> 分别是0和1。</p><p>这两条记录InnoDB自动生成的，每个都只由5字节大小的<code>记录头信息</code>和8字节大小的一个固定的部分组成。</p><p><img data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/8/16a95c100ff0ccc2~tplv-t2oaga2asx-watermark.image" alt="image_1c9ra45eam7t1mil9o1h3ucqdhv.png-50.4kB" style="zoom:67%;"></p><h2 id="page-directory">Page Directory</h2><p>将数据页里面的数据分为几个组，每个组<strong>最后一条记录</strong>的头信息的 <code>n_owned</code> 记录该组有多少条记录，将每个组最后一条记录的<strong>相对页面起始字节的地址偏移量</strong>按从小到大的顺序存储在Page Directory（页目录）这一部分，称这个地址偏移量为槽。</p><figure><img data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/8/16a95c10e3449897~tplv-t2oaga2asx-watermark.image" alt><figcaption>image_1d6g64af2sgj1816ktl1q22dehp.png-189.1kB</figcaption></figure><p>最小记录所在的分组只能有 <strong><em>1</em></strong> 条记录，最大记录所在的分组拥有的记录条数只能在 <strong><em>1~8</em></strong> 条之间，剩下的分组中记录的条数范围只能在是 <strong><em>4~8</em></strong> 条之间。分组按照下边的步骤进行：</p><ul><li>初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。</li><li>之后每插入一条记录，都会从<code>页目录</code>中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的<code>n_owned</code>值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。</li><li>在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在<code>页目录</code>中新增一个<code>槽</code>来记录这个新增分组中最大的那条记录的偏移量。</li></ul><p>在一个数据页中查找指定主键值的记录的过程分为两步（假设槽的编号从0开始，槽的偏移量越大，编号也就越大）：</p><ol type="1"><li>通过二分法确定该记录所在的槽的编号 <code>i</code> ，并找到该槽所在分组中主键值最小的那条记录（需要通过上一个槽 <code>i - 1</code> 的最后一条记录的<code>next_record</code>属性找到下一条记录，即当前槽的第一条记录）。</li><li>通过记录的<code>next_record</code>属性遍历该槽 <code>i</code> 所在的组中的各个记录。</li></ol><h2 id="page-header">Page Header</h2><p>Page Header记录<strong>数据页</strong>中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等。</p><table><colgroup><col style="width: 20%"><col style="width: 13%"><col style="width: 65%"></colgroup><thead><tr class="header"><th>名称</th><th>占用空间大小</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><code>PAGE_N_DIR_SLOTS</code></td><td><code>2</code>字节</td><td>在页目录中的槽数量</td></tr><tr class="even"><td><code>PAGE_HEAP_TOP</code></td><td><code>2</code>字节</td><td>还未使用的空间最小地址，也就是说从该地址之后就是<code>Free Space</code></td></tr><tr class="odd"><td><code>PAGE_N_HEAP</code></td><td><code>2</code>字节</td><td>本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）</td></tr><tr class="even"><td><code>PAGE_FREE</code></td><td><code>2</code>字节</td><td>第一个已经标记为删除的记录地址（各个已删除的记录通过<code>next_record</code>也会组成一个单链表，这个单链表中的记录可以被重新利用）</td></tr><tr class="odd"><td><code>PAGE_GARBAGE</code></td><td><code>2</code>字节</td><td>已删除记录占用的字节数</td></tr><tr class="even"><td><code>PAGE_LAST_INSERT</code></td><td><code>2</code>字节</td><td>最后插入记录的位置</td></tr><tr class="odd"><td><code>PAGE_DIRECTION</code></td><td><code>2</code>字节</td><td>记录插入的方向</td></tr><tr class="even"><td><code>PAGE_N_DIRECTION</code></td><td><code>2</code>字节</td><td>一个方向连续插入的记录数量</td></tr><tr class="odd"><td><code>PAGE_N_RECS</code></td><td><code>2</code>字节</td><td>该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录）</td></tr><tr class="even"><td><code>PAGE_MAX_TRX_ID</code></td><td><code>8</code>字节</td><td>修改当前页的最大事务ID，该值仅在二级索引中定义</td></tr><tr class="odd"><td><code>PAGE_LEVEL</code></td><td><code>2</code>字节</td><td>当前页在B+树中所处的层级</td></tr><tr class="even"><td><code>PAGE_INDEX_ID</code></td><td><code>8</code>字节</td><td>索引ID，表示当前页属于哪个索引</td></tr><tr class="odd"><td><code>PAGE_BTR_SEG_LEAF</code></td><td><code>10</code>字节</td><td>B+树叶子段的头部信息，仅在B+树的Root页定义</td></tr><tr class="even"><td><code>PAGE_BTR_SEG_TOP</code></td><td><code>10</code>字节</td><td>B+树非叶子段的头部信息，仅在B+树的Root页定义</td></tr></tbody></table><ul><li><code>PAGE_DIRECTION</code>：假如新插入的一条记录的主键值比上一条记录的主键值大，我们说这条记录的插入方向是右边，反之则是左边。用来表示最后一条记录插入方向的状态就是<code>PAGE_DIRECTION</code>。</li><li><code>PAGE_N_DIRECTION</code>：假设连续几次插入新记录的方向都是一致的，<code>InnoDB</code>会把沿着同一个方向插入记录的条数记下来，这个条数就用<code>PAGE_N_DIRECTION</code>这个状态表示。当然，如果最后一条记录的插入方向改变了的话，这个状态的值会被清零重新统计。</li></ul><h2 id="file-header">File Header</h2><p>File Header记录页本身的信息，以及该页和其他页的关系信息，例如页的编号、上一页、下一页等。对所有类型的页通用。</p><table><thead><tr class="header"><th>名称</th><th>占用空间大小</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><code>FIL_PAGE_SPACE_OR_CHKSUM</code></td><td><code>4</code>字节</td><td>页的校验和（checksum值）</td></tr><tr class="even"><td><code>FIL_PAGE_OFFSET</code></td><td><code>4</code>字节</td><td>页号，每一个页都有一个唯一的页号，<code>InnoDB</code>通过页号来唯一定位一个页。</td></tr><tr class="odd"><td><code>FIL_PAGE_PREV</code></td><td><code>4</code>字节</td><td>上一个页的页号</td></tr><tr class="even"><td><code>FIL_PAGE_NEXT</code></td><td><code>4</code>字节</td><td>下一个页的页号</td></tr><tr class="odd"><td><code>FIL_PAGE_LSN</code></td><td><code>8</code>字节</td><td>页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number）</td></tr><tr class="even"><td><code>FIL_PAGE_TYPE</code></td><td><code>2</code>字节</td><td>该页的类型</td></tr><tr class="odd"><td><code>FIL_PAGE_FILE_FLUSH_LSN</code></td><td><code>8</code>字节</td><td>仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值</td></tr><tr class="even"><td><code>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</code></td><td><code>4</code>字节</td><td>页属于哪个表空间</td></tr></tbody></table><ul><li><p><code>FIL_PAGE_SPACE_OR_CHKSUM</code>：当前页面的校验和（checksum）。这样在比较两个很长的字节串之前先比较这两个长字节串的校验和，如果校验和都不一样两个长字节串肯定是不同的（校验和相同这两个串页未必相同），省去了直接比较两个比较长的字节串的时间损耗。</p></li><li><p><code>FIL_PAGE_TYPE</code>：当前<code>页</code>的类型</p><table><thead><tr class="header"><th>类型名称</th><th>十六进制</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><code>FIL_PAGE_TYPE_ALLOCATED</code></td><td>0x0000</td><td>最新分配，还没使用</td></tr><tr class="even"><td><code>FIL_PAGE_UNDO_LOG</code></td><td>0x0002</td><td>Undo日志页</td></tr><tr class="odd"><td><code>FIL_PAGE_INODE</code></td><td>0x0003</td><td>段信息节点</td></tr><tr class="even"><td><code>FIL_PAGE_IBUF_FREE_LIST</code></td><td>0x0004</td><td>Insert Buffer空闲列表</td></tr><tr class="odd"><td><code>FIL_PAGE_IBUF_BITMAP</code></td><td>0x0005</td><td>Insert Buffer位图</td></tr><tr class="even"><td><code>FIL_PAGE_TYPE_SYS</code></td><td>0x0006</td><td>系统页</td></tr><tr class="odd"><td><code>FIL_PAGE_TYPE_TRX_SYS</code></td><td>0x0007</td><td>事务系统数据</td></tr><tr class="even"><td><code>FIL_PAGE_TYPE_FSP_HDR</code></td><td>0x0008</td><td>表空间头部信息</td></tr><tr class="odd"><td><code>FIL_PAGE_TYPE_XDES</code></td><td>0x0009</td><td>扩展描述页</td></tr><tr class="even"><td><code>FIL_PAGE_TYPE_BLOB</code></td><td>0x000A</td><td>溢出页</td></tr><tr class="odd"><td><code>FIL_PAGE_INDEX</code></td><td>0x45BF</td><td>索引页，也就是我们所说的<code>数据页</code></td></tr></tbody></table></li><li><p><code>FIL_PAGE_PREV</code> 和 <code>FIL_PAGE_NEXT</code>：分别代表本页的上一个和下一个页的页号，所有的页通过这两个属性连接成一个<strong>双向链表</strong>。<strong>并不是所有类型的页都有这两个属性</strong>，数据页（也就是类型为<code>FIL_PAGE_INDEX</code>的页）是有这两个属性的。</p><figure><img data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/8/16a95c10eb9d61ce~tplv-t2oaga2asx-watermark.image" alt><figcaption>image_1ca00fhg418pl1f1a1iav1uo3aou9.png-90.9kB</figcaption></figure></li></ul><h2 id="file-trailer">File Trailer</h2><p>File Trailer用于检验一个页是否完整。针对各种类型的页都通用。为保证从内存中同步到磁盘的页的完整性，在页的首部和尾部都会存储页中数据的校验和和页面最后修改时对应的<code>LSN</code>值，如果首部和尾部的校验和和<code>LSN</code>值校验不成功的话，就说明同步过程出现了问题。</p><p>需要检验一个页是否完整的场景：<code>InnoDB</code>存储引擎会把数据存储到磁盘上，但是磁盘速度太慢，需要以<code>页</code>为单位把数据加载到内存中处理，如果该页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中。如果在同步了一半的时候中断电了，需要判断是同步完成还是失败。</p><ul><li><p>前4个字节代表页的校验和：和<code>File Header</code>中的校验和相对应。每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为<code>File Header</code>在页面的前边，所以校验和会被首先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的。如果写了一半儿断电了，那么磁盘中的这一页的 <code>File Header</code>中的校验和是已经修改过的页的校验和，而在<code>File Trailer</code>中的校验和是原先的页的校验和，二者不同则意味着同步中间出了错。</p><blockquote><p>面试题：innoDB数据从内存同步回磁盘时如何在断电的情况下保持同步。</p><p>发现磁盘中该页的 <code>File Header</code> 和 <code>File Trailer</code> 中的校验和不同步，需要根据redo log进行恢复。</p></blockquote></li><li><p>后4个字节代表页面被最后修改时对应的日志序列位置（LSN）：也是为了校验页的完整性的。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文内容来自&lt;a href=&quot;https://juejin.cn/book/6844733769996304392&quot;&gt;掘金小册《MySQL是怎样运行的》&lt;/a&gt;。纸质书早就买了，但是还是喜欢看电子版的。&lt;/p&gt;
&lt;h1 id=&quot;innodb数据页基本概念&quot;&gt;InnoDB数据页基本概念&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;InnoDB&lt;/code&gt;是一个将表中的数据存储到磁盘上的存储引擎，所以即使关机后重启我们的数据还是存在的。而真正处理数据的过程是发生在内存中的，所以需要把磁盘中的数据加载到内存中，如果是处理写入或修改请求的话，还需要把内存中的内容刷新到磁盘上。&lt;code&gt;InnoDB&lt;/code&gt;将数据划分为若干个&lt;strong&gt;页&lt;/strong&gt;，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为 &lt;strong&gt;&lt;em&gt;16&lt;/em&gt;&lt;/strong&gt; KB。也就是在一般情况下，一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="https://lovebettygirl.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MySQL" scheme="https://lovebettygirl.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://lovebettygirl.github.io/tags/MySQL/"/>
    
    <category term="InnoDB" scheme="https://lovebettygirl.github.io/tags/InnoDB/"/>
    
    <category term="数据页" scheme="https://lovebettygirl.github.io/tags/%E6%95%B0%E6%8D%AE%E9%A1%B5/"/>
    
  </entry>
  
  <entry>
    <title>C++ explicit关键字</title>
    <link href="https://lovebettygirl.github.io/posts/a6ee4d0c/"/>
    <id>https://lovebettygirl.github.io/posts/a6ee4d0c/</id>
    <published>2021-05-20T08:25:33.000Z</published>
    <updated>2021-05-20T12:27:21.703Z</updated>
    
    <content type="html"><![CDATA[<p>C++的 <code>explicit</code> 关键字用于修饰一个类的构造函数和拷贝构造函数，防止构造函数的隐式转换。</p><p>以下的文字仅在 <code>g++ v7.5.0</code> 和 <code>clang++ v11.0.3</code> 测试过。</p><a id="more"></a><p>之前使用 <code>string</code> 的时候总是会看到这样的用法，而且自己也总是这么使用，但是一直不知道是什么原理（也没有百度过），现在终于知道原来这是隐式转换导致的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;aaa&quot;</span>;</span><br></pre></td></tr></table></figure><p>首先先调用类型和等号右边值类型匹配的构造函数创建一个临时对象，再调用拷贝构造函数，参数传入这个临时对象，从而实现 <code>s</code> 的初始化。</p><p>自己做了一个尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cla1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    cla1(<span class="keyword">int</span> a) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;cla1(int a) &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    cla1(<span class="keyword">const</span> cla1 &amp;temp) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;cla1(const cla &amp;temp) &quot;</span> &lt;&lt; temp.a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = temp.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">cla1 <span class="title">c1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    cla1 c2 = <span class="number">2</span>;</span><br><span class="line">    cla1 c3 = c2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以下命令编译生成可执行文件，并运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ test1.cpp -o test1 &amp;&amp; ./test1</span><br></pre></td></tr></table></figure><p>发现运行结果是这样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cla1(<span class="keyword">int</span> a) <span class="number">1</span></span><br><span class="line">cla1(<span class="keyword">int</span> a) <span class="number">2</span></span><br><span class="line">cla1(<span class="keyword">const</span> cla &amp;temp) <span class="number">2</span></span><br></pre></td></tr></table></figure><p>可以发现，在创建对象 <code>c2</code> 的时候的行为并没有按照预期的先创建临时对象，再调用拷贝构造函数。而是直接调用参数类型和等号右边值类型匹配的构造函数一步到位了。了解了一下，原来是现在的编译器为了提高效率，跳过了调用拷贝构造函数这一步。如果加上 <code>-fno-elide-constructors</code> 选项就是原来这样了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ test1.cpp -o test1 -fno-elide-constructors &amp;&amp; ./test1</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cla1(<span class="keyword">int</span> a) <span class="number">1</span></span><br><span class="line">cla1(<span class="keyword">int</span> a) <span class="number">2</span></span><br><span class="line">cla1(<span class="keyword">const</span> cla &amp;temp) <span class="number">2</span></span><br><span class="line">cla1(<span class="keyword">const</span> cla &amp;temp) <span class="number">2</span></span><br></pre></td></tr></table></figure><p>如果对构造函数加上了 <code>explicit</code> 关键字，下面的代码会编译失败，因为 <code>explicit</code> 关键字抑制了隐式转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cla2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">cla2</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;cla2(int a) &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    cla2(<span class="keyword">const</span> cla2 &amp;temp) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;cla2(const cla &amp;temp) &quot;</span> &lt;&lt; temp.a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = temp.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">cla2 <span class="title">c4</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    cla2 c5 = <span class="number">2</span>; <span class="comment">// error: no viable conversion from &#x27;int&#x27; to &#x27;cla2&#x27;</span></span><br><span class="line">    cla2 c6 = c5;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果对拷贝构造函数加上了 <code>explicit</code> 关键字，下面的代码也会编译失败，因为 <code>explicit</code> 关键字抑制了拷贝构造函数的隐式调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cla3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    cla3(<span class="keyword">int</span> a) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;cla3(int a) &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">cla3</span><span class="params">(<span class="keyword">const</span> cla3 &amp;temp)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;cla3(const cla &amp;temp) &quot;</span> &lt;&lt; temp.a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = temp.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">cla3 <span class="title">c7</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    cla3 c8 = <span class="number">2</span>;</span><br><span class="line">    <span class="function">cla3 <span class="title">c9</span><span class="params">(c8)</span></span>; <span class="comment">// 显式调用不会报错</span></span><br><span class="line">    cla3 c10 = c8; <span class="comment">// error: no matching constructor for initialization of &#x27;cla3&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，如果删除了上面代码的第24句，编译器也是不会报错的。即使加了 <code>-fno-elide-constructors</code> 选项，第22行也会正常调用拷贝构造函数。</p><p>不加 <code>-fno-elide-constructors</code> 选项的结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cla3(<span class="keyword">int</span> a) <span class="number">1</span></span><br><span class="line">cla3(<span class="keyword">int</span> a) <span class="number">2</span></span><br><span class="line">cla3(<span class="keyword">const</span> cla &amp;temp) <span class="number">2</span></span><br></pre></td></tr></table></figure><p>加了 <code>-fno-elide-constructors</code> 选项的结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cla3(<span class="keyword">int</span> a) <span class="number">1</span></span><br><span class="line">cla3(<span class="keyword">int</span> a) <span class="number">2</span></span><br><span class="line">cla3(<span class="keyword">const</span> cla &amp;temp) <span class="number">2</span></span><br><span class="line">cla3(<span class="keyword">const</span> cla &amp;temp) <span class="number">2</span></span><br></pre></td></tr></table></figure><p>将拷贝构造函数变成 <code>private</code> ，以下的代码会编译失败。可以说明基本类型和 <code>class</code> 对象类型的隐式转换确实会引发拷贝构造函数的调用，只是编译器可以选择是否省略这一步。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cla1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    cla1(<span class="keyword">int</span> a) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;cla1(int a) &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    cla1(<span class="keyword">const</span> cla1 &amp;temp) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;cla1(const cla &amp;temp) &quot;</span> &lt;&lt; temp.a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = temp.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">cla1 <span class="title">c1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 以下代码都会报错</span></span><br><span class="line">    <span class="comment">// error: calling a private constructor of class &#x27;cla1&#x27;</span></span><br><span class="line">    cla1 c2 = <span class="number">2</span>;</span><br><span class="line">    <span class="function">cla1 <span class="title">c3</span><span class="params">(c2)</span></span>;</span><br><span class="line">    cla1 c4 = c2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++的 &lt;code&gt;explicit&lt;/code&gt; 关键字用于修饰一个类的构造函数和拷贝构造函数，防止构造函数的隐式转换。&lt;/p&gt;
&lt;p&gt;以下的文字仅在 &lt;code&gt;g++ v7.5.0&lt;/code&gt; 和 &lt;code&gt;clang++ v11.0.3&lt;/code&gt; 测试过。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://lovebettygirl.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="https://lovebettygirl.github.io/tags/C/"/>
    
    <category term="explicit" scheme="https://lovebettygirl.github.io/tags/explicit/"/>
    
  </entry>
  
  <entry>
    <title>Linux -bash 挖矿病毒查杀记</title>
    <link href="https://lovebettygirl.github.io/posts/a0e4304d/"/>
    <id>https://lovebettygirl.github.io/posts/a0e4304d/</id>
    <published>2021-05-12T11:45:06.000Z</published>
    <updated>2021-05-20T12:27:21.698Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景">背景</h2><p>今天要在实验室的虚拟机上配环境搭系统，我就从我的一台 Ubuntu 18.04 的虚拟机复制了一台作为要配环境的虚拟机。然而发现了异样，就是我每次打开 firefox 浏览器很快就会闪退，连执行 <code>make</code> 编译源代码的进程都被杀死了。于是我查看进程发现了这样一幕：</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210512202031008.png" alt="1"></p><p>好家伙，16个核全占满了，但是内存占用率却不高。而且CPU都是名为 <code>-bash</code> 的进程占的，还一核一个。</p><p>结合之前看到的<a href="https://mp.weixin.qq.com/s/j4vfelk1Eu-rl2s8B70_CQ">公众号文章</a>怀疑自己的虚拟机被挖矿了，但是又不敢十分确定，毕竟我不相信挖矿病毒还能侵入实验室的内网（抱歉是我读书太少了，生而为人，我很抱歉）。然后百度了一番，发现符合挖矿的特征（CPU占用超高，内存占用较少），确认了虚拟机的确被挖矿了。我杀掉这个进程也没用，马上类似的进程又卷土重来了。</p><a id="more"></a><h2 id="初期的一些失败的尝试">初期的一些失败的尝试</h2><h3 id="查看tcp连接">查看TCP连接</h3><p>从文章中学到的第一个方法，就是先查看有没有异常的TCP连接。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo netstat -napt</span><br></pre></td></tr></table></figure><p>果不其然，有点东西，揪出了可疑的外网IP地址 <code>51.79.73.21</code>，可疑的TCP连接建立了。</p><blockquote><p>实在抱歉，我就是要暴露你的IP地址，谁叫你用别人的算力去挖矿，真的不讲武德。</p></blockquote><figure><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210512202846141.png" alt><figcaption>2</figcaption></figure><p>再看看这条命令，就可以看到对应的域名为 <code>vps-e476f784.vps.ovh.ca</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo lsof -p &lt;进程号&gt;</span><br></pre></td></tr></table></figure><figure><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210512203305817.png" alt><figcaption>3</figcaption></figure><h3 id="查看进程对应可执行程序的符号链接">查看进程对应可执行程序的符号链接</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ls -l /proc/&lt;pid&gt;/exe</span><br></pre></td></tr></table></figure><p>好家伙，可执行程序文件都被删除了</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210512204222502.png" alt="4" style="zoom:50%;"></p><h3 id="查看定时任务">查看定时任务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo crontab -l</span><br></pre></td></tr></table></figure><p>还真有一个</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210512204520886.png" alt="5" style="zoom:50%;"></p><p><code>/home/user/.bash/bash</code> 的内容是这样的</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210512204716533.png" alt="6" style="zoom:50%;"></p><p>看不出来在干什么，先把这个文件夹删掉再说吧</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf /home/user/.bash</span><br></pre></td></tr></table></figure><p>删掉这个定时任务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo crontab -e</span><br></pre></td></tr></table></figure><p>再杀掉这个进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">kill</span> -9 &lt;pid&gt;</span><br></pre></td></tr></table></figure><p>好像一段时间之后CPU再也不100%占用了，是成功了吗？</p><p>然而我重启了虚拟机又开始这样了，计划失败了</p><h3 id="封锁网络流量">封锁网络流量</h3><p>既然前面的方法不起作用，那我封锁你的流量总可以吧</p><p>首先编辑 hosts 文件 <code>/etc/hosts</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/hosts</span><br></pre></td></tr></table></figure><p>加入以下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 vps-e476f784.vps.ovh.ca</span><br></pre></td></tr></table></figure><p>然后通过防火墙封锁对应IP的所有流量，为了保险起见，我用 <code>iptables</code> 和 <code>ufw</code> 都设置了一遍</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -A INPUT -s 51.79.73.21 -j DROP</span><br><span class="line">sudo iptables -A OUTPUT -s 51.79.73.21 -j DROP</span><br><span class="line">sudo ufw deny from 51.79.73.21 to any</span><br><span class="line">sudo ufw <span class="built_in">enable</span></span><br></pre></td></tr></table></figure><p>重启之后还是失败了</p><h2 id="向成功迈出了一步">向成功迈出了一步</h2><p>前面所说的使用 <code>crontab -l</code> 命令是看不到某些定时任务的，需要查看 <code>/etc/crontab</code> 的内容才可以</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="regexp">/etc/</span>crontab</span><br></pre></td></tr></table></figure><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210513013148105.png" alt="7" style="zoom:50%;"></p><p>进入目录 <code>/etc/cron.hourly</code> 发现了一个可疑文件 <code>pwnrig</code>，查看它的内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/cron.hourly/pwnrig</span><br></pre></td></tr></table></figure><p>这下才看出来，<code>-bash</code> 进程的由来是 <code>/bin/crondr</code> ，该脚本将其重命名为 <code>/bin/-bash</code> ，再执行 <code>/bin/-bash</code> ，然后将 <code>/bin/-bash</code> 删除。 <code>2&gt;/dev/null</code> 的作用是为了删除这些命令的错误报告（标准错误流 <code>stderr</code> 的输出），就是为了不留痕迹地执行，太流氓了！！！</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210512214440281.png" alt="8" style="zoom:50%;"></p><p>注意，在路径 <code>/etc/cron.d</code>、 <code>/etc/cron.daily</code>、<code>/etc/cron.weekly</code>、<code>/etc/cron.monthly</code> 都有一个相同内容的 <code>pwnrig</code> 文件，在前面的图中已经标出来了</p><p>删除这些可疑文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf /etc/cron.d/pwnrig</span><br><span class="line">sudo rm -rf /etc/cron.hourly/pwnrig</span><br><span class="line">sudo rm -rf /etc/cron.daily/pwnrig</span><br><span class="line">sudo rm -rf /etc/cron.weekly/pwnrig</span><br><span class="line">sudo rm -rf /etc/cron.monthly/pwnrig</span><br></pre></td></tr></table></figure><p>但是删不掉？？？</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210512214641106.png" alt="9" style="zoom:50%;"></p><p>那就祭出大杀器 <code>chattr</code> 和 <code>lsattr</code> 来解锁，再使用 <code>rm</code> 删掉，对于这些其他文件也是一样的办法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo lsattr /etc/cron.weekly/pwnrig <span class="comment"># 查看具有的文件属性</span></span><br><span class="line">sudo chattr -R -ia /etc/cron.weekly/pwnrig <span class="comment"># 去掉属性a（文件只能在最后添加新内容）和属性i（文件不能被删除）</span></span><br></pre></td></tr></table></figure><p>再删除真正的元凶 <code>/bin/crondr</code> 、<code>/bin/-bash</code> （不知道又是从哪冒出来的，注意不是 <code>/bin/bash</code>）文件，使用同样的办法。</p><p>再通过以下命令杀掉挖矿进程，挖矿进程终于看不到了。然而将虚拟机重启之后，挖矿进程还是卷土重来了，又失败了。但是可以推断，挖矿进程卷土重来的原因是可能已经被加入到了系统启动项，总之 <code>pwnrig</code> 没删干净就对了。</p><p>在 <code>/etc</code> 下搜索文件名含有 <code>pwnrig</code> 的所有文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo find /etc -name <span class="string">&quot;*pwnrig*&quot;</span></span><br></pre></td></tr></table></figure><p>还是有很多，而且真的加入到了启动项：</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210513014211767.png" alt="10" style="zoom:50%;"></p><p>其中红框里面的需要按照上述方式先解锁再删除，没加红框的可以直接删除（如果有出入就先解锁再删除）</p><p>然后再删除其他残留文件：<code>/bin/sysdr</code>、<code>/bin/initdr</code>、<code>/bin/bprofr</code>，先解锁再删除。</p><p>最后 kill 掉挖矿进程，大功告成。</p><h2 id="防止复活的手段">防止复活的手段</h2><p>这远远还没结束。由于不同人，不同机器，感染病毒的情况不一样，现在看来是删掉了所有启动项和定时任务，但是也不能确保所有残留文件都删干净了。在网络上一番查找，某个定时任务会从 <code>pw.pwndns.pw</code> 下载一个恶意脚本 <code>update.sh</code> 文件，这个文件会下载前面所说的挖矿程序。因此需要在 <code>/etc/hosts</code> 中加入以下内容来封堵从这台主机下载恶意脚本的路径：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 pw.pwndns.pw</span><br><span class="line">127.0.0.1 pwn.pwndns.pw</span><br><span class="line">127.0.0.1 xmr-v4.pwndns.pw</span><br><span class="line">127.0.0.1 xmr-rx0.pwndns.pw</span><br></pre></td></tr></table></figure><p>然后就是重新给帐户设一个强密码（之前设的是 <code>123456</code>，应该是被破解了）。另外，之前的黑客可能是从 <code>ssh</code> 远程登录进来的，之前也把防火墙关了。为了防止他们再免密登录进来，再作以下操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf /root/.ssh</span><br><span class="line">rm -rf ~/.ssh</span><br><span class="line"><span class="comment"># 不一定要删掉，备份也行</span></span><br></pre></td></tr></table></figure><h2 id="后记">后记</h2><p>上<a href="https://www.shodan.io">Shodan</a>查一下IP地址，是加拿大的，还是自签名，真有你的</p><figure><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210513025538574.png" alt><figcaption>11</figcaption></figure><h2 id="相关链接">相关链接</h2><p>我没有做安全的相关经验，感谢提供经验的大佬们</p><ul><li><a href="https://blog.csdn.net/u013591740/article/details/109157784" class="uri">https://blog.csdn.net/u013591740/article/details/109157784</a></li><li><a href="https://blog.csdn.net/YuMingJing_/article/details/110428620" class="uri">https://blog.csdn.net/YuMingJing_/article/details/110428620</a></li><li><a href="https://blog.csdn.net/jycjyc/article/details/106770998" class="uri">https://blog.csdn.net/jycjyc/article/details/106770998</a></li><li><a href="https://blog.csdn.net/adscici/article/details/107382572" class="uri">https://blog.csdn.net/adscici/article/details/107382572</a></li><li><a href="https://baijiahao.baidu.com/s?id=1672145727359775748&amp;wfr=spider&amp;for=pc" class="uri">https://baijiahao.baidu.com/s?id=1672145727359775748&amp;wfr=spider&amp;for=pc</a></li><li><a href="https://www.antiy.cn/research/notice&amp;report/research_report/20200424.html" class="uri">https://www.antiy.cn/research/notice&amp;report/research_report/20200424.html</a></li><li><a href="http://hackdig.com/10/hack-181622.htm" class="uri">http://hackdig.com/10/hack-181622.htm</a></li><li><a href="https://www.yuque.com/genekong/zkb5i7/gbgx05" class="uri">https://www.yuque.com/genekong/zkb5i7/gbgx05</a></li><li><a href="https://www.cnblogs.com/Gsealy/p/14480365.html" class="uri">https://www.cnblogs.com/Gsealy/p/14480365.html</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;今天要在实验室的虚拟机上配环境搭系统，我就从我的一台 Ubuntu 18.04 的虚拟机复制了一台作为要配环境的虚拟机。然而发现了异样，就是我每次打开 firefox 浏览器很快就会闪退，连执行 &lt;code&gt;make&lt;/code&gt; 编译源代码的进程都被杀死了。于是我查看进程发现了这样一幕：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210512202031008.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;
&lt;p&gt;好家伙，16个核全占满了，但是内存占用率却不高。而且CPU都是名为 &lt;code&gt;-bash&lt;/code&gt; 的进程占的，还一核一个。&lt;/p&gt;
&lt;p&gt;结合之前看到的&lt;a href=&quot;https://mp.weixin.qq.com/s/j4vfelk1Eu-rl2s8B70_CQ&quot;&gt;公众号文章&lt;/a&gt;怀疑自己的虚拟机被挖矿了，但是又不敢十分确定，毕竟我不相信挖矿病毒还能侵入实验室的内网（抱歉是我读书太少了，生而为人，我很抱歉）。然后百度了一番，发现符合挖矿的特征（CPU占用超高，内存占用较少），确认了虚拟机的确被挖矿了。我杀掉这个进程也没用，马上类似的进程又卷土重来了。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://lovebettygirl.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://lovebettygirl.github.io/tags/Linux/"/>
    
    <category term="Ubuntu" scheme="https://lovebettygirl.github.io/tags/Ubuntu/"/>
    
    <category term="pwnrig" scheme="https://lovebettygirl.github.io/tags/pwnrig/"/>
    
    <category term="挖矿病毒" scheme="https://lovebettygirl.github.io/tags/%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92/"/>
    
  </entry>
  
  <entry>
    <title>如何让Ubuntu启动显示Grub</title>
    <link href="https://lovebettygirl.github.io/posts/5dc33326/"/>
    <id>https://lovebettygirl.github.io/posts/5dc33326/</id>
    <published>2021-05-12T02:48:33.000Z</published>
    <updated>2021-05-12T04:29:02.387Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景">背景</h2><p>我的Ubuntu系统版本是 18.04，系统内核版本是 <code>5.4.0-72-generic</code></p><a id="more"></a><p>按照以下步骤降低内核版本，却没有降低成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt search <span class="string">&#x27;linux-image-5.0.0-23-generic&#x27;</span> </span><br><span class="line">sudo apt install <span class="string">&#x27;linux-image-5.0.0-23-generic&#x27;</span> -y </span><br><span class="line">sudo apt install <span class="string">&#x27;linux-headers-5.0.0-23-generic&#x27;</span> -y</span><br><span class="line">sudo update-initramfs -u -k all </span><br><span class="line">sudo update-grub</span><br></pre></td></tr></table></figure><p>原来是因为Grub默认以最高内核版本启动。我就想能在启动的时候显示Grub，就可以自己选择内核版本了，也可以切换到原来的内核版本。</p><h2 id="解决方法">解决方法</h2><p>编辑文件 <code>/etc/default/grub</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/default/grub</span><br></pre></td></tr></table></figure><p>注释掉 <code>GRUB_HIDDEN_TIMEOUT=0</code> 这一行（如果有），再将<code>GRUB_TIMEOUT</code>的值更改为-1。</p><p>然后输入如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-grub</span><br></pre></td></tr></table></figure><p>然后重启就可以看到Grub界面了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><h2 id="参考">参考</h2><ul><li><a href="https://ubuntuqa.com/article/1780.html" class="uri">https://ubuntuqa.com/article/1780.html</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;我的Ubuntu系统版本是 18.04，系统内核版本是 &lt;code&gt;5.4.0-72-generic&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://lovebettygirl.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://lovebettygirl.github.io/tags/Linux/"/>
    
    <category term="Ubuntu" scheme="https://lovebettygirl.github.io/tags/Ubuntu/"/>
    
    <category term="Grub" scheme="https://lovebettygirl.github.io/tags/Grub/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】347. 前K个高频元素</title>
    <link href="https://lovebettygirl.github.io/posts/f352394b/"/>
    <id>https://lovebettygirl.github.io/posts/f352394b/</id>
    <published>2021-05-07T18:32:44.000Z</published>
    <updated>2021-05-09T15:50:50.500Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/" class="uri">https://leetcode-cn.com/problems/top-k-frequent-elements/</a></p><p>经过这道题学会了 <code>std::priority_queue</code> 怎么使用小根堆，也复习了一遍快排</p><a id="more"></a><h2 id="题目描述">题目描述</h2><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p><blockquote><p>注意：可以按 <strong>任意顺序</strong> 返回答案</p></blockquote><p><strong>示例 1:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = <span class="comment">[1,1,1,2,2,3]</span>, k = 2</span><br><span class="line">输出: <span class="comment">[1,2]</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = <span class="comment">[1]</span>, k = 1</span><br><span class="line">输出: <span class="comment">[1]</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>k</code> 的取值范围是 <code>[1, 数组中不相同的元素的个数]</code></li><li>题目数据保证答案唯一，换句话说，数组中前 <code>k</code> 个高频元素的集合是唯一的</li></ul><p><strong>进阶：</strong>你所设计算法的时间复杂度 <strong>必须</strong> 优于 <code>O(n log n)</code> ，其中 <code>n</code> 是数组大小。</p><h2 id="暴力排序">暴力排序</h2><p>思路很直观，分为3步：</p><ul><li>统计元素出现频率，可以使用哈希表</li><li>按照频率排序</li><li>找出前K个高频元素</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="comment">// 统计元素出现频率</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            m[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 转化成数组并排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.begin(); it != m.end(); it++) &#123;</span><br><span class="line">            v.push_back(&#123;it-&gt;second, it-&gt;first&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(v.begin(), v.end());</span><br><span class="line">        <span class="comment">// 找出前K个高频元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            result.push_back(v[v.size() - <span class="number">1</span> - i].second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(n\log n)\)</span></p><p>空间复杂度：<span class="math inline">\(O(n)\)</span></p><h2 id="优先队列">优先队列</h2><p>如果用优先队列来解决这道题，首先想到的就是大根堆吧：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            m[nums[i]]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.begin(); it != m.end(); it++)</span><br><span class="line">            q.emplace(it-&gt;second, it-&gt;first);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            result.push_back(q.top().second);</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(n\log n)\)</span></p><p>空间复杂度：<span class="math inline">\(O(n)\)</span></p><p>时间复杂度仍然达不到进阶要求，跟暴力排序法也没什么本质区别。</p><p>使用小根堆解决，在遍历哈希表的时候边遍历边将哈希表的条目插入到优先队列，如果优先队列的大小超过了 <code>k</code> ，那就将优先队列队头（对应的小根堆堆顶）弹出。这样，遍历完了之后，小根堆里面就只剩出现频率前 <code>k</code> 的元素了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;a, <span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a.first &gt; b.first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">result</span><span class="params">(k)</span></span>;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;, cmp&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            m[nums[i]]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.begin(); it != m.end(); it++) &#123;</span><br><span class="line">            q.emplace(it-&gt;second, it-&gt;first);</span><br><span class="line">            <span class="keyword">if</span> (q.size() &gt; k)</span><br><span class="line">                q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            result[i] = q.top().second;</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(n\log k)\)</span> （优先队列中的元素不会超过 <code>k</code> 个）</p><p>空间复杂度：<span class="math inline">\(O(n)\)</span></p><blockquote><p>假设优先队列长度为 <code>k</code>，进行一次堆操作（插入、删除）的时间复杂度为 <span class="math inline">\(O(\log k)\)</span></p></blockquote><h2 id="快速排序">快速排序</h2><p>没有一篇题解能把这个讲清楚，看了一下午，哎，可能是我太菜了吧</p><p>借用快速排序中 <code>pivot</code> 的思想，<code>pivot</code> 将数组 <code>arr[i, ..., j]</code>分成两半部分，假设 <code>pivot</code> 在数组中的位置为 <code>q</code>：</p><ul><li>左半部分 <code>arr[i, ..., q - 1]</code></li><li>右半部分 <code>arr[q + 1, ..., end]</code></li></ul><p>为了能够使用快速排序，首先将记录 <code>nums</code> 数组中数字频度的哈希表转换为频度数组 <code>v</code>，并且让左半部分的频度都大于等于频度数组 <code>v</code> 中 <code>pivot</code> 对应的频度，右半部分小于等于 <code>pivot</code> 对应的频度。</p><p>和普通的快排不一样，普通的快排需要在数组的左右两半部分都进行递归调用，这里只需要对其中一部分进行递归调用。假设在数组 <code>v</code> 的子数组的起始位置为 <code>start</code> ，末尾位置为 <code>end</code> ，<code>index</code> 为 <code>pivot</code> 对应的位置，令 <code>N = index - start + 1</code></p><ul><li>如果 <code>k == N</code>，那么 <code>v[start, ..., index]</code> 中的元素正好构成了前 <code>N</code> 个高频元素，即前 <code>k</code> 个高频元素，直接返回即可<ul><li>注意题目描述中的细节，返回的结果可以是任意顺序的</li></ul></li><li>如果 <code>k &lt; N</code>，那么 <code>v[start, ..., index]</code> 中的元素正好构成了前 <code>N</code> 个高频元素（不一定是前 <code>k</code> 个， 因为 <code>pivot</code> 左右两部分并不保证有序），由于 <code>pivot</code> 左右两部分并不保证有序，因此需要对 <code>v[start, ..., index - 1]</code> 进行递归调用，以找到前 <code>k</code> 个高频元素</li><li>如果 <code>k &gt; N</code>，那么 <code>v[start, ..., index]</code> 中的元素正好构成了前 <code>N</code> 个高频元素，前 <code>N</code> 个高频元素肯定是前 <code>k</code> 个元素中的一部分，需要对 <code>v[index + 1, ..., end]</code> 进行递归调用，以找到剩下的 <code>k - N</code> 个结果</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 快速排序的partition算法，这是快排的其中一种实现</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; &amp;v, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 快排中常用的选取 pivot 的方式是将 v[start] 或 v[end] 作为基准</span></span><br><span class="line">        <span class="comment">// 为了降低快排发生最坏情况的可能性，就随机选取 pivot</span></span><br><span class="line">        <span class="comment">// 这是快排常用的一种优化方法</span></span><br><span class="line">        <span class="keyword">int</span> picked = rand() % (end - start + <span class="number">1</span>) + start;</span><br><span class="line">        <span class="keyword">int</span> pivot = v[picked].first;</span><br><span class="line">        swap(v[start], v[picked]);</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">while</span> (start &lt; end &amp;&amp; v[end].first &lt;= pivot)</span><br><span class="line">                end--;</span><br><span class="line">            swap(v[start], v[end]);</span><br><span class="line">            <span class="keyword">while</span> (start &lt; end &amp;&amp; v[start].first &gt;= pivot)</span><br><span class="line">                start++;</span><br><span class="line">            swap(v[start], v[end]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; &amp;v, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;result, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = partition(v, start, end);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k &lt; index - start + <span class="number">1</span>) &#123;</span><br><span class="line">            qsort(v, start, index - <span class="number">1</span>, result, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>  &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= index; i++)</span><br><span class="line">                result.push_back(v[i].second);</span><br><span class="line">            <span class="comment">// 如果k &gt; index - start + 1，前index - start + 1个元素肯定是结果的一部分</span></span><br><span class="line">            <span class="keyword">if</span> (k &gt; index - start + <span class="number">1</span>)</span><br><span class="line">                qsort(v, index + <span class="number">1</span>, end, result, k - (index - start + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            m[nums[i]]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.begin(); it != m.end(); it++) &#123;</span><br><span class="line">            v.push_back(&#123;it-&gt;second, it-&gt;first&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        qsort(v, <span class="number">0</span>, v.size() - <span class="number">1</span>, result, k);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：平均情况 <span class="math inline">\(O(n)\)</span>，最坏情况 <span class="math inline">\(O(n^{2})\)</span></p><p>空间复杂度：<span class="math inline">\(O(n)\)</span></p><h2 id="计数排序桶排序">计数排序（桶排序）</h2><p>由于 <code>nums</code> 数组中，一个数字出现的频率至多为 <code>nums</code> 的长度（此时 <code>nums</code> 数组中只有一种元素），那么可以使用计数排序来优化时间复杂度也不会占用大量的空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="comment">// 频度表，下标为nums数组中元素出现频度，元素为频度对应的数</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v(size + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            m[nums[i]]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.begin(); it != m.end(); it++) &#123;</span><br><span class="line">            v[it-&gt;second].push_back(it-&gt;first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下标越大，频度越高，因此要从后往前遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = v.size() - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[i].size()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v[i].size(); j++) &#123;</span><br><span class="line">                    result.push_back(v[i][j]);</span><br><span class="line">                    <span class="keyword">if</span> (result.size() == k)</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(n)\)</span></p><p>空间复杂度：<span class="math inline">\(O(n)\)</span></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/top-k-frequent-elements/&quot; class=&quot;uri&quot;&gt;https://leetcode-cn.com/problems/top-k-frequent-elements/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;经过这道题学会了 &lt;code&gt;std::priority_queue&lt;/code&gt; 怎么使用小根堆，也复习了一遍快排&lt;/p&gt;</summary>
    
    
    
    <category term="刷题" scheme="https://lovebettygirl.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    <category term="LeetCode" scheme="https://lovebettygirl.github.io/categories/%E5%88%B7%E9%A2%98/LeetCode/"/>
    
    
    <category term="C++" scheme="https://lovebettygirl.github.io/tags/C/"/>
    
    <category term="LeetCode" scheme="https://lovebettygirl.github.io/tags/LeetCode/"/>
    
    <category term="优先队列" scheme="https://lovebettygirl.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
    <category term="快速排序" scheme="https://lovebettygirl.github.io/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    
    <category term="计数排序" scheme="https://lovebettygirl.github.io/tags/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    
    <category term="桶排序" scheme="https://lovebettygirl.github.io/tags/%E6%A1%B6%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】239. 滑动窗口最大值</title>
    <link href="https://lovebettygirl.github.io/posts/c2b11f10/"/>
    <id>https://lovebettygirl.github.io/posts/c2b11f10/</id>
    <published>2021-05-06T12:12:18.000Z</published>
    <updated>2021-05-06T12:37:30.773Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/sliding-window-maximum/" class="uri">https://leetcode-cn.com/problems/sliding-window-maximum/</a></p><p>好难啊</p><a id="more"></a><h2 id="题目描述">题目描述</h2><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3,<span class="string">-1</span>,<span class="string">-3</span>,5,3,6,7], k = 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  <span class="string">-1</span>] <span class="string">-3</span>  5  3  6  7       3</span><br><span class="line"> 1 [3  <span class="string">-1</span>  <span class="string">-3</span>] 5  3  6  7       3</span><br><span class="line"> 1  3 [<span class="string">-1</span>  <span class="string">-3</span>  5] 3  6  7       5</span><br><span class="line"> 1  3  <span class="string">-1</span> [<span class="string">-3</span>  5  3] 6  7       5</span><br><span class="line"> 1  3  <span class="string">-1</span>  <span class="string">-3</span> [5  3  6] 7       6</span><br><span class="line"> 1  3  <span class="string">-1</span>  <span class="string">-3</span>  5 [3  6  7]      7</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="comment">[1]</span>, k = 1</span><br><span class="line">输出：<span class="comment">[1]</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="comment">[1,-1]</span>, k = 1</span><br><span class="line">输出：<span class="comment">[1,-1]</span></span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="comment">[9,11]</span>, k = 2</span><br><span class="line">输出：<span class="comment">[11]</span></span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="comment">[4,-2]</span>, k = 2</span><br><span class="line">输出：<span class="comment">[4]</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li><li><code>1 &lt;= k &lt;= nums.length</code></li></ul><h2 id="优先队列">优先队列</h2><p>这道题需要一个数据结构，来存储滑动窗口中最大值、第二大的值、第三大的值、……的下标。（最初我只想到了用变量去存滑动窗口中最大值和第二大的值的下标，结果当窗口移动之后变量总是不能正确被更新，然后就做不对了；居然还想到了用栈，我真的太菜了）</p><p>首先最直观的想法应该是使用优先队列（大根堆），这样，优先队列的队头（即大根堆的堆顶）就是滑动窗口内最大的值在 <code>nums</code> 数组的下标。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q; <span class="comment">// std::priority_queue默认是大根堆</span></span><br><span class="line">        <span class="comment">// 窗口在初始位置时，将此时窗口中的数组元素加入到优先队列中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">            q.emplace(nums[i], i);</span><br><span class="line">        result.push_back(q.top().first);</span><br><span class="line">        <span class="comment">// 向右移动滑动窗口</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; size; i++) &#123;</span><br><span class="line">            q.emplace(nums[i], i);</span><br><span class="line">            <span class="comment">// 需要将所有已经移出窗口的数组元素从优先队列中删除</span></span><br><span class="line">            <span class="keyword">while</span> (q.top().second &lt;= i - k)</span><br><span class="line">                q.pop();</span><br><span class="line">            result.push_back(q.top().first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(n\log n)\)</span>（一个元素进入优先队列）</p><p>空间复杂度：<span class="math inline">\(O(n)\)</span>（优先队列所占用的空间）</p><h2 id="单调队列">单调队列</h2><p>单调队列就是队列中的所有元素都是单调递增或递减的队列。</p><p>这里的想法是用队列来存储滑动窗口中最大值的下标，以及在最大值右边的第二大的值、第三大的值、……的下标。这样，一旦窗口向右移动，并且窗口内的最大值移出了窗口，就能知道下一个该成为窗口中最大值的元素是哪个。</p><p>窗口每向右移动一格，需要做的事情：</p><ul><li>将新进入窗口的元素的下标插入到队尾，为了保持队列中存储的下标对应的元素是递减的，需要先将队列中所有比该元素小的值从队尾删除。</li><li>将队列中已经被移出窗口的下标从队头删除，队列中剩下的值可能会成为窗口内最大值的候选值。</li></ul><p>为了能够实现从队头和队尾都能删除元素，需要使用双端队列（deque）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!q.empty() &amp;&amp; nums[i] &gt;= nums[q.back()])</span><br><span class="line">                q.pop_back();</span><br><span class="line">            q.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        result.push_back(nums[q.front()]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!q.empty() &amp;&amp; nums[i] &gt;= nums[q.back()])</span><br><span class="line">                q.pop_back();</span><br><span class="line">            q.push_back(i);</span><br><span class="line">            <span class="comment">// 将已经移出窗口的下标删除</span></span><br><span class="line">            <span class="keyword">while</span> (q.front() &lt;= i - k)</span><br><span class="line">                q.pop_front();</span><br><span class="line">            result.push_back(nums[q.front()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(n)\)</span>（最坏情况是每个元素都要进入到队列和从队列中删除各一次，例如数组中的元素大小是递增的）</p><p>空间复杂度：<span class="math inline">\(O(n)\)</span>（单调队列所占用的空间）</p><h2 id="动态规划">动态规划</h2><p>从官方题解来的，卡了好半天了，哎，还是从下面两篇题解看出了一些眉目</p><p><a href="https://leetcode.com/problems/sliding-window-maximum/discuss/458121/Java-All-Solutions-(B-F-PQ-Deque-DP)-with-Explanation-and-Complexity-Analysis" class="uri">https://leetcode.com/problems/sliding-window-maximum/discuss/458121/Java-All-Solutions-(B-F-PQ-Deque-DP)-with-Explanation-and-Complexity-Analysis</a></p><p><a href="https://leetcode.com/problems/sliding-window-maximum/discuss/951894/C%2B%2B-Easy-DP-or-O(n)-or-Explained-or-No-Deque-Required-%3AD" class="uri">https://leetcode.com/problems/sliding-window-maximum/discuss/951894/C%2B%2B-Easy-DP-or-O(n)-or-Explained-or-No-Deque-Required-%3AD</a></p><p>先将整个 <code>nums</code> 数组（长度为 <code>n</code> ）分成几个互不相交且长度为 <code>k</code> 的块（最后一个块的长度可能小于 <code>k</code>），如下所示：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span> <span class="number">3</span>  -<span class="number">1</span> ｜ -<span class="number">3</span>  <span class="number">5</span>  <span class="number">3</span> ｜ <span class="number">6</span>  <span class="number">7</span></span><br></pre></td></tr></table></figure><p>那么，从下标 <code>i</code> 开始，长度为 <code>k</code> 的滑动窗口可能刚好在一个块，也有可能跨越两个块。</p><p>如果 <code>i</code> 刚好是 <code>k</code> 的倍数，那么窗口刚好只占一个块，例如：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span> <span class="number">3</span>  -<span class="number">1</span> ｜ [-<span class="number">3</span>  <span class="number">5</span>  <span class="number">3</span>] ｜ <span class="number">6</span>  <span class="number">7</span></span><br></pre></td></tr></table></figure><p>否则，窗口就会跨越两个块，例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">        <span class="selector-tag">i</span>     j  <span class="selector-tag">i</span>+k-<span class="number">1</span></span><br><span class="line">        ↓     ↓  ↓</span><br><span class="line"><span class="number">1</span>  <span class="number">3</span>  <span class="selector-attr">[-1 ｜ -3  5]</span>  <span class="number">3</span> ｜ <span class="number">6</span>  <span class="number">7</span></span><br></pre></td></tr></table></figure><p>可以看出，这种情况下，一个块被窗口的边界分成了左半部分和右半部分，分别使用两个长度为 <code>n</code> 的数组 <code>left</code> 和 <code>right</code>：</p><ul><li><code>left[i + k - 1]</code> 表示从 <code>nums[j]</code> 到 <code>nums[i + k - 1]</code> 中（窗口中的右半部分）的最大值，同时是第二个块的左半部分的最大值（以窗口右边界分隔）</li><li><code>right[i]</code> 表示从 <code>nums[i]</code> 到 <code>nums[j - 1]</code> 中（窗口中的左半部分）的最大值，同时是第一个块的右半部分的最大值（以窗口左边界分隔）</li></ul><p>因此，当窗口的起始位置为 <code>i</code> 时，窗口中的最大值可以描述为窗口中左半部分和右半部分的最大值： <span class="math display">\[\max(right[i],left[i + k - 1])\]</span> 其中，<code>left</code> 数组中的元素的递推式为（需要从左向右遍历 <code>nums</code> 数组得到）： <span class="math display">\[left[i]=\begin{cases}nums[i]&amp;i\  \text{mod} \  k=0\\ \max \left( left[i-1],nums[i]\right)  &amp;\text{else} \end{cases}\]</span> <code>right</code> 数组中的元素的递推式为（需要从右向左遍历 <code>nums</code> 数组得到）： <span class="math display">\[right[i]=\begin{cases}nums[i]&amp;i=n-1\  \text{or} \  (i+1)\  \text{mod} \  k=0\\ \max \left( right[i+1],nums[i]\right)  &amp;\text{else} \end{cases}\]</span> 注意，当窗口起始位置 <code>i</code> 刚好是 <code>k</code> 的倍数时，有： <span class="math display">\[right[i]=left[i+k-1]\]</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        vector&lt;int&gt; left(size), right(size), result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % k == <span class="number">0</span>)</span><br><span class="line">                left[i] = nums[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left[i] = max(left[i - <span class="number">1</span>], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        right[size - <span class="number">1</span>] = nums[size - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i + <span class="number">1</span>) % k == <span class="number">0</span>)</span><br><span class="line">                right[i] = nums[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right[i] = max(right[i + <span class="number">1</span>], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size - k; i++) &#123;</span><br><span class="line">            result.push_back(max(right[i], left[i + k - <span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(n)\)</span></p><p>空间复杂度：<span class="math inline">\(O(n)\)</span></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode-cn.com/problems/sliding-window-maximum/&quot; class=&quot;uri&quot;&gt;https://leetcode-cn.com/problems/sliding-window-maximum/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;好难啊&lt;/p&gt;</summary>
    
    
    
    <category term="刷题" scheme="https://lovebettygirl.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    <category term="LeetCode" scheme="https://lovebettygirl.github.io/categories/%E5%88%B7%E9%A2%98/LeetCode/"/>
    
    
    <category term="C++" scheme="https://lovebettygirl.github.io/tags/C/"/>
    
    <category term="LeetCode" scheme="https://lovebettygirl.github.io/tags/LeetCode/"/>
    
    <category term="优先队列" scheme="https://lovebettygirl.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
    <category term="队列" scheme="https://lovebettygirl.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
    <category term="动态规划" scheme="https://lovebettygirl.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>【数据库】关系数据理论</title>
    <link href="https://lovebettygirl.github.io/posts/ba7ec3b2/"/>
    <id>https://lovebettygirl.github.io/posts/ba7ec3b2/</id>
    <published>2021-05-03T16:03:42.000Z</published>
    <updated>2021-05-04T02:41:01.229Z</updated>
    
    <content type="html"><![CDATA[<p>大二学数据库时候的笔记，这段时间要准备面试，所以现在把它抖出来。但是我应该看不太懂了。</p><p>我要是在学操作系统和计算机网络的时候也有笔记就好了，这样就不愁面试了。</p><p>哦，原来数据库考索引多一些，大学白学了。</p><a id="more"></a><h2 id="不好的设计所带来的异常">不好的设计所带来的异常</h2><h3 id="冗余">冗余</h3><p>同样的信息在多个元组中重复。</p><h3 id="更新异常">更新异常</h3><p>这是由<strong>冗余</strong>导致的。修改了某个元组的信息，但是没有修改其他元组中相同的信息。导致数据的<strong>不一致性</strong>。</p><h3 id="删除异常">删除异常</h3><p>想删除这个元组的部分信息，却因为删除了元组而丢失了其他信息（这些信息只在这一个元组中出现）。违背了<strong>数据完整性</strong>。</p><h3 id="插入异常">插入异常</h3><p>想插入一个元组，但是某个主键属性值缺失（null）而导致不能插入该元组。</p><h2 id="好的设计所具有的特征">好的设计所具有的特征</h2><ul><li>保证所有信息不丢失。</li><li>含有最小数量的冗余。</li><li>保留数据之间的函数依赖。</li><li>比较好的查询性能。</li></ul><h2 id="函数依赖和多值依赖">函数依赖和多值依赖</h2><h3 id="函数依赖的定义">函数依赖的定义</h3><p>如果R的两个元组在属性A1,A2,...,An上一致（即它们对应于这些属性的分量值都相等），那么它们必定在其他属性B1,B2,...,Bm上也一致。<strong>换句话说，一组A1,A2,...,An只对应唯一的B1,B2,...,Bm。</strong></p><p>记为：A1,A2,...,An→B1,B2,...,Bm。</p><p><strong>注意：在数据库开发过程中，函数依赖（FDs）一般是用户给出的领域知识描述。如果从已有数据中找寻FDs，属于知识发现或数据挖掘。</strong></p><h3 id="属性集合的闭包">属性集合的闭包</h3><h4 id="定义">定义</h4><p>属性集合{A1,A2,...,An}的闭包为所有能从已有的函数依赖推导出的属性的集合。记为：{A1,A2,...,An}+。</p><h4 id="算法">算法</h4><p>略。</p><h4 id="用途">用途</h4><ul><li>判断某个函数依赖是否成立（能否从这个函数依赖的集合导出）。</li><li>求关系R的键。</li><li>测试是否为超键。</li></ul><h3 id="函数依赖集合的闭包">函数依赖集合的闭包</h3><h4 id="定义-1">定义</h4><p>给定关系R和在R上成立的函数依赖F，F的闭包为所有能从F中的函数依赖推导出的函数依赖的集合。记为：F+。</p><h4 id="算法-1">算法</h4><ul><li>对R的属性集合{A1,A2,...,An}，先求相应的子集（一共2^n）个。</li><li>对R的属性集合{A1,A2,...,An}每个子集X，求X的的闭包X+。</li><li>求X+的所有子集Y，并输出函数依赖X→Y到F+中。</li></ul><h4 id="用途-1">用途</h4><p>由于R的属性集合{A1,A2,...,An}一共有2<sup>n个，故算法的时间复杂度为O(2</sup>n)，为NP问题。</p><p>一般来说，不用求函数依赖集合F的闭包。因为不仅F+规模大，而且<strong>所有能从F中的函数依赖推导出的函数依赖都在F+中。</strong></p><h3 id="推导函数依赖">推导函数依赖</h3><h4 id="armstrong公理">Armstrong公理</h4><ul><li><p>自反律：A1,A2,...,An→A1,A2,...,An的子集</p></li><li><p>增广律：A1,A2,...,An→B1,B2,...,Bm, then A1,A2,...,An,C1,C2,...,Ck→B1,B2,...,Bm,C1,C2,...,Ck</p></li><li><p>传递律：A1,A2,...,An→B1,B2,...,Bm and B1,B2,...,Bm→C1,C2,...,Ck, then A1,A2,...,An→C1,C2,...,Ck</p></li></ul><h4 id="常用结论">常用结论</h4><p>这些结论都可以由Armstrong公理推导出来。</p><p>X, Y, Z都是属性集合。</p><ul><li><p>Union rule：X→Y and X→Z, then X→YZ</p></li><li><p>Decomposition rule：X→YZ, then X→Y and X→Z</p></li><li><p>Pseudo-transitivity rule：X→Y and YZ→U, then XZ→U</p></li></ul><p>由Armstrong公理的自反律推导出的函数依赖称为“平凡函数依赖”。由增广律可以消除箭头两边重复的属性。由上述Decomposition rule可以拆解箭头右边的属性。一般我们讨论的函数依赖为非平凡函数依赖，且函数依赖的箭头右边只有一个属性。</p><h4 id="判断函数依赖是否成立的方法">判断函数依赖是否成立的方法</h4><ul><li>给定函数依赖集合F和函数依赖X→Y，求X的闭包X+，如果Y在X+中，则X→Y成立。</li><li>chase检验。（和上述方法本质相同）</li></ul><h3 id="最小函数依赖集">最小函数依赖集</h3><h4 id="等价">等价</h4><p>给定函数依赖集合F和G，若G+=F+，则F与G等价。</p><p>F+=G+的充要条件是F是G+的子集，G是F+的子集。</p><h4 id="最小函数依赖集的定义">最小函数依赖集的定义</h4><p>给定函数依赖集合S，则任何与S等价的函数依赖集合都是S的基本集。满足下面三个条件的基本集B为关系的最小函数依赖集。</p><ul><li>B中所有函数依赖的右边均为单一属性。</li><li>从B中删除任何一个函数依赖后，该集合不再是基本集。</li><li>对于B中的任何一个函数依赖，如果从其左边删除一个或多个属性，B将不再是基本集。</li></ul><p>最小函数依赖集中不包括平凡函数依赖，因为可以根据第2条规则将其删除。对于函数集合S，其对应的最小函数依赖集B也不是唯一的。</p><h4 id="求法">求法</h4><p>给定函数依赖集合F。</p><ul><li>选择F中的任意一个函数依赖，去掉这个函数依赖，看F中剩余的函数依赖能否导出那个被去掉的函数依赖。如果能则去掉，反之则在F中保留。然后在F中重新选取另一个函数依赖，重复上述步骤。</li><li><del>选择F中的一个函数依赖Y→B，Y至少有两个属性，从Y中删除一个属性并记为Z。如果B能够从F中（包括Y→B）依赖推断，则使用Z→B替换Y→B。</del></li><li>一个一个地检查函数依赖左部非单个属性的依赖。例如XY→A，若要判Y为多余的，则以X→A代替XY→A是否等价？若A属于(X)+，则Y是多余属性，可以去掉。（以上步骤中，求出关系依赖集F,此时，再F的基础上，求出X或者Y的闭包，是否包含A）</li></ul><p>以各种可能的方式重复上述两个步骤，注意在选取函数依赖的时候不要选择前面选过但是原样保留在F中的函数依赖，直到F不再变化。</p><h4 id="函数依赖集的投影">函数依赖集的投影</h4><p>给定关系R和在R中成立的函数依赖集合S，R1是R的投影，T是在R1上成立的函数依赖集合。先将T初始化为空集。</p><ul><li>对于R1属性集合的每一个子集X，计算X的闭包X+。</li><li>对于所有在X+中且属于R1的属性A，将所有非平凡函数依赖X→A添加到T中。</li><li>求T的最小函数依赖集。</li></ul><h4 id="用途-2">用途</h4><ul><li>保持函数依赖集合无损连接的3NF模式分解</li><li>求由原关系R分解（投影）得出的关系的函数依赖集合，来看分解后的函数依赖是否保持了原关系中的函数依赖。（函数依赖集的投影）</li></ul><h3 id="多值依赖mvd">多值依赖（MVD）</h3><ul><li><p>在关系模式中，函数依赖不能表示属性值之间的一对多联系，这些属性之间有些虽然没有直接关系，但存在间接的关系，把没有直接联系、但有间接的联系称为多值依赖的数据依赖。</p></li><li><p>在函数依赖中，X与Y是否存在函数依赖关系，只需考察X,Y的两组属性，与别的属性无关。而在多值依赖中，X与Y是否存在多值依赖还需看属性Z。</p></li><li><p>多值依赖允许X的一个值决定Y的一组值，这种决定关系与Z取值无关。</p></li><li><p>多值依赖是全模式的依赖关系。</p></li></ul><h4 id="定义-2">定义</h4><p>A <em>multivalued dependency</em> (MVD) <em>X</em>→→<em>Y</em> is an assertion that if two tuples of a relation agree on all the attributes of <em>X</em>, then their components in the set of attributes <em>Y</em> may be swapped, and the result will be two tuples that are also in the relation.</p><p>函数依赖是多值依赖的特例。一般的多值依赖不是函数依赖。</p><p>或：设R(U)是一个属性集合U上的一个关系模式，X, Y, 和Z是U的子集，并且Z=U-X-Y，多值依赖X-&gt;-&gt;Y成立当且仅当对R的任一个关系r，r在(X,Z)上的每个值对应<strong>一组</strong>Y的值，这组值仅仅决定于X值而与Z值无关。</p><p>若X-&gt;-&gt;Y，而Z=空集，则称X-&gt;-&gt;Y为平凡的多值依赖。否则，称X-&gt;-&gt;Y为非平凡的多值依赖。</p><h4 id="规则">规则</h4><ul><li>平凡MVD：若X→→Y,而Z为空集，则称X→→Y为平凡的多值依赖；若Z不为空，则称其为非平凡的多值依赖。</li><li>传递律：X→→Y and Y→→Z, then X→→Z。Z的任何属于X的属性也要从右边除去。</li><li>互补规则：若关系R上存在多值依赖X→→Y，则R上也存在X→→Z，其中Z是R中不属于X和Y<strong>所有</strong>其他属性的集合。</li></ul><p>注意：MVD不支持MVD的分解/结合原则，即FD的右边可拆，但是MVD左右都不能拆。</p><h4 id="mvd推导">MVD推导</h4><p>chase推广</p><h4 id="投影mvd">投影MVD</h4><p>chase推广</p><h2 id="关系的键key">关系的键（key）</h2><h3 id="键的定义">键的定义</h3><p>如果下列条件满足，就认为一个或多个属性集合{A1,A2,...,An}是关系R的键（候选码）。</p><ul><li>这些属性决定了关系的所有其他属性。也就是说，关系R不可能存在两个不同的元组，他们具有相同的A1,A2,...,An值。</li><li>在{A1,A2,...,An}的真子集中，没有一个能决定关系的所有其他属性。（决定所有属性的最小属性集合）</li></ul><p>当键只包括一个单独的属性A时，称A（而不是{A}）是键。</p><h3 id="超键superkey">超键（superkey）</h3><p>一个包含键的属性集称为超键。须注意：键是超键（根据定义），但是超键不一定是键。</p><h3 id="键的求法">键的求法</h3><h4 id="从er图中寻找键">从E/R图中寻找键</h4><p>略。</p><h4 id="由关系和函数依赖集求键">由关系和函数依赖集求键</h4><ul><li>对于给定关系R和在R上成立的函数依赖集合F，在R的所有属性组成的集合A={A1,A2,...,An}，从A中去掉在F中只出现在箭头右边的属性得到集合B。</li><li>对于A中剩余的属性所组成的集合B，求B所有的子集（空集除外）的闭包B+。如果B+=A，则B是关系R的一个键。在求解的过程中，如果遇到的子集是超键（对于前面已经求出的键来说），则略过不求。</li></ul><h2 id="范式">范式</h2><ul><li>设计关系数据库时，需要遵从不同的规范要求，设计出合理的关系型数据库，<strong>这些不同的规范要求被称为不同的范式</strong>，各种范式呈递次规范，<strong>越高的范式数据库冗余越小</strong>。<strong>没有冗余的数据库未必是最好的数据库</strong>， <strong>有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据</strong>。</li><li>目前关系数据库有六种范式（按冗余程度从高到低排序）：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、Boyce-Codd范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。</li><li>所有范式都是基于约束（函数依赖、键）定义的。</li><li><strong>范式之间存在包含关系。一个数据库设计如果符合第二范式，一定也符合第一范式。如果符合第三范式，一定也符合第二范式，依次类推。</strong></li><li>一般来说，数据库满足3NF或BCNF就可以了。关系模式如果不能达到3NF及以上，会出现冗余和各种异常。分解是消除异常的方法。</li><li>关系模式的分解是为了适应实际应用，分解后减少了冗余，但查询时却要增加连接，效率下降，这都需要<strong>权衡</strong>。因此，选取设计范式应立足实际应用，适当的冗余是可以容忍和必要的。</li></ul><h3 id="关系模式的分解">关系模式的分解</h3><h4 id="分解关系模式的一般方法">分解关系模式的一般方法</h4><p>给定关系模式R和R上成立的函数依赖集合F，欲将其分解为满足更高级别范式的关系模式。</p><ul><li>检查F中存在违背某一更高级别范式条件函数依赖。如果没有，则采用比这个更高级别还要高的范式条件进行检查。</li><li>如果存在违背的函数依赖，就将其拆分为小的关系模式。</li><li>检查这些小的关系模式的函数依赖（用 <a href="#函数依赖集的投影">函数依赖集的投影</a> 的方法求）是否存在违背这个更高级别范式的函数依赖，如果存在，则还要继续分解、继续检查，直到满足这个更高级别的范式条件即可。</li><li>如果这些小的关系模式不存在违背的函数依赖，则这些关系模式都满足这个更高级别的范式。之后可以采用比这个更高级别还要高的范式重复上述步骤。</li></ul><h4 id="无损分解无损连接">无损分解、无损连接</h4><ul><li><p>分解：给定关系模式R(A1,A2,...,An)，将R分解成R1(B1,B2,...,Bn)和R2(C1,C2,...,Cn)，R1和R2都是R的投影。还要满足：{B1,B2,...,Bn}∪{C1,C2,...,Cn}={A1,A2,...,An}。</p></li><li><p>无损分解、无损连接：将关系模式分解成R1、R2、……，而R1、R2、……自然连接的生成的表R'和不仅R的关系模式相同，而且R'的行数和R的行数也应该一致（此时元组和原来的也一样，可证明），则这个分解和连接的过程是无损的，即没有信息丢失。具体的表现是：给定关系模式R(X,Y,Z)，在R上成立的函数依赖集合F={Y→X,Y→Z}，分解成R1(X,Y)和R2(Y,Z)，才能做到无损分解。</p></li><li><p>有损：R'中的行数比R中的行数多，而且这些多出来的行使得我们无法分辨哪条信息才是真的。一个具体的表现是：给定关系模式R(X,Y,Z)，Y→X,X→Z均不在R上成立，分解成R1(X,Y)和R2(Y,Z)，R1和R2自然连接的结果虽然关系模式是R'(X,Y,Z)，但是元组会比原来多，其中有的元组是虚假信息。</p></li><li><p>判断无损分解和连接的算法：chase检验。</p><p>而chase检验的本质和属性闭包算法本质相同。<del>可以将从R分解出的所有关系模式列出来，使用R上的函数依赖集合分别对每个关系模式的所有属性组成的集合分别求属性闭包，如果某一个属性闭包正好包含了R中所有的属性，则是无损连接。</del></p></li></ul><h4 id="保持函数依赖">保持函数依赖</h4><p>给定关系模式R和R上成立的函数依赖集合S，将R分解成R1和R2，分别对应函数依赖集合S1、S2。</p><ul><li>如果(S1∪S2)与S等价，即(S1∪S2)+=S+，则这个分解保持了原有函数依赖。</li><li>一个表现：S中的一个函数依赖X→Y，分解之后X只在一个关系模式中，Y只在另一个关系模式中。则没有保持原有函数依赖。</li><li>分解之后丢失了如果部分函数依赖，则自然连接回去的关系模式也会丢失相应的函数依赖。</li><li><strong>分解之后是否保持函数依赖，关键是看连接回去是否具有这个函数依赖。</strong></li></ul><p>判断分解后是否保持函数依赖的算法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对F上的每一个α→β使用下面的过程：</span></span><br><span class="line">result=α;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> each 分解后的Ri  <span class="comment">//将每个分解后的结构Ri逐个带入</span></span><br><span class="line">      t=(result∩Ri)+ ∩Ri;  <span class="comment">//这里的意思是取result与Ri的交集的闭包值，之后再与Ri取交集</span></span><br><span class="line">      result=result∪t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(result发生变化);</span><br></pre></td></tr></table></figure><p>直到一轮<code>while</code>循环之后<code>result</code>不发生变化或者中途验证了结论正确（β在<code>result</code>中，即α→β保持了）才停止。</p><h3 id="nf">1NF</h3><ul><li>最低要求的范式。</li><li>所有属性必须是原子值，不允许多值属性，复合属性及其组合。</li><li>当前关系数据库的表都是这种表，也就是通过<code>create table...</code>创建出的表都属于1NF。</li></ul><h3 id="nf-1">2NF</h3><ul><li>符合1NF，且所有的非主属性都完全依赖于主属性。</li><li>换言之，如果存在违背2NF的函数依赖，即存在一个非平凡函数依赖，非主属性由键的一部分决定，即不属于2NF。</li><li>主属性：键中的属性。</li><li>2NF要求有主键（实体唯一性）。</li></ul><h3 id="nf-2">3NF</h3><ul><li>符合2NF，并要求<strong>任何非主属性不依赖于其他非主属性，</strong>也就是在第二范式的基础上消除传递依赖（A-&gt;B-&gt;C）。</li><li>换言之，如果存在违背3NF的函数依赖，即<strong>当且仅当非平凡函数依赖箭头左边不是超键，箭头右边是非主属性</strong>，即不属于3NF。（这个非主属性可由键的一部分推出）</li><li>3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余（函数依赖级别的冗余）。</li><li>关系模式如果不能达到3NF及以上，会出现冗余和各种异常。</li><li>是对BCNF条件的妥协让步。</li></ul><h4 id="保持函数依赖和无损连接的3nf模式分解">保持函数依赖和无损连接的3NF模式分解</h4><p>对于给定关系R以及在R上成立的函数依赖集合F，</p><ul><li><p>求F的最小函数依赖集合G。</p></li><li><p>对于G的每一个函数依赖X→A，将XA作为分解出的一个关系模式。即有几组就有几张表。</p></li><li><p>如果某个关系模式被另一个关系模式所包含，删除该关系模式。</p></li><li><p>如果上一步分解出的关系模式均不包含R的超键，则增加一个关系，其模式为R的任何一个键。（如果有一个包含则不增加）</p></li></ul><p>此方法分解出的关系模式一定满足3NF。</p><h3 id="bcnf">BCNF</h3><ul><li>符合3NF，并且<strong>主属性内部不能有部分或传递依赖</strong>。这将消除对主属性子集的依赖，使主属性保持最简。（Whenever a set of attributes of <em>R</em> is determining another attribute, it should determine <strong><em>all</em></strong> attributes of <em>R</em>.）<strong>BCNF既检查非主属性，又检查主属性。当只检查非主属性时，就成了第三范式。</strong></li><li>换言之，如果存在违背BCNF的函数依赖，即<strong>当且仅当非平凡函数依赖箭头左边不是超键的时候</strong>，即不属于BCNF。</li><li>推论：所有二元关系都是BCNF。</li><li>BCNF能消除大部分类型的冗余，但是不能消除“多值函数依赖”冗余。即试图把键的两个或多个集合值属性置于同一个关系中。</li></ul><h4 id="将关系分解成bcnf二叉分解">将关系分解成BCNF（二叉分解）</h4><p>给定不属于BCNF的关系R和在R上成立的函数依赖集合F。</p><ul><li>在F中找出违背BCNF的函数依赖X→B。</li><li>求X的属性闭包X+，并将X+中的属性做成一张表R1。</li><li>将R-(X+)+X中的属性做成一张表R2。</li><li>使用 <a href="#函数依赖集的投影">函数依赖集的投影</a> 的方法求R1、R2的函数依赖集合，并检查R1、R2是否有违背BCNF的函数依赖。如果有则重复上述步骤，否则停止分解。</li></ul><p>此方法能够保证无损分解、无损连接，但不一定能保持原有的函数依赖。如果在实际应用中找不到保证函数依赖BCNF分解方式（例如，函数依赖集合F={AB→C, C→B}，键为{AB}、{AC}，不违背3NF），则可以退回3NF。</p><h3 id="nf-3">4NF</h3><ul><li><strong>满足BCNF，消除非平凡且非FD的多值依赖(MVD)。</strong>4NF就是限制关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖。</li><li>也就是说，当一个表中的非主属性互相独立时（3NF），这些非主属性不应该有多值。若有多值就违反了第四范式。</li><li>通俗地说，这种情况是试图在一张表中说多个事情，但是一般来讲，一张表就讲一个事情。</li><li>如果存在违背4NF的多值依赖，即<strong>当且仅当非平凡MVD（或者非平凡FD）箭头左边不是超键的时候</strong>，即不属于4NF。但是此时的键和超键的定义跟原来是一样的，都是基于一般的函数依赖。</li><li>推论：只有两个属性的表是BCNF，也是4NF。</li></ul><h4 id="分解成4nf">分解成4NF</h4><ul><li>关键：对于多值依赖X→→Y，使子模式的Z=Ø，仅有平凡多值依赖。</li><li>方法与BCNF分解类似。对于给定关系R，若找出违背4NF的多值依赖A1,A2,...,An→→B1,B2,...,Bm，则R可分解为两个模式：R1(A,B)，R2(A及R中所有不属于A和B的其他属性)。再用 <a href="#投影MVD">投影MVD</a> 的方法求R1、R2的函数依赖和多值依赖，并检查R1、R2是否有违背4NF的多值依赖。如果有则重复上述步骤，否则停止分解。</li></ul><h3 id="nf-4">5NF</h3><ul><li>是最终范式。<strong>消除连接依赖，并且必须保证数据完整性</strong>。</li><li>第四范式处理的是相互独立的多值情况，而第五范式则处理相互依赖的多值情况。</li></ul><h3 id="范式之间的联系">范式之间的联系</h3><p>范式之间存在包含关系。一个数据库设计如果符合第二范式，一定也符合第一范式。如果符合第三范式，一定也符合第二范式，依次类推。</p><table><thead><tr class="header"><th>性质</th><th>3NF</th><th>BCNF</th><th>4NF</th></tr></thead><tbody><tr class="odd"><td>消除FD带来的冗余</td><td>否</td><td>是</td><td>是</td></tr><tr class="even"><td>消除MVD带来的冗余</td><td>否</td><td>否</td><td>是</td></tr><tr class="odd"><td>保持FD</td><td>是</td><td>否</td><td>否</td></tr><tr class="even"><td>保持MVD</td><td>否</td><td>否</td><td>否</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;大二学数据库时候的笔记，这段时间要准备面试，所以现在把它抖出来。但是我应该看不太懂了。&lt;/p&gt;
&lt;p&gt;我要是在学操作系统和计算机网络的时候也有笔记就好了，这样就不愁面试了。&lt;/p&gt;
&lt;p&gt;哦，原来数据库考索引多一些，大学白学了。&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://lovebettygirl.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="https://lovebettygirl.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="范式" scheme="https://lovebettygirl.github.io/tags/%E8%8C%83%E5%BC%8F/"/>
    
    <category term="依赖" scheme="https://lovebettygirl.github.io/tags/%E4%BE%9D%E8%B5%96/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】454. 四数相加2</title>
    <link href="https://lovebettygirl.github.io/posts/7d64e6bd/"/>
    <id>https://lovebettygirl.github.io/posts/7d64e6bd/</id>
    <published>2021-04-02T11:20:53.000Z</published>
    <updated>2021-04-03T16:47:13.474Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/4sum-ii/" class="uri">https://leetcode-cn.com/problems/4sum-ii/</a></p><p>这次刷题居然是最有成就感的一次。。。</p><a id="more"></a><h2 id="题目描述">题目描述</h2><p>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 <code>(i, j, k, l)</code> ，使得 <code>A[i] + B[j] + C[k] + D[l] = 0</code>。</p><p>为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。</p><p><strong>例如:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">A = <span class="comment">[ 1, 2]</span></span><br><span class="line">B = <span class="comment">[-2,-1]</span></span><br><span class="line">C = <span class="comment">[-1, 2]</span></span><br><span class="line">D = <span class="comment">[ 0, 2]</span></span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">两个元组如下:</span><br><span class="line">1. (0, 0, 0, 1) -&gt; A<span class="comment">[0]</span> + B<span class="comment">[0]</span> + C<span class="comment">[0]</span> + D<span class="comment">[1]</span> = 1 + (-2) + (-1) + 2 = 0</span><br><span class="line">2. (1, 1, 0, 0) -&gt; A<span class="comment">[1]</span> + B<span class="comment">[1]</span> + C<span class="comment">[0]</span> + D<span class="comment">[0]</span> = 2 + (-1) + (-1) + 0 = 0</span><br></pre></td></tr></table></figure><h2 id="暴力解法会超时">暴力解法（会超时）</h2><p>最容易想的也是我最初只想到的就是暴力解法，但是肯定会超时</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; C, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; D)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; B.size(); j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; C.size(); k++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; D.size(); l++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (A[i] + B[j] + C[k] + D[l] == <span class="number">0</span>)</span><br><span class="line">                            count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(n^4)\)</span></p><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p><h2 id="哈希表">哈希表</h2><p>起初是使用两数之和那道题的思想，使用哈希表存储数组 <code>A</code> 中的信息，在哈希表中查找 <code>0 - B[j] - C[k] - D[l]</code> 对应的位置。这样就把4层for循环分成1个1层循环和1个3层循环，时间复杂度就降到 <span class="math inline">\(O(n^3)\)</span> 了。然后就又想到拆成两个两层for循环。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; C, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; D)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m; <span class="comment">// 哈希表中存储的是-(A[i] + B[j])对应的结果个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; B.size(); j++) &#123;</span><br><span class="line">                m[-(A[i] + B[j])]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; C.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; D.size(); j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> key = C[i] + D[j];</span><br><span class="line">                <span class="keyword">if</span> (m.find(key) != m.end())</span><br><span class="line">                    count += m[key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(n^2)\)</span></p><p>空间复杂度：<span class="math inline">\(O(n^2)\)</span></p><h2 id="注意">注意</h2><p>以下的代码会让程序使用内存更大。因为如果不预先判断 <code>map</code> 或者 <code>unordered_map</code> 中是否会有键相应的值，直接使用的话就会为这个键创建一个默认值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; C, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; D)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; B.size(); j++) &#123;</span><br><span class="line">                m[-(A[i] + B[j])]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; C.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; D.size(); j++) &#123;</span><br><span class="line">                count += m[C[i] + D[j]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode-cn.com/problems/4sum-ii/&quot; class=&quot;uri&quot;&gt;https://leetcode-cn.com/problems/4sum-ii/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这次刷题居然是最有成就感的一次。。。&lt;/p&gt;</summary>
    
    
    
    <category term="刷题" scheme="https://lovebettygirl.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    <category term="LeetCode" scheme="https://lovebettygirl.github.io/categories/%E5%88%B7%E9%A2%98/LeetCode/"/>
    
    
    <category term="C++" scheme="https://lovebettygirl.github.io/tags/C/"/>
    
    <category term="LeetCode" scheme="https://lovebettygirl.github.io/tags/LeetCode/"/>
    
    <category term="算法" scheme="https://lovebettygirl.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="哈希表" scheme="https://lovebettygirl.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】202. 快乐数</title>
    <link href="https://lovebettygirl.github.io/posts/6960ebdc/"/>
    <id>https://lovebettygirl.github.io/posts/6960ebdc/</id>
    <published>2021-03-31T13:14:26.000Z</published>
    <updated>2021-04-03T16:47:13.471Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/happy-number/" class="uri">https://leetcode-cn.com/problems/happy-number/</a></p><p>这题一点都不快乐……</p><a id="more"></a><h2 id="题目描述">题目描述</h2><p>编写一个算法来判断一个数 <code>n</code> 是不是快乐数。</p><p>「快乐数」定义为：</p><ul><li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li><li>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。</li><li>如果 <strong>可以变为</strong> 1，那么这个数就是快乐数。</li></ul><p>如果 <code>n</code> 是快乐数就返回 <code>true</code> ；不是，则返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight parser3"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">输入：</span><span class="number">19</span></span><br><span class="line"><span class="xml">输出：true</span></span><br><span class="line"><span class="xml">解释：</span></span><br><span class="line"><span class="number">1</span><span class="keyword">^2</span><span class="xml"> + </span><span class="number">9</span><span class="keyword">^2</span><span class="xml"> = </span><span class="number">82</span></span><br><span class="line"><span class="number">8</span><span class="keyword">^2</span><span class="xml"> + </span><span class="number">2</span><span class="keyword">^2</span><span class="xml"> = </span><span class="number">68</span></span><br><span class="line"><span class="number">6</span><span class="keyword">^2</span><span class="xml"> + </span><span class="number">8</span><span class="keyword">^2</span><span class="xml"> = </span><span class="number">100</span></span><br><span class="line"><span class="number">1</span><span class="keyword">^2</span><span class="xml"> + </span><span class="number">0</span><span class="keyword">^2</span><span class="xml"> + </span><span class="number">0</span><span class="keyword">^2</span><span class="xml"> = </span><span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">n</span> = <span class="number">2</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 2^31 - 1</code></li></ul><h2 id="一种投机取巧的方法">一种投机取巧的方法</h2><p>没想到怎么做，但还是有机会通过的。反正是觉得肯定是判断了一定的次数没判断出来那就认为不是快乐数。假设测试用例给出的数如果是快乐数，都可以在判断10000次（也许不需要这么多次）以内得出结果，那就：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> index = n % <span class="number">10</span>;</span><br><span class="line">                sum += index * index;</span><br><span class="line">                n = n / <span class="number">10</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (n);</span><br><span class="line">            <span class="keyword">if</span> (sum == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            n = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>据官方题解评论区，其实只需要判断10次就可以了！</p><figure><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210331213231190.png" alt><figcaption>image-20210331213231190</figcaption></figure><h2 id="哈希表">哈希表</h2><p>可以使用哈希表记录得出过的平方和。题目上说「无限循环」就说明某个平方和在计算的过程中肯定会出现至少两次（我怎么没想到），那就用哈希表判断一下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> index = n % <span class="number">10</span>;</span><br><span class="line">                sum += index * index;</span><br><span class="line">                n = n / <span class="number">10</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (n);</span><br><span class="line">            <span class="keyword">if</span> (s.find(sum) != s.end()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            n = sum;</span><br><span class="line">            s.insert(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另外，计算过程中出现的所有平方和不会无限增大，可以这样理解：</p><blockquote><p>因为即使一个数很大，它每个位置上的数字的平方和都不会很大。例如对于数字 <code>9999999999999</code> （13个9）来说，它每个位置上的数字的平方和为 <code>1053</code> （13为数每个位置上数字的平方和不会超过这个数），而 <code>1053</code> 每个位置上的数字的平方和就更小了。</p></blockquote><p><a href="https://leetcode-cn.com/problems/happy-number/solution/kuai-le-de-zhi-shi-dian-zeng-jia-liao-by-sweetiee/">某个大佬的题解</a>中有对应的证明，证明对一个数字计算每个位置上数字的平方和，结果会急剧减小。</p><h2 id="双指针快慢指针">双指针（快慢指针）</h2><p>当一个数很大的时候，计算过程中产生的平方和可能会导致哈希表所占的内存空间非常大。那么，如果将计算过程中出现的所有平方和都增加一个链表的尾部，那么将会形成一个有环的链表！就可以使用链表找环的方式求解！可以让空间复杂度变为 <span class="math inline">\(O(1)\)</span>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> index = n % <span class="number">10</span>;</span><br><span class="line">            sum += index * index;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (n);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fast = n, slow = n;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            slow = getNext(slow);</span><br><span class="line">            fast = getNext(getNext(fast));</span><br><span class="line">        &#125; <span class="keyword">while</span> (fast != slow);</span><br><span class="line">        <span class="keyword">return</span> fast == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210331233727506.png" alt="image-20210331233727506" style="zoom:50%;"></p><h2 id="总结">总结</h2><ul><li>总之，涉及到哈希表的题都和「检查是否重复」有关，以后做这类的题就往这个方向考虑吧</li><li>有的题可以转换成经典模型求解，比如这道题可以转换成判断链表是否有环的模型</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode-cn.com/problems/happy-number/&quot; class=&quot;uri&quot;&gt;https://leetcode-cn.com/problems/happy-number/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这题一点都不快乐……&lt;/p&gt;</summary>
    
    
    
    <category term="刷题" scheme="https://lovebettygirl.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    <category term="LeetCode" scheme="https://lovebettygirl.github.io/categories/%E5%88%B7%E9%A2%98/LeetCode/"/>
    
    
    <category term="C++" scheme="https://lovebettygirl.github.io/tags/C/"/>
    
    <category term="LeetCode" scheme="https://lovebettygirl.github.io/tags/LeetCode/"/>
    
    <category term="双指针" scheme="https://lovebettygirl.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="哈希表" scheme="https://lovebettygirl.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】142. 环形链表2</title>
    <link href="https://lovebettygirl.github.io/posts/f0fa686e/"/>
    <id>https://lovebettygirl.github.io/posts/f0fa686e/</id>
    <published>2021-03-30T11:08:22.000Z</published>
    <updated>2021-03-30T17:35:25.728Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" class="uri">https://leetcode-cn.com/problems/linked-list-cycle-ii/</a></p><p>双指针的解法非常重要，要时常拿出来看一下</p><a id="more"></a><h2 id="题目描述">题目描述</h2><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p><p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意，<code>pos</code> 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</strong></p><p><strong>说明：</strong>不允许修改给定的链表。</p><p><strong>进阶：</strong></p><ul><li>你是否可以使用 <code>O(1)</code> 空间解决此题？</li></ul><p><strong>示例 1：</strong></p><p><img data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img" style="zoom:50%;"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">head</span> = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,-<span class="number">4</span>], <span class="attr">pos</span> = <span class="number">1</span></span><br><span class="line">输出：返回索引为 <span class="number">1</span> 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img" style="zoom:50%;"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">head</span> = [<span class="number">1</span>,<span class="number">2</span>], <span class="attr">pos</span> = <span class="number">0</span></span><br><span class="line">输出：返回索引为 <span class="number">0</span> 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img" style="zoom:50%;"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">head</span> = [<span class="number">1</span>], <span class="attr">pos</span> = -<span class="number">1</span></span><br><span class="line">输出：返回 <span class="literal">null</span></span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围在范围 <code>[0, 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li></ul><h2 id="哈希表">哈希表</h2><p>使用一个哈希表存储遍历过的节点。在遍历链表的过程中，如果该节点被遍历了两次（当前节点已经在哈希表中）则说明有环。若第一次出现被遍历过的节点，就返回该节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;ListNode*&gt; s;</span><br><span class="line">        ListNode *temp = head;</span><br><span class="line">        <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.find(temp) != s.end())</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            s.insert(temp);</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(n)\)</span></p><p>空间复杂度：<span class="math inline">\(O(n)\)</span></p><h2 id="双指针快慢指针">双指针（快慢指针）</h2><p>这个方法实在不好想出来，没想到数学推导才是重点啊！！！是我太菜了</p><p>定义快指针 <code>fast</code> 和慢指针 <code>slow</code> ，最初都指向头节点。快指针每次走两步，慢指针每次走一步，如果快慢指针相遇则说明链表有环（这个能想到，但相遇的位置不一定是<strong>链表开始入环的第一个节点</strong>）</p><p><img data-src="https://assets.leetcode-cn.com/solution-static/142/142_fig1.png" alt="fig1" style="zoom: 33%;"></p><p>借用官方题解的图，紫色的点是快指针和慢指针相遇节点位置。在相遇的时候，快指针走过的距离为： <span class="math display">\[a+n(b+c)+b=a+(n+1)b+nc\]</span> 快指针必须在环内走<span class="math inline">\(n (n\ge1)\)</span>圈才能和慢指针相遇。</p><p>而快指针走过的距离一定是慢指针走过的距离的两倍，则有： <span class="math display">\[a+(n+1)b+nc=2(a+b)\]</span> 解得： <span class="math display">\[a=(n-1)b+nc=(n-1)(b+c)+c\]</span> 即链表头节点到环的入口节点要走的距离等于<span class="math inline">\(c\)</span>再在环内走<span class="math inline">\(n-1\)</span>圈的距离。</p><p>这样，就新定义一个指针 <code>ptr</code> 指向头节点，<code>ptr</code> 和 <code>slow</code> 同时各走一步，相遇的位置即为链表开始入环的第一个节点。</p><p>特殊情况下，如果<span class="math inline">\(n\)</span>为<span class="math inline">\(1\)</span>，则<span class="math inline">\(a=c\)</span>， <code>slow</code> 走 <span class="math inline">\(c\)</span> 个节点的距离就能和 <code>ptr</code> 在链表开始入环的第一个节点相遇。</p><p>如果 <span class="math inline">\(n&gt;1\)</span> ，则 <code>slow</code> 必须在环内多转整整 <span class="math inline">\(n-1\)</span> 圈才能相遇。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *fast = head, *slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                ListNode *ptr = head;</span><br><span class="line">                <span class="keyword">while</span> (ptr != slow) &#123;</span><br><span class="line">                    ptr = ptr-&gt;next;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(n)\)</span></p><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p><h2 id="联动141.-环形链表">联动<a href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表</a></h2><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/" class="uri">https://leetcode-cn.com/problems/linked-list-cycle/</a></p><p>142和这道题相比，多了一个返回环的入口节点的要求，这道题仅仅只是判断有没有环</p><h3 id="哈希表-1">哈希表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;ListNode*&gt; s;</span><br><span class="line">        ListNode *temp = head;</span><br><span class="line">        <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.find(temp) != s.end())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            s.insert(temp);</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="双指针">双指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *fast = head, *slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="问题">问题</h2><h3 id="为何慢指针第一圈走不完一定会和快指针相遇即慢指针走了ab而不是a若干环的长度b呢">为何慢指针第一圈走不完一定会和快指针相遇？即慢指针走了a+b而不是a+若干环的长度+b呢</h3><p>引用评论区的一个评论：</p><blockquote><p>解释：为何慢指针第一圈走不完一定会和快指针相遇： 首先，第一步，快指针先进入环 第二步：当慢指针刚到达环的入口时，快指针此时在环中的某个位置（注意，快指针可能还没有走够一圈，可能已经走了超过一圈）(也可能此时相遇<strong>，此时相遇的位置就是环的入口节点</strong>) 第三步：设此时快指针和慢指针距离为x，若在第二步相遇，则x = 0； 第四步：设环的周长为n，那么看成快指针追赶慢指针，需要追赶n-x； 第五步：快指针每次都追赶慢指针1个单位，设慢指针速度1/s，快指针2/s，那么追赶需要(n-x)s 第六步：在n-x秒内，慢指针走了n-x单位，因为x&gt;=0，则慢指针走的路程小于等于n，即走不完一圈就和快指针相遇</p></blockquote><p>还有这个解释：<a href="https://mp.weixin.qq.com/s/vK0JjSTHfpAbs8evz5hH8A" class="uri">https://mp.weixin.qq.com/s/vK0JjSTHfpAbs8evz5hH8A</a></p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210330214649372.png" alt="image-20210330214649372" style="zoom:50%;"></p><p>对这里的理解：假设慢指针在进入环入口时，快指针在环的某个位置（但不是入口），快指针要走 <span class="math inline">\(k+n\)</span> 才能到达入口，相应地，慢指针要走 <span class="math inline">\((k+n)/2\)</span> （由于 <span class="math inline">\(k&lt;n\)</span>，所以 <span class="math inline">\((k+n)/2&lt;n\)</span>）。这样，如果快指针走到了入口，慢指针肯定没有走到入口，而且快指针就超过了慢指针，这显然不可能。因此，慢指针肯定没走够一圈就和快指针相遇了。</p><h3 id="为什么快指针每次必须走两步而不是三步">为什么快指针每次必须走两步，而不是三步？</h3><p>这样，两个指针可能不会相遇，而是快指针超过了慢指针，这样就死循环了。</p><blockquote><p>注意：假设把慢指针看作是静止的，那么快指针相对于慢指针的速度为走一步的速度；两个指针都进入环之后，可以看作是快指针追慢指针；如果快指针每次走两步，快指针是一个节点一个节点的靠近慢指针的，所以肯定可以和慢指针相遇，而不是跳过；如果快指针每次走三步，快指针相对于慢指针的速度为走两步的速度</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode-cn.com/problems/linked-list-cycle-ii/&quot; class=&quot;uri&quot;&gt;https://leetcode-cn.com/problems/linked-list-cycle-ii/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;双指针的解法非常重要，要时常拿出来看一下&lt;/p&gt;</summary>
    
    
    
    <category term="刷题" scheme="https://lovebettygirl.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    <category term="LeetCode" scheme="https://lovebettygirl.github.io/categories/%E5%88%B7%E9%A2%98/LeetCode/"/>
    
    
    <category term="C++" scheme="https://lovebettygirl.github.io/tags/C/"/>
    
    <category term="LeetCode" scheme="https://lovebettygirl.github.io/tags/LeetCode/"/>
    
    <category term="双指针" scheme="https://lovebettygirl.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="链表" scheme="https://lovebettygirl.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】19. 删除链表的倒数第N个结点</title>
    <link href="https://lovebettygirl.github.io/posts/1c8d5108/"/>
    <id>https://lovebettygirl.github.io/posts/1c8d5108/</id>
    <published>2021-03-30T10:26:56.000Z</published>
    <updated>2021-03-30T17:35:25.734Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" class="uri">https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/</a></p><a id="more"></a><h2 id="题目描述">题目描述</h2><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p><p><strong>示例 1：</strong></p><p><img data-src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="img" style="zoom:50%;"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1,2,3,4</span>,<span class="number">5</span>], n = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">1,2,3,5</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="comment">[1]</span>, n = 1</span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="comment">[1,2]</span>, n = 1</span><br><span class="line">输出：<span class="comment">[1]</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中结点的数目为 <code>sz</code></li><li><code>1 &lt;= sz &lt;= 30</code></li><li><code>0 &lt;= Node.val &lt;= 100</code></li><li><code>1 &lt;= n &lt;= sz</code></li></ul><h2 id="计算链表长度遍历两次">计算链表长度（遍历两次）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode *newHead = <span class="keyword">new</span> ListNode(), *temp;</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">0</span>, index = <span class="number">0</span>;</span><br><span class="line">        newHead-&gt;next = head;</span><br><span class="line">        temp = newHead;</span><br><span class="line">        <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        index = size - n;</span><br><span class="line">        temp = newHead;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        temp-&gt;next = temp-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> newHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="双指针快慢指针遍历一次">双指针（快慢指针，遍历一次）</h2><p>没想到这个方法，下次再来</p><p>定义快指针 <code>fast</code> 和慢指针 <code>slow</code> ，最初都指向虚拟头节点。快指针先单独走 <code>n + 1</code> 步，然后两个指针同时走，直到快指针走到链表末尾为止。此时慢指针指向节点的下一个节点就是要删除的节点（快指针先走 <code>n + 1</code> 步而不是 <code>n</code> 步的原因）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode *newHead = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode *fast = newHead, *slow = newHead;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        newHead-&gt;next = head;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++)</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (fast) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> newHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/&quot; class=&quot;uri&quot;&gt;https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="刷题" scheme="https://lovebettygirl.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    <category term="LeetCode" scheme="https://lovebettygirl.github.io/categories/%E5%88%B7%E9%A2%98/LeetCode/"/>
    
    
    <category term="C++" scheme="https://lovebettygirl.github.io/tags/C/"/>
    
    <category term="LeetCode" scheme="https://lovebettygirl.github.io/tags/LeetCode/"/>
    
    <category term="双指针" scheme="https://lovebettygirl.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="链表" scheme="https://lovebettygirl.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】206. 反转链表</title>
    <link href="https://lovebettygirl.github.io/posts/302b265c/"/>
    <id>https://lovebettygirl.github.io/posts/302b265c/</id>
    <published>2021-03-29T11:22:49.000Z</published>
    <updated>2021-03-29T13:38:58.057Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/reverse-linked-list/" class="uri">https://leetcode-cn.com/problems/reverse-linked-list/</a></p><p>大厂考的非常多的题，一定要反复刷，不能忘了，背下来吧！！！</p><a id="more"></a><h2 id="题目描述">题目描述</h2><p>反转一个单链表。</p><p><strong>示例:</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL</span><br><span class="line">输出: <span class="number">5</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong> 你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p><h2 id="我的方法迭代">我的方法（迭代）</h2><p>始终改变头节点指针 <code>head</code> 的指向</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr-&gt;next) &#123;</span><br><span class="line">            ListNode *temp = curr-&gt;next-&gt;next;</span><br><span class="line">            curr-&gt;next-&gt;next = head;</span><br><span class="line">            head = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="迭代">迭代</h2><p><code>curr</code> 表示当前遍历到的位置，<code>prev</code> 当前位置的上一个节点，<code>next</code> 是当前位置的下一个节点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *curr = head,  *prev = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">            <span class="comment">// 将原先的下一个节点记录下来，因为指向下一个节点的指针要指向原先的前一个节点</span></span><br><span class="line">            ListNode *next = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(n)\)</span></p><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p><h2 id="递归">递归</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当链表只有一个元素或者为空的时候，反转的结果就是自己</span></span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *temp = reverseList(head-&gt;next);</span><br><span class="line">        <span class="comment">// head-&gt;next-&gt;next：已经被反转的链表的末尾（NULL）</span></span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(n)\)</span></p><p>空间复杂度：<span class="math inline">\(O(n)\)</span>（递归调用栈空间最多为<span class="math inline">\(n\)</span>层，每一层的空间是常数级别）</p><blockquote><p><strong>递归算法的时间复杂度 = 递归的次数 * 每次递归的时间复杂度</strong></p><p><strong>递归算法的空间复杂度 = 每次递归的空间复杂度 * 递归深度</strong></p></blockquote><p>引用题解评论区的一句话辅助理解：</p><blockquote><p>递归的意思：我子节点下的所有节点都已经反转好了，现在就剩我和我的子节点 没有完成最后的反转了，所以反转一下我和我的子节点。</p></blockquote><p>一次递归操作前后示意图：</p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210329211641698.png" alt="image-20210329211641698" style="zoom:50%;"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-linked-list/&quot; class=&quot;uri&quot;&gt;https://leetcode-cn.com/problems/reverse-linked-list/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;大厂考的非常多的题，一定要反复刷，不能忘了，背下来吧！！！&lt;/p&gt;</summary>
    
    
    
    <category term="刷题" scheme="https://lovebettygirl.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    <category term="LeetCode" scheme="https://lovebettygirl.github.io/categories/%E5%88%B7%E9%A2%98/LeetCode/"/>
    
    
    <category term="C++" scheme="https://lovebettygirl.github.io/tags/C/"/>
    
    <category term="LeetCode" scheme="https://lovebettygirl.github.io/tags/LeetCode/"/>
    
    <category term="链表" scheme="https://lovebettygirl.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】707. 设计链表</title>
    <link href="https://lovebettygirl.github.io/posts/b4e42ef2/"/>
    <id>https://lovebettygirl.github.io/posts/b4e42ef2/</id>
    <published>2021-03-28T07:43:18.000Z</published>
    <updated>2021-03-29T13:26:23.259Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/design-linked-list/" class="uri">https://leetcode-cn.com/problems/design-linked-list/</a></p><a id="more"></a><h2 id="题目描述">题目描述</h2><p>设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：<code>val</code> 和 <code>next</code>。<code>val</code> 是当前节点的值，<code>next</code> 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 <code>prev</code> 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。</p><p>在链表类中实现这些功能：</p><ul><li>get(index)：获取链表中第 <code>index</code> 个节点的值。如果索引无效，则返回<code>-1</code>。</li><li>addAtHead(val)：在链表的第一个元素之前添加一个值为 <code>val</code> 的节点。插入后，新节点将成为链表的第一个节点。</li><li>addAtTail(val)：将值为 <code>val</code> 的节点追加到链表的最后一个元素。</li><li>addAtIndex(index,val)：在链表中的第 <code>index</code> 个节点之前添加值为 <code>val</code> 的节点。如果 <code>index</code> 等于链表的长度，则该节点将附加到链表的末尾。如果 <code>index</code> 大于链表长度，则不会插入节点。如果<code>index</code>小于0，则在头部插入节点。</li><li>deleteAtIndex(index)：如果索引 <code>index</code> 有效，则删除链表中的第 <code>index</code>个节点。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyLinkedList linkedList = <span class="keyword">new</span> MyLinkedList();</span><br><span class="line">linkedList.addAtHead(<span class="number">1</span>);</span><br><span class="line">linkedList.addAtTail(<span class="number">3</span>);</span><br><span class="line">linkedList.addAtIndex(<span class="number">1</span>,<span class="number">2</span>);   <span class="comment">//链表变为1-&gt; 2-&gt; 3</span></span><br><span class="line">linkedList.get(<span class="number">1</span>);            <span class="comment">//返回2</span></span><br><span class="line">linkedList.deleteAtIndex(<span class="number">1</span>);  <span class="comment">//现在链表是1-&gt; 3</span></span><br><span class="line">linkedList.get(<span class="number">1</span>);            <span class="comment">//返回3</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>所有<code>val</code>值都在 <code>[1, 1000]</code> 之内。</li><li>操作次数将在 <code>[1, 1000]</code> 之内。</li><li>请不要使用内置的 LinkedList 库。</li></ul><h2 id="解法">解法</h2><p>没啥好说的，就是总是容易忘掉改变链表长度 <code>len</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    ListNode *head;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    MyLinkedList() &#123;</span><br><span class="line">        head = <span class="literal">nullptr</span>;</span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        ListNode *temp = head;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == index)</span><br><span class="line">                <span class="keyword">return</span> temp-&gt;val;</span><br><span class="line">            i++;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *temp = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">        temp-&gt;next = head;</span><br><span class="line">        head = temp;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Append a node of value val to the last element of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head)</span><br><span class="line">            addAtHead(val);</span><br><span class="line">        ListNode *temp = head;</span><br><span class="line">        <span class="keyword">while</span> (temp-&gt;next)</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        temp-&gt;next = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == len)</span><br><span class="line">            addAtTail(val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (index &lt;= <span class="number">0</span>)</span><br><span class="line">            addAtHead(val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (index &gt; len)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            ListNode *curr = head;</span><br><span class="line">            <span class="keyword">while</span> (curr-&gt;next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (curr-&gt;next &amp;&amp; i + <span class="number">1</span> == index) &#123;</span><br><span class="line">                    ListNode *temp = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">                    temp-&gt;next = curr-&gt;next;</span><br><span class="line">                    curr-&gt;next = temp;</span><br><span class="line">                    len++;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">                curr = curr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Delete the index-th node in the linked list, if the index is valid. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ListNode *temp = head;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (temp-&gt;next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> == index) &#123;</span><br><span class="line">                    temp-&gt;next = temp-&gt;next-&gt;next;</span><br><span class="line">                    len--;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">                temp = temp-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>学习一下别人的代码（使用虚拟头节点）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    ListNode *head; <span class="comment">// 虚拟头节点</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    MyLinkedList() &#123;</span><br><span class="line">        head = <span class="keyword">new</span> ListNode();</span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= len || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        ListNode *temp = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index + <span class="number">1</span>; i++)</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> temp-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *temp = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">        temp-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next = temp;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Append a node of value val to the last element of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *temp = head;</span><br><span class="line">        <span class="keyword">while</span> (temp-&gt;next)</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        temp-&gt;next = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; len)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        ListNode *curr = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        ListNode *temp = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">        temp-&gt;next = curr-&gt;next;</span><br><span class="line">        curr-&gt;next = temp;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Delete the index-th node in the linked list, if the index is valid. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= len || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        ListNode *temp = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        temp-&gt;next = temp-&gt;next-&gt;next;</span><br><span class="line">        len--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode-cn.com/problems/design-linked-list/&quot; class=&quot;uri&quot;&gt;https://leetcode-cn.com/problems/design-linked-list/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="刷题" scheme="https://lovebettygirl.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    <category term="LeetCode" scheme="https://lovebettygirl.github.io/categories/%E5%88%B7%E9%A2%98/LeetCode/"/>
    
    
    <category term="C++" scheme="https://lovebettygirl.github.io/tags/C/"/>
    
    <category term="LeetCode" scheme="https://lovebettygirl.github.io/tags/LeetCode/"/>
    
    <category term="链表" scheme="https://lovebettygirl.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】203. 移除链表元素</title>
    <link href="https://lovebettygirl.github.io/posts/381b9ed0/"/>
    <id>https://lovebettygirl.github.io/posts/381b9ed0/</id>
    <published>2021-03-28T06:33:39.000Z</published>
    <updated>2021-03-28T07:54:37.311Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/remove-linked-list-elements/" class="uri">https://leetcode-cn.com/problems/remove-linked-list-elements/</a></p><p>这么经典的题一定要能手撕啊！！！</p><a id="more"></a><h2 id="题目描述">题目描述</h2><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p><p><strong>示例 1：</strong></p><p><img data-src="https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg" alt="img" style="zoom:50%;"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="string">[1,2,6,3,4,5,6]</span>, val = <span class="number">6</span></span><br><span class="line">输出：<span class="string">[1,2,3,4,5]</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="comment">[]</span>, val = 1</span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="comment">[7,7,7,7]</span>, val = 7</span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>列表中的节点在范围 <code>[0, 10^4]</code> 内</li><li><code>1 &lt;= Node.val &lt;= 50</code></li><li><code>0 &lt;= k &lt;= 50</code></li></ul><h2 id="考虑头节点的删除逻辑">考虑头节点的删除逻辑</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (head &amp;&amp; head-&gt;val == val) &#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!head)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *temp = head;</span><br><span class="line">        <span class="keyword">while</span> (temp-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp-&gt;next-&gt;val == val) </span><br><span class="line">                temp-&gt;next = temp-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="使用虚拟头节点">使用虚拟头节点</h2><p>在真实头节点的前面新建虚拟头节点（其下一个节点为真实头节点）可以统一所有节点的删除逻辑。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *newHead = <span class="keyword">new</span> ListNode(), *temp;</span><br><span class="line">        newHead-&gt;next = head;</span><br><span class="line">        temp = newHead;</span><br><span class="line">        <span class="keyword">while</span> (temp-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp-&gt;next-&gt;val == val) </span><br><span class="line">                temp-&gt;next = temp-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="递归">递归</h2><p>某个大佬在题解里给出来的。链表和二叉树一样都是递归的结构，所以也可以用递归。每次都写不好递归终止的条件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        head-&gt;next = removeElements(head-&gt;next, val);</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;val == val)</span><br><span class="line">            <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="注意">注意</h2><p>在真实的链表删除场景下，如果使用C++应该将删除的节点内存释放掉，虚拟头节点也是。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode-cn.com/problems/remove-linked-list-elements/&quot; class=&quot;uri&quot;&gt;https://leetcode-cn.com/problems/remove-linked-list-elements/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这么经典的题一定要能手撕啊！！！&lt;/p&gt;</summary>
    
    
    
    <category term="刷题" scheme="https://lovebettygirl.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    <category term="LeetCode" scheme="https://lovebettygirl.github.io/categories/%E5%88%B7%E9%A2%98/LeetCode/"/>
    
    
    <category term="C++" scheme="https://lovebettygirl.github.io/tags/C/"/>
    
    <category term="LeetCode" scheme="https://lovebettygirl.github.io/tags/LeetCode/"/>
    
    <category term="链表" scheme="https://lovebettygirl.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】59. 螺旋矩阵2</title>
    <link href="https://lovebettygirl.github.io/posts/cfb5c3b1/"/>
    <id>https://lovebettygirl.github.io/posts/cfb5c3b1/</id>
    <published>2021-03-27T15:42:59.000Z</published>
    <updated>2021-03-28T06:47:02.387Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">https://leetcode-cn.com/problems/spiral-matrix-ii/</a></p><p>总算有一道完成最快的中等题了……</p><a id="more"></a><h2 id="题目描述">题目描述</h2><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n^2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p><p><strong>示例 1：</strong></p><figure><img data-src="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg" alt><figcaption>img</figcaption></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span></span><br><span class="line">输出：<span class="string">[[1,2,3],[8,9,4],[7,6,5]]</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：<span class="string">[[1]]</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li></ul><h2 id="按层模拟">按层模拟</h2><p>从外层到内层模拟矩阵生成，将数字依次填入空矩阵中，找出循环规律即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n - i; j++) &#123;</span><br><span class="line">                result[i][j] = ++count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n - i; j++) &#123;</span><br><span class="line">                result[j][n - <span class="number">1</span> - i] = ++count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">2</span> - i; j &gt;= i; j--) &#123;</span><br><span class="line">                result[n - <span class="number">1</span> - i][j] = ++count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">2</span> - i; j &gt; i; j--) &#123;</span><br><span class="line">                result[j][i] = ++count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(n^{2})\)</span></p><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p><p><img data-src="https://self-image-bucket.oss-cn-beijing.aliyuncs.com/img/image-20210328021723779.png" alt="image-20210328021723779" style="zoom:50%;"></p><h2 id="按方向模拟">按方向模拟</h2><p>参考官方题解，可以按照行走的方向进行模拟，如果出现了超越数组边界或者遇到已经走过的位置的情况，则转向：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">int</span> direction[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>, col = <span class="number">-1</span>, currDir = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (count &lt; n * n) &#123;</span><br><span class="line">            <span class="keyword">int</span> newRow = row + direction[currDir][<span class="number">0</span>], newCol = col + direction[currDir][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (newRow &gt;= n || newRow &lt; <span class="number">0</span> || newCol &gt;= n || newCol &lt; <span class="number">0</span> || result[newRow][newCol] != <span class="number">0</span>)</span><br><span class="line">                currDir = (currDir + <span class="number">1</span>) % <span class="number">4</span>;;</span><br><span class="line">            row += direction[currDir][<span class="number">0</span>];</span><br><span class="line">            col += direction[currDir][<span class="number">1</span>];</span><br><span class="line">            result[row][col] = ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(n^{2})\)</span></p><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode-cn.com/problems/spiral-matrix-ii/&quot;&gt;https://leetcode-cn.com/problems/spiral-matrix-ii/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;总算有一道完成最快的中等题了……&lt;/p&gt;</summary>
    
    
    
    <category term="刷题" scheme="https://lovebettygirl.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    <category term="LeetCode" scheme="https://lovebettygirl.github.io/categories/%E5%88%B7%E9%A2%98/LeetCode/"/>
    
    
    <category term="C++" scheme="https://lovebettygirl.github.io/tags/C/"/>
    
    <category term="LeetCode" scheme="https://lovebettygirl.github.io/tags/LeetCode/"/>
    
    <category term="数组" scheme="https://lovebettygirl.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="矩阵" scheme="https://lovebettygirl.github.io/tags/%E7%9F%A9%E9%98%B5/"/>
    
    <category term="模拟" scheme="https://lovebettygirl.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】209. 长度最小的子数组</title>
    <link href="https://lovebettygirl.github.io/posts/22db2e16/"/>
    <id>https://lovebettygirl.github.io/posts/22db2e16/</id>
    <published>2021-03-26T09:02:27.000Z</published>
    <updated>2021-03-28T04:25:22.514Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">https://leetcode-cn.com/problems/minimum-size-subarray-sum/</a></p><a id="more"></a><h2 id="题目描述">题目描述</h2><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> 。</p><p>找出该数组中满足其和 <code>≥ target</code> 的长度最小的 连续子数组 <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度。如果不存在符合条件的子数组，返回 <code>0</code> 。</p><p>示例 1：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 7, nums = <span class="comment">[2,3,1,2,4,3]</span></span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 <span class="comment">[4,3]</span> 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">target</span> = <span class="number">4</span>, <span class="attr">nums</span> = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = <span class="number">11</span>, nums = [<span class="number">1,1,1,1</span>,<span class="number">1,1,1,1</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= target &lt;= 10^9</code></li><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>1 &lt;= nums[i] &lt;= 10^5</code></li></ul><p>进阶：</p><ul><li>如果你已经实现 <code>O(n)</code> 时间复杂度的解法, 请尝试设计一个 <code>O(n log(n))</code> 时间复杂度的解法。</li></ul><h2 id="暴力解法">暴力解法</h2><p>也不知道怎么回事，想出来的第一个暴力解法居然是3个for循环的，于是就理所应当地在最后一个例子那里超时了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="keyword">int</span> minSum = INT_MAX, len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (len = <span class="number">1</span>; len &lt;= size; len++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - len + <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++)</span><br><span class="line">                    sum += nums[i + j];</span><br><span class="line">                <span class="keyword">if</span> (sum &lt; minSum &amp;&amp; sum &gt;= target)</span><br><span class="line">                    minSum = sum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (minSum &gt;= target &amp;&amp; minSum &lt; INT_MAX)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minSum &lt; INT_MAX ? len : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><del>经过题解的提示写出</del>两个for循环的版本，可以通过：</p><p>（我怎么没想到第二个循环可以边遍历边求和，只需要满足条件的最小长度就行）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="keyword">int</span> minLen = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>, j;</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &lt; size; j++) &#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt;= target) &#123;</span><br><span class="line">                    minLen = min(minLen, j - i + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minLen &lt; INT_MAX ? minLen : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(n^{2})\)</span></p><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p><h2 id="使用滑动窗口">使用滑动窗口</h2><p><code>i</code> 作为滑动窗口的起始位置，<code>j</code> 作为滑动窗口的末尾，<code>sum</code> 是在窗口内的数组元素的和。在不满足<code>sum &gt;= target</code>的条件先在末尾处扩大窗口，满足了之后再在起始处缩小窗口直到不满足条件为止。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, minLen = INT_MAX;</span><br><span class="line">        <span class="comment">// 在不满足sum &gt;= target的条件先扩大窗口</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">            <span class="comment">// 缩小窗口</span></span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">                minLen = min(minLen, j - i + <span class="number">1</span>);</span><br><span class="line">                sum -= nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minLen &lt; INT_MAX ? minLen : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(n)\)</span>（指针 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(j\)</span> 最多不会移动超过 <span class="math inline">\(n\)</span> 次，两个指针移动的总次数不会超过 <span class="math inline">\(2n\)</span> 次）</p><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p><h2 id="前缀和二分查找">前缀和+二分查找</h2><p>进阶问题需要的解法</p><p>需要开辟一个数组 <code>sums</code> 存放 <code>nums</code> 数组各个元素的前缀和，<code>sums[i]</code> 表示从 <code>nums[0]</code> 到 <code>nums[i−1]</code> 的元素之和，长度为 <code>nums</code> 数组的长度 + 1。原数组 <code>nums</code> 不是有序的，但是 <code>sums</code> 是递增的，可以进行二分查找。</p><p>遍历 <code>sums</code> 数组，通过二分查找找到 <code>&gt;= sums[i - 1] + target</code> 的第一个前缀和的位置 <code>j</code>。</p><p>这样题目的条件转化成 <code>sums[j] - sums[i - 1] &gt;= target</code>，对应于原数组 <code>nums</code> ，就是在 <code>i - 1 &lt;= pos &lt;= j - 1</code> 之间的元素总和 <code>&gt;= target</code>，这部分子数组的长度为 <code>j - i + 1</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size();</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="keyword">int</span> minLen = INT_MAX;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sums</span><span class="params">(size + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= size; i++) &#123;</span><br><span class="line">            sums[i] = sums[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= size; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> s = target + sums[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> index = binarySearch(s, sums);</span><br><span class="line">            <span class="keyword">if</span> (index &lt;= size)</span><br><span class="line">                minLen = min(minLen, index - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minLen &lt; INT_MAX ? minLen : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(n\log n)\)</span></p><p>空间复杂度：<span class="math inline">\(O(n)\)</span></p><h2 id="总结">总结</h2><ul><li>当涉及到<strong><em>连续子数组</em></strong>的时候可以考虑的方法：滑动窗口、前缀和<ul><li>构造前缀和数组是构造一个有序数组的思路之一，数组有序就可以尝试使用二分查找、双指针等方法</li></ul></li><li>使用双指针和滑动窗口都可以减少for循环的层数，降低时间复杂度<ul><li>滑动窗口是根据当前子序列和大小的情况，不断调节子序列的<strong><em>起始位置</em></strong></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode-cn.com/problems/minimum-size-subarray-sum/&quot;&gt;https://leetcode-cn.com/problems/minimum-size-subarray-sum/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="刷题" scheme="https://lovebettygirl.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    <category term="LeetCode" scheme="https://lovebettygirl.github.io/categories/%E5%88%B7%E9%A2%98/LeetCode/"/>
    
    
    <category term="C++" scheme="https://lovebettygirl.github.io/tags/C/"/>
    
    <category term="LeetCode" scheme="https://lovebettygirl.github.io/tags/LeetCode/"/>
    
    <category term="滑动窗口" scheme="https://lovebettygirl.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
    <category term="二分查找" scheme="https://lovebettygirl.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
</feed>
